[
  
  {
    "title": "Trie êµ¬í˜„",
    "url": "/posts/Trie/",
    "categories": "Study, Algorithm",
    "tags": "Trie",
    "date": "2025-02-03 14:11:04 +0900",
    





    
    "snippet": "Trie ìë£Œêµ¬ì¡° (C++ êµ¬í˜„)ë¬¸ìì—´ì„ ì €ì¥í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰í•˜ê¸° ìœ„í•œ íŠ¸ë¦¬ ê¸°ë°˜ì˜ ìë£Œêµ¬ì¡°.  ë‹¨ì–´ ì‚½ì…: ë‹¨ì–´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìŒ.  ë‹¨ì–´ ê²€ìƒ‰: ì €ì¥ëœ ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆìŒ.  ì ‘ë‘ì‚¬ ê²€ìƒ‰: ì£¼ì–´ì§„ ì ‘ë‘ì‚¬ë¥¼ ê°–ëŠ” ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ íƒìƒ‰í•  ìˆ˜ ìˆìŒ.1. TrieNode êµ¬ì¡°ì²´Trieì˜ ê¸°ë³¸ êµ¬ì„± ë‹¨ìœ„ëŠ” TrieNod...",
    "content": "Trie ìë£Œêµ¬ì¡° (C++ êµ¬í˜„)ë¬¸ìì—´ì„ ì €ì¥í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰í•˜ê¸° ìœ„í•œ íŠ¸ë¦¬ ê¸°ë°˜ì˜ ìë£Œêµ¬ì¡°.  ë‹¨ì–´ ì‚½ì…: ë‹¨ì–´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìŒ.  ë‹¨ì–´ ê²€ìƒ‰: ì €ì¥ëœ ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆìŒ.  ì ‘ë‘ì‚¬ ê²€ìƒ‰: ì£¼ì–´ì§„ ì ‘ë‘ì‚¬ë¥¼ ê°–ëŠ” ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ íƒìƒ‰í•  ìˆ˜ ìˆìŒ.1. TrieNode êµ¬ì¡°ì²´Trieì˜ ê¸°ë³¸ êµ¬ì„± ë‹¨ìœ„ëŠ” TrieNodeì´ë‹¤.  children: ì•ŒíŒŒë²³ 26ê°œ(ëŒ€ë¬¸ì â€˜Aâ€™ ~ â€˜Zâ€™)ì— ëŒ€ì‘í•˜ëŠ” ìì‹ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” í¬ì¸í„° ë°°ì—´          TrieNode* children[26]: ê° ì¸ë±ìŠ¤ëŠ” í•´ë‹¹ ì•ŒíŒŒë²³ì— í•´ë‹¹í•˜ëŠ” ìì‹ ë…¸ë“œ ê°€ë¦¬í‚´.        isEnd: í˜„ì¬ ë…¸ë“œê°€ ë‹¨ì–´ì˜ ë(ì¢…ë£Œ ë…¸ë“œ)ì¸ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ê°’          ë‹¨ì–´ ì‚½ì… ì‹œ ë§ˆì§€ë§‰ ë¬¸ìì— í•´ë‹¹í•˜ëŠ” ë…¸ë“œì—ì„œ isEndë¥¼ trueë¡œ ì„¤ì •í•¨í•¨.      struct TrieNode {    TrieNode* children[26]; // 26ê°œì˜ ìì‹ ë…¸ë“œ    bool isEnd;             // ë‹¨ì–´ì˜ ëì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸    TrieNode() {        isEnd = false;        for (int i = 0; i &lt; 26; i++)             children[i] = nullptr;    }};2. Trie í´ë˜ìŠ¤class Trie {private:    TrieNode* root; // Trieì˜ ë£¨íŠ¸ ë…¸ë“œpublic:    Trie() {         root = new TrieNode(); // ë£¨íŠ¸ ë…¸ë“œ ì´ˆê¸°í™”    }    // ...};3. ë©”ì†Œë“œ ì„¤ëª…3.1. ë‹¨ì–´ ì‚½ì… (insert)  ë¬¸ìì—´ì„ Trieì— ì‚½ì…í•œë‹¤.  ë™ì‘ ê³¼ì •:          ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘.      ë‹¨ì–´ì˜ ê° ë¬¸ìì— ëŒ€í•´, í•´ë‹¹ ë¬¸ìë¥¼ ì¸ë±ìŠ¤(c - 'A')ë¡œ ë³€í™˜.      ë§Œì•½ í•´ë‹¹ ì¸ë±ìŠ¤ì— ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ë©´ ìƒˆë¡œìš´ TrieNodeë¥¼ ìƒì„±.      í•´ë‹¹ ìì‹ ë…¸ë“œë¡œ ì´ë™.      ë‹¨ì–´ì˜ ë§ˆì§€ë§‰ ë¬¸ìê¹Œì§€ ì²˜ë¦¬í•œ í›„, ë§ˆì§€ë§‰ ë…¸ë“œì˜ isEndë¥¼ trueë¡œ ì„¤ì •.      void insert(const string&amp; word) {    TrieNode* node = root;    for (char c : word) {        int index = c - 'A';        if (!node-&gt;children[index]) {            node-&gt;children[index] = new TrieNode();        }        node = node-&gt;children[index];    }    node-&gt;isEnd = true;}3.2. ë‹¨ì–´ ê²€ìƒ‰ (search)  Trieì— íŠ¹ì • ë‹¨ì–´ ì¡´ì¬ ì—¬ë¶€ í™•ì¸.  ë™ì‘ ê³¼ì •:          ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•˜ì—¬ ë‹¨ì–´ì˜ ê° ë¬¸ìë¥¼ ë”°ë¼ ì´ë™.      ë§Œì•½ ê²½ë¡œ ìƒì— í•´ë‹¹ ë¬¸ìë¥¼ ìœ„í•œ ë…¸ë“œê°€ ì—†ë‹¤ë©´ falseë¥¼ ë°˜í™˜.      ë‹¨ì–´ì˜ ëª¨ë“  ë¬¸ìë¥¼ íƒìƒ‰í•œ í›„, ë§ˆì§€ë§‰ ë…¸ë“œì˜ isEndê°€ trueì´ë©´ ë‹¨ì–´ê°€ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•œë‹¤.      bool search(const string&amp; word) {    TrieNode* node = root;    for (char c : word) {        int index = c - 'A';        if (!node-&gt;children[index])             return false;        node = node-&gt;children[index]; // ë‹¤ìŒ ë…¸ë“œë¡œ ì´ë™    }    return node-&gt;isEnd;}3.3. ì ‘ë‘ì‚¬ ê²€ìƒ‰ (startsWith)  Trieì— íŠ¹ì • ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ê°€ ìˆëŠ”ì§€ í™•ì¸.  ë™ì‘ ê³¼ì •:          ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•˜ì—¬ ì ‘ë‘ì‚¬ì˜ ê° ë¬¸ìë¥¼ ë”°ë¼ ì´ë™.      ë§Œì•½ ê²½ë¡œ ìƒì— í•´ë‹¹ ë¬¸ìë¥¼ ìœ„í•œ ë…¸ë“œê°€ ì—†ë‹¤ë©´ falseë¥¼ ë°˜í™˜.      ì ‘ë‘ì‚¬ì˜ ëª¨ë“  ë¬¸ìë¥¼ íƒìƒ‰í–ˆë‹¤ë©´, í•´ë‹¹ ê²½ë¡œê°€ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•˜ë¯€ë¡œ trueë¥¼ ë°˜í™˜.      bool startsWith(const string&amp; prefix) {    TrieNode* node = root;    for (char c : prefix) {        int index = c - 'A';        if (!node-&gt;children[index])             return false;        node = node-&gt;children[index];    }    return true;}4. ë©”ëª¨ë¦¬ ê´€ë¦¬~Trie() {    deleteNode(root);}private:void deleteNode(TrieNode* node) {    if (!node) return;    for (int i = 0; i &lt; 26; i++) {        deleteNode(node-&gt;children[i]);    }    delete node;}ì¬ê·€ì ìœ¼ë¡œ ëª¨ë“  ìì‹ ë…¸ë“œë¥¼ í•´ì œí•˜ì—¬ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€.í™œìš© ì˜ˆì‹œ  ìë™ì™„ì„±(Autocomplete): ì‚¬ìš©ìê°€ ì…ë ¥í•œ ì ‘ë‘ì‚¬ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°€ëŠ¥í•œ ë‹¨ì–´ë“¤ì„ ë¹ ë¥´ê²Œ ê²€ìƒ‰ ê°€ëŠ¥.  ì‚¬ì „ ê²€ìƒ‰: ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ë¹ ë¥´ê²Œ íŒë‹¨í•  ìˆ˜ ìˆë‹¤.  ë¬¸ìì—´ ì§‘í•© ê´€ë¦¬: ë¬¸ìì—´ë“¤ì˜ ì§‘í•©ì„ ê´€ë¦¬í•  ë•Œ ë¹ ë¥¸ ê²€ìƒ‰ ë° ì‚½ì…ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©.ì‹œê°„ ë³µì¡ë„  ì‚½ì… ì‹œê°„ ë³µì¡ë„: O(L), L: ë¬¸ìì—´ì˜ ê¸¸ì´  íƒìƒ‰ ì‹œê°„ ë³µì¡ë„: O(L)CPP êµ¬í˜„#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct TrieNode {    TrieNode* children[26]; // 26ê°œì˜ ìì‹ ë…¸ë“œ    bool isEnd; // ë‹¨ì–´ì˜ ëì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸    TrieNode() {        isEnd = false;        for (int i = 0; i &lt; 26; i++) children[i] = nullptr;    }};class Trie {private:    TrieNode* root;public:    Trie() { root = new TrieNode(); }    // ë‹¨ì–´ ì‚½ì…    void insert(const string&amp; word) {        TrieNode* node = root;        for (char c : word) {            int index = c - 'A';            if (!node-&gt;children[index]) {                node-&gt;children[index] = new TrieNode();            }            node = node-&gt;children[index];        }        node-&gt;isEnd = true;    }    // ë‹¨ì–´ ê²€ìƒ‰    bool search(const string&amp; word) {        TrieNode* node = root;        for (char c : word) {            int index = c - 'A';            if (!node-&gt;children[index]) return false;            node = node-&gt;children[index];        }        return node-&gt;isEnd;    }    // ì ‘ë‘ì‚¬ ê²€ìƒ‰    bool startsWith(const string&amp; prefix) {        TrieNode* node = root;        for (char c : prefix) {            int index = c - 'A';            if (!node-&gt;children[index]) return false;            node = node-&gt;children[index];        }        return true;    }    ~Trie() {        deleteNode(root);    }private:    // ë™ì  ë©”ëª¨ë¦¬ í•´ì œ (íŠ¸ë¼ì´ íŠ¸ë¦¬ ì „ì²´ ì‚­ì œ)    void deleteNode(TrieNode* node) {        if (!node) return;        for (int i = 0; i &lt; 26; i++) {            deleteNode(node-&gt;children[i]);        }        delete node;    }};ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°python êµ¬í˜„from typing import Listclass Node:    def __init__(self):        self.next: List[Node | None] = [None] * 26        self.end = Falseclass Trie:    def __init__(self):        self.root = Node()    def insert(self, s: str):        node = self.root        for ch in s:            ch = ord(ch) - ord('a')            if not node.next[ch]:                node.next[ch] = Node()            node = node.next[ch]        node.end = True        def search(self, s:str):        node = self.root        for ch in s:            ch = ord(ch) - ord('a')            if not node.next[ch]:                return False            node = node.next[ch]        return node.end    def print(self):        result = []        self.dfs(self.root, \"\", result)        print(result)    def dfs(self, node, word, result):        if node.end:            result.append(word)        for i in range(26):            if node.next[i]:                self.dfs(node.next[i], word+str(chr(i+ord('a'))), result)ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ê²Œì„ ë³´ë“œ ê´€ë ¨ ì¡ì„¤",
    "url": "/posts/Bot_note_3/",
    "categories": "Project, Discord_Bot",
    "tags": "Bot",
    "date": "2025-02-02 18:09:53 +0900",
    





    
    "snippet": "ì ìˆ˜íŒê³¼ ì¬ìƒ ì •ë³´ëŠ” board.rsì—ì„œ ë‹¤ë£¸register_channel.rsì—ì„œ ë“±ë¡í•œ í…ìŠ¤íŠ¸ ì±„ë„ì—ìŠ¤ë ˆë“œ ìƒì„±í›„ ì ìˆ˜íŒê³¼ ì¬ìƒ ì •ë³´ embedë¥¼ ê°±ì‹ í•˜ëŠ” ë°©ì‹ê³ ë ¤ì‚¬í•­  text channel ë“±ë¡ì—†ì´ play í•˜ëŠ” ê²½ìš°  â€¦24-05-22í˜„ì¬ boardì™€ guild_queueê°€ ë¶„ë¦¬ë˜ì–´ ìˆì–´ íŠ¸ë™ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œ boardì— ì ‘ê·¼í•˜ê¸° ë¶ˆí¸í•¨....",
    "content": "ì ìˆ˜íŒê³¼ ì¬ìƒ ì •ë³´ëŠ” board.rsì—ì„œ ë‹¤ë£¸register_channel.rsì—ì„œ ë“±ë¡í•œ í…ìŠ¤íŠ¸ ì±„ë„ì—ìŠ¤ë ˆë“œ ìƒì„±í›„ ì ìˆ˜íŒê³¼ ì¬ìƒ ì •ë³´ embedë¥¼ ê°±ì‹ í•˜ëŠ” ë°©ì‹ê³ ë ¤ì‚¬í•­  text channel ë“±ë¡ì—†ì´ play í•˜ëŠ” ê²½ìš°  â€¦24-05-22í˜„ì¬ boardì™€ guild_queueê°€ ë¶„ë¦¬ë˜ì–´ ìˆì–´ íŠ¸ë™ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œ boardì— ì ‘ê·¼í•˜ê¸° ë¶ˆí¸í•¨.ë‘ ê¸°ëŠ¥ì€ ê°™ì´ ë™ì‘í•˜ë¯€ë¡œ ê²°í•©ì‹œí‚¬ ì˜ˆì •GuildQueueì™€ Boardë¥¼ í•©ì¹˜ëŠ” ê³¼ì •ì¤‘pub async fn register_channel(&amp;self, channel: GuildChannel) {    let mut inner = self.inner.lock();    let channel_id = channel.id.into();    let http = inner.http.clone();    inner.board.set(http, channel).await;    inner.channel = Some(channel_id);}inner.board.set(http, channel).await; ë¼ì¸ì—ì„œ future is not Send as this value is used across an await ì—ëŸ¬ê°€ ë°œìƒí•¨.parking_lot::MutexGuardê°€ not Sendë¼ì„œ ë°œìƒí•˜ëŠ” ê²ƒ ê°™ì€ë°, GuildQueueì˜ Mutexë¥¼ tokio::sync::Mutexë¡œ ë³€ê²½í• ì§€GuildQueueì™€ Boardë¥¼ ë¶„ë¦¬í•  ì§€ ìƒê°í•´ë´ì•¼ê² ë‹¤.24-05-23boardì™€ guild_queueë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ê²°í•©í•¨. ìƒê¸°í•œ ë¬¸ì œê°€ ëë˜ ë¶€ë¶„ ë˜í•œ ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜ì •í•¨.pub struct GuildQueueCore {    // ...    board: Arc&lt;tokio::sync::Mutex&lt;Board&gt;&gt;,}pub async fn register_channel(&amp;self, channel: &amp;GuildChannel) {    let board_lock = {        let mut inner = self.inner.lock();        let channel_id = channel.id.into();        inner.channel = Some(channel_id);        inner.board.clone()    };        let mut board = board_lock.lock().await;    board.set(channel).await;}ê¸°ì¡´ ì½”ë“œ êµ¬ì¡°ì—ì„œ GuildQueueëŠ” ë™ê¸°ì ìœ¼ë¡œ ë™ì‘í–ˆìœ¼ë¯€ë¡œ ë³€ê²½ì„ ì¤„ì´ê¸° ìœ„í•´ Boardë§Œ tokio::sync::Mutexë¡œ ê°ìŒˆ.innerì˜ MutexGuardëŠ” not Sendì´ê¸° ë•Œë¬¸ì— ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì„œ await êµ¬ë¬¸ ì „ì— drop ì‹œì¼œì¤Œ.ìŒì•…ì˜ ì¬ìƒê³¼ ë©”ì„¸ì§€ì˜ ì—…ë°ì´íŠ¸ë¥¼ QueueHandlerì—ì„œ ë‹¤ë£¨ê¸° ìœ„í•´ì„œ í•˜ë‚˜ë¡œ í•©ì³¤ëŠ”ë°, async/awaitë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šë˜ ë¶€ë¶„ì— Boardë¥¼ ë¼ì›Œë„£ë‹¤ë³´ë‹ˆ ì „ì²´ì ì¸ êµ¬ì¡°ê°€ ì´ìƒí•´ì§„ ëŠë‚Œ.ë‚˜ì¤‘ì— ê³ ì³ì•¼ í•  ë“¯ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ìŒì„± ê´€ë ¨",
    "url": "/posts/Bot_note_2/",
    "categories": "Project, Discord_Bot",
    "tags": "Bot",
    "date": "2025-02-02 18:06:00 +0900",
    





    
    "snippet": "êµ¬ë²„ì „ì—ì„œ dca(Ogg to DCA converter)ë¼ê³  ëª…ëª…í•œ ogg packetì„ ì´ì–´ë¶™ì¸ ìì²´ í¬ë§·ëŒ€ì‹  symphonia crateë¥¼ ì‚¬ìš©í•´ ìŒì„± ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•¨.Input::Lazy ì˜ FlowYoutubeDl::into()     YoutubeDl::create_async (Compose trait êµ¬í˜„ ì‚¬í•­)        Http...",
    "content": "êµ¬ë²„ì „ì—ì„œ dca(Ogg to DCA converter)ë¼ê³  ëª…ëª…í•œ ogg packetì„ ì´ì–´ë¶™ì¸ ìì²´ í¬ë§·ëŒ€ì‹  symphonia crateë¥¼ ì‚¬ìš©í•´ ìŒì„± ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•¨.Input::Lazy ì˜ FlowYoutubeDl::into()     YoutubeDl::create_async (Compose trait êµ¬í˜„ ì‚¬í•­)        HttpRequest::create_async (Compose trait êµ¬í˜„ ì‚¬í•­)            HttpRequest::create_stream                reqwest::Client::get -&gt; reqwest::Response                reqwest::Response::bytes_stream -&gt; Box&lt;tokio_io::StreamReader&gt;                 Box&lt;tokio_io::StreamReader&gt; -&gt; songbird::HttpStream            songbird::HttpStream::stream -&gt; AsyncAdapterStream        songbird::HttpStream -&gt; songbird::AudioStream    return songbird::AudioStream create_streamì—ì„œ resumeë¥¼ ì´ìš©í•´ì„œ ê³„ì† íŒŒì¼ì„ ë°›ì•„ì˜¤ëŠ” ê²ƒ ê°™ìŒ.ì—°ì†ëœ ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼ì—ì„œ íŠ¹ì • ë¶€ë¶„ë§Œ ì˜ë¼ë‚´ëŠ”ê±´ ì–´ë ¤ì›Œë³´ì´ë¯€ë¡œ yt-dlpë¡œ ì›ë³¸ì„, ffmpegë¡œ ì˜ë¼ë‚¸ ë¶€ë¶„ì„ íŒŒì¼ë¡œ ì €ì¥ í›„ songbird::Fileì„ ì´ìš©í•´ì„œ songbird::Inputì„ ìƒì„±songbird::Callê³¼ songbird::Songbirdì˜ ë©”ì†Œë“œ ì°¨ì´ì songbird::CallëŠ” í•œ ì„œë²„ ë‚´ì˜ ìŒì„± ì—°ê²°ì„ ë‹´ë‹¹songbird::SongbirdëŠ” ë‚´ë¶€ì ìœ¼ë¡œ DashMapì„ ì‚¬ìš©í•´ ë””ìŠ¤ì½”ë“œ ì„œë²„ë§ˆë‹¤ songbird::Callì„ ê´€ë¦¬connection.rsì˜ ë‹¤ìŒ ë¶€ë¶„ì—ì„œ 1. | let manager = songbird::get(ctx).await.clone(); 2. | // ... 3. | if let Some(call) = manager.get(guild_id) { 4. |    let mut call = call.lock().await; 5. |    if let Some(bot_channel) = call.current_channel() { 6. |        // ...     7. |    } else { 8. |        match call.join(user_channel).await { 9. |            Ok(_) =&gt; Ok(ConnectionSuccessCode::NewConnection),10. |            Err(why) =&gt; Err(ConnectionErrorCode::JoinError(why))11. |        }12. |    }13. |    // ...14. | }ê¸°ì¡´ì— 8ë²ˆ ë¼ì¸ì˜ call.join(user_channel).await ëŒ€ì‹  manager.join(guild_id, user_channel).await ì‚¬ìš©í–ˆì—ˆëŠ”ë° ì´ ê²½ìš° DeadLock ë°œìƒí•¨.ì´ìœ ëŠ”  4ë²ˆ ë¼ì¸ì—ì„œ callì— ëŒ€í•œ Mutex íšë“  8ë²ˆ ë¼ì¸ ì‹¤í–‰ ì‹œ í•´ë‹¹ íë¦„ì€ block í›„ manager.joinì´ ë°˜í™˜ë  ë•Œ ê¹Œì§€ block  manager.joinì—ì„œ ë‹¤ì‹œ call ì— ëŒ€í•œ Mutex íšë“ ì‹œë„ í›„ ì ê²¨ ìˆìœ¼ë¯€ë¡œ block ë¨  ë”°ë¼ì„œ manager.joinì´ ë°˜í™˜ë˜ì§€ ëª»í•˜ê³ , í˜¸ì¶œìë„ block ë˜ì–´ ìˆê²Œ ë¨ì¼ë°˜ ì±„íŒ…ìœ¼ë¡œ ì¬ìƒì¤‘ì¸ ê³¡ì„ ìŠ¤í‚µí•˜ë ¤ë©´  ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì—ì„œ async fn message(&amp;self, ctx: Context, msg: Message)í•¨ìˆ˜ë¡œ ì±„íŒ… í™•ì¸  ì±„íŒ…ì´ íŠ¹ì • ì±„ë„ì—ì„œ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸  ì±„íŒ…ì´ ì¬ìƒ ì¤‘ì¸ ê³¡ì˜ í‚¤ì›Œë“œë‘ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸2ë²ˆì—ì„œ íŠ¹ì • ì±„ë„ì„ í™•ì¸í•˜ê¸° ìœ„í•´ ëª…ë ¹ì–´ë¡œ í™•ì¸í•  ì±„ë„ì„ ë“±ë¡í•˜ë„ë¡ í•¨ì´ëŠ” CommandDataOptionValueì— Channel(ChannelId) í•„ë“œê°€ ì¡´ì¬í•˜ë¯€ë¡œ ê°€ëŠ¥í•  ê²ƒìœ¼ë¡œ ë³´ì„ì¬ìƒ ì¤‘ì¸ ê³¡ì˜ í‚¤ì›Œë“œì™€ ì±„íŒ… ì±„ë„ì„ í™•ì¸í•˜ê¸° ìœ„í•´ TrackQueueë¥¼ ìˆ˜ì •í•˜ì—¬ GuildQueueë¥¼ ë§Œë“¦ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "Rust ë™ì‹œì„± ë¬¸ì œ",
    "url": "/posts/Bot_note_1/",
    "categories": "Project, Discord_Bot",
    "tags": "Concurrency, Bot",
    "date": "2025-02-02 17:57:07 +0900",
    





    
    "snippet": "      std::process::Stdio::piped() ëŠ” ìƒˆë¡œìš´ íŒŒì´í”„ë¥¼ ìƒì„±í•œë‹¤. std::process::Command::stdin(Stdio::piped()) ê°™ì€ ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ stdinì´ ìƒì„±ëœ íŒŒì´í”„ë¡œ ëŒ€ì²´ ë˜ëŠ” ì‹.CommandObject.stdin.take().unwrap()ìœ¼ë¡œ í•´ë‹¹ íŒŒì´í”„ ë””ìŠ¤í¬ë¦½í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë‹¤.   ...",
    "content": "      std::process::Stdio::piped() ëŠ” ìƒˆë¡œìš´ íŒŒì´í”„ë¥¼ ìƒì„±í•œë‹¤. std::process::Command::stdin(Stdio::piped()) ê°™ì€ ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ stdinì´ ìƒì„±ëœ íŒŒì´í”„ë¡œ ëŒ€ì²´ ë˜ëŠ” ì‹.CommandObject.stdin.take().unwrap()ìœ¼ë¡œ í•´ë‹¹ íŒŒì´í”„ ë””ìŠ¤í¬ë¦½í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë‹¤.        Command::spawn()ìœ¼ë¡œ ìƒì„±ëœ Child ê°ì²´ëŠ” wait[_with_output]ë‚˜ kill í˜¸ì¶œ ì „ê¹Œì§€ ì™„ë£Œ/ì¢…ë£Œë˜ì§€ ì•ŠëŠ”ë‹¤.ë§Œì•½ íŒŒì¼ì„ ì €ì¥í•˜ëŠ” ì‘ì—… ì´í›„ ì—°ì†í•´ì„œ ë‹¤ë¥¸ Command ê°€ ê·¸ íŒŒì¼ì„ ì½ìœ¼ë ¤ í•œë‹¤ë©´ íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•„ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤. ë²„í¼ ê´€ë ¨ ë¬¸ì œì¸ë“¯ë”°ë¼ì„œ wait ë¥¼ ì‚¬ìš©í•´ í”„ë¡œì„¸ìŠ¤ë¥¼ ê¸°ë‹¤ë¦¬ë©´ íŒŒì¼ì´ ì €ì¥ë˜ì–´ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.í•˜ì§€ë§Œ pipeë¡œ ì¶œë ¥ê³¼ ì…ë ¥ì„ ì—°ê²°í•˜ë©´ ì¶œë ¥ë²„í¼ì—ì„œ ì§ì ‘ ìŠ¤íŠ¸ë¦¼ì„ ì½ì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— waitê°€ í•„ìš” ì—†ë‹¤.        íŒŒì´í”„ ê´€ë ¨í•˜ì—¬  ë§Œì•½ Command::spawn()ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ í•˜ë‚˜ ìƒì„± í•  ë•Œ, ì´ í”„ë¡œì„¸ìŠ¤ì˜ stdinê³¼ stdoutì„ ëª¨ë‘ íŒŒì´í”„ ì²˜ë¦¬í–ˆì„ ë•Œ deadlockì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.ì˜ˆë¥¼ ë“¤ì–´          use std::{          io::{Read, Write},          process::{Command, Stdio},      };      let mut ffmpeg = Command::new(\"ffmpeg\")          .args(&amp;[\"-i\", \"-\"])          .args(&amp;FFMPEG_ARGS)          .arg(\"-\")          .stdin(Stdio::piped())          .stdout(Stdio::piped())          .spawn()          .unwrap();      let mut stdin = ffmpeg.stdin.take().unwrap();      stdin.write_all(&amp;data).unwrap();              let mut output = vec![];      let mut stdout = ffmpeg.stdout.take().unwrap();      stdout.read_to_end(&amp;mut output).unwrap();              ffmpeg.wait().unwrap();        ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ìˆì„ ë•Œ, stdin.write_all(&amp;data).unwrap();ë¶€ë¶„ì—ì„œ deadlockì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.ê°€ëŠ¥í•œ ì‹œë‚˜ë¦¬ì˜¤ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.          Rust í”„ë¡œì„¸ìŠ¤ê°€ stdin.write_all(&amp;data)ì„ ì‹¤í–‰í•¨      std::ioëŠ” Blocking I/Oì´ê¸° ë•Œë¬¸ì— Rust í”„ë¡œì„¸ìŠ¤ëŠ” ë°ì´í„°ë¥¼ ì „ë¶€ ì“°ê¸° ì „ê¹Œì§€ write_all ì—ì„œ ë¸”ë¡ëœë‹¤.      ffmpegëŠ” stdinì—ì„œ ë°ì´í„°ë¥¼ ì†Œë¹„í•˜ì—¬ stdoutì— ë°ì´í„°ë¥¼ ì“´ë‹¤.      ffmpegê°€ ì‘ì—…ì„ ì§„í–‰í•˜ì—¬ stdoutê°€ ê°€ë“ ì°¨ê²Œ ë˜ë©´ ffmpegë„ blockëœë‹¤.      ffmpegê°€ ê¹¨ì–´ë‚˜ë ¤ë©´ stdoutì• ì„œ ë°ì´í„°ê°€ ì†Œë¹„ ë˜ì–´ì•¼ í•œë‹¤.      ê·¸ëŸ¬ë‚˜ ffmpegê°€ Block ëê¸° ë•Œë¬¸ì— stdinì—ì„œ ë°ì´í„°ë¥¼ ì†Œë¹„í•  ìˆ˜ ì—†ì–´ Rust í”„ë¡œì„¸ìŠ¤ ë˜í•œ ê³„ì† write_allì—ì„œ Block ë˜ì–´ ìˆë‹¤.      ë”°ë¼ì„œ ì‹¤í–‰ íë¦„ì´ stdout.read_to_end(&amp;mut output).unwrap();ê¹Œì§€ ë„ë‹¬í•˜ì§€ ëª»í•´ ffmpegì˜ stdoutì„ ë¹„ì›Œ ì¤„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ë‘ í”„ë¡œì„¸ìŠ¤ ëª¨ë‘ Block ë˜ëŠ” deadlockì— ë¹ ì§€ê²Œ ëœë‹¤.        ì´ë¥¼ í•´ê²°í•˜ë ¤ë©´   stdin.write_all(&amp;data).unwrap();ë¥¼ tokio::spawnìœ¼ë¡œ ê°ì‹¸ taskë¥¼ ë¶„ë¦¬í•´ì£¼ë©´ ëœë‹¤.      tokio::spawn(async move {      stdin.write_all(&amp;data).await.unwrap();  });        ì´ë ‡ê²Œ í•˜ë©´ write_allì€ ì—¬ì „íˆ blockë˜ì§€ë§Œ ë‹¤ë¥¸ taskì—ì„œ blockë˜ë¯€ë¡œ ê¸°ì¡´ì˜ taskëŠ” stdout.read_to_end(&amp;mut output).unwrap();ê¹Œì§€ ë„ë‹¬í•˜ì—¬ stdoutì„ ì†Œë¹„í•˜ì—¬ spawnëœ í”„ë¡œì„¸ìŠ¤ë¥¼ ê³„ì† ì‹¤í–‰ì‹œí‚¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— deadlockì´ ë°œìƒí•˜ì§€ ì•Šê²Œ ëœë‹¤.    ë‹¨, ì´ë¥¼ ìœ„í•´ì„œ ê¸°ì¡´ì˜ std::process::Commandë¥¼ tokio::process::Commandë¡œ ë°”ê¿”ì•¼í•œë‹¤.  tokio::spawnì€ Futureì— ëŒ€í•´ ë™ì‘í•˜ê¸° ë•Œë¬¸ì¸ë°, std::ioëŠ” Futureê°€ ë  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.    ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œëŠ” íŒŒì´í”„ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  íŒŒì¼ë¡œ ì €ì¥í•œ í›„ ìŠ¤í° í•  í”„ë¡œì„¸ìŠ¤ì—ì„œ íŒŒì¼ì„ ì²˜ë¦¬í•˜ë„ë¡ í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•˜ë‹¤.  Arc íƒ€ì…ì— ê´€í•´  ì›ìì ìœ¼ë¡œ ë™ì‘í•˜ëŠ” ë³µìˆ˜ì˜ ì†Œìœ ê¶Œì„ ê°€ì§€ëŠ” ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°  Arc::clone í•˜ë©´ ê°’ì„ cloneí•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ë©´ì„œ ì°¸ì¡° ì¹´ìš´íŒ…ì„ ëŠ˜ë¦°ë‹¤.  ë‹¨ í•´ë‹¹ ì°¸ì¡°ëŠ” immutableí•˜ë¯€ë¡œ Mutexë‚˜ RwLockë¥¼ ê°ì‹¸ì„œ Arc&lt;Mutex&lt;T&gt;&gt;ë¡œ ê°€ë³€ì„±ì„ ì–»ëŠ” ì‹ìœ¼ë¡œ ë§ì´ ì‚¬ìš©í•œë‹¤.ìŒì„± ì±„ë„ ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” ë¶€ë¶„ì„ connection handlerë¡œ ë¶„ë¦¬í–ˆì„ ë•Œlet manager = songbird::get(ctx)    .await    .expect(\"Songbird Voice client placed in at initialisation.\");ì´ë¶€ë¶„ì—ì„œ future cannot be sent between threads safely ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤.ì°¾ì•„ë³´ë‹ˆlet voice_states: &amp;HashMap&lt;UserId, VoiceState&gt; = &amp;guild_id    .to_guild_cached(ctx)    .unwrap()    .voice_states;let user_channel = voice_states    .get(&amp;command.user.id)    .and_then(|voice_state| voice_state.channel_id);to_guild_cachedë¡œ ê°€ì ¸ì˜¤ëŠ” CacheRefê°€ NotSendì˜€ê¸° ë•Œë¬¸ì— songbird::get(ctx).await í˜¸ì¶œ ì‹œì ì—ë„ voice_statesê°€ ì‚´ì•„ìˆì–´ì„œ ë°œìƒí•œ ë¬¸ì œì˜€ë‹¤.let user_channel = {    // CacheRef is not Send    let voice_states: &amp;HashMap&lt;UserId, VoiceState&gt; = &amp;guild_id        .to_guild_cached(ctx)        .unwrap()        .voice_states;    voice_states        .get(&amp;command.user.id)        .and_then(|voice_state| voice_state.channel_id)}; // So must drop hereê·¸ë˜ì„œ ë‹¤ìŒê³¼ ê°™ì´ ë¸”ë¡ì„ ë§Œë“¤ì–´ì„œ voice_statesë¥¼ ë¸”ë¡ ë‚´ì—ì„œë§Œ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •í–ˆë‹¤.ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ê³ ì • í¬ê¸° Heap êµ¬í˜„",
    "url": "/posts/Heap_with_Array/",
    "categories": "Study, Algorithm",
    "tags": "Heap",
    "date": "2025-01-31 07:49:01 +0900",
    





    
    "snippet": "í™(Heap)ì™„ì „ ì´ì§„ íŠ¸ë¦¬(Complete Binary Tree) ê¸°ë°˜ì˜ ìë£Œêµ¬ì¡° Â ìµœëŒ“ê°’ ë˜ëŠ” ìµœì†Ÿê°’ì„ ë¹ ë¥´ê²Œ ì ‘ê·¼ ë° ê´€ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.1. í™ì˜ ì¢…ë¥˜ğŸ”¹ ìµœëŒ€ í™ (Max Heap)  ë¶€ëª¨ ë…¸ë“œëŠ” í•­ìƒ ìì‹ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìŒ  ë£¨íŠ¸ ë…¸ë“œì—ëŠ” ê°€ì¥ í° ê°’ì´ ìœ„ì¹˜í•¨  ì‚½ì…(push)ê³¼ ì‚­ì œ(pop) í›„ì—ë„ ì´ ì†ì„±ì´ ìœ ì§€ë¨âœ… ì˜ˆì‹œ (ìµœëŒ€ í™)   ...",
    "content": "í™(Heap)ì™„ì „ ì´ì§„ íŠ¸ë¦¬(Complete Binary Tree) ê¸°ë°˜ì˜ ìë£Œêµ¬ì¡° Â ìµœëŒ“ê°’ ë˜ëŠ” ìµœì†Ÿê°’ì„ ë¹ ë¥´ê²Œ ì ‘ê·¼ ë° ê´€ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.1. í™ì˜ ì¢…ë¥˜ğŸ”¹ ìµœëŒ€ í™ (Max Heap)  ë¶€ëª¨ ë…¸ë“œëŠ” í•­ìƒ ìì‹ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìŒ  ë£¨íŠ¸ ë…¸ë“œì—ëŠ” ê°€ì¥ í° ê°’ì´ ìœ„ì¹˜í•¨  ì‚½ì…(push)ê³¼ ì‚­ì œ(pop) í›„ì—ë„ ì´ ì†ì„±ì´ ìœ ì§€ë¨âœ… ì˜ˆì‹œ (ìµœëŒ€ í™)        50       /  \\     30    40    /  \\   /   10  20 35  top()ì„ í•˜ë©´ 50ì´ ë°˜í™˜ë¨  pop()ì„ í•˜ë©´ 50ì´ ì œê±°ë˜ê³ , í™ ì†ì„±ì´ ìœ ì§€ë¨ğŸ”¹ ìµœì†Œ í™ (Min Heap)  ë¶€ëª¨ ë…¸ë“œëŠ” í•­ìƒ ìì‹ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìŒ  ë£¨íŠ¸ ë…¸ë“œì—ëŠ” ê°€ì¥ ì‘ì€ ê°’ì´ ìœ„ì¹˜í•¨âœ… ì˜ˆì‹œ (ìµœì†Œ í™)        10       /  \\     20    30    /  \\   /   50  40 35  top()ì„ í•˜ë©´ 10ì´ ë°˜í™˜ë¨  pop()ì„ í•˜ë©´ 10ì´ ì œê±°ë˜ê³ , í™ ì†ì„±ì´ ìœ ì§€ë¨2. í™ì˜ íŠ¹ì§•  ì™„ì „ ì´ì§„ íŠ¸ë¦¬(Complete Binary Tree)          íŠ¸ë¦¬ì˜ ëª¨ë“  ë ˆë²¨ì´ ì™„ì „íˆ ì±„ì›Œì ¸ ìˆì–´ì•¼ í•¨      ë§ˆì§€ë§‰ ë ˆë²¨ë§Œ ì˜ˆì™¸ì ìœ¼ë¡œ ì™¼ìª½ë¶€í„° ì±„ì›Œì§        í™ ì†ì„±(Heap Property) ìœ ì§€          ìµœëŒ€ í™: ë¶€ëª¨ ë…¸ë“œ â‰¥ ìì‹ ë…¸ë“œ      ìµœì†Œ í™: ë¶€ëª¨ ë…¸ë“œ â‰¤ ìì‹ ë…¸ë“œ        ë¹ ë¥¸ ì‚½ì…ê³¼ ì‚­ì œ          O(log N)ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§      3. í™ì˜ ì—°ì‚°ğŸ”¹ ì‚½ì… (push, insert)      ìƒˆë¡œìš´ ì›ì†Œë¥¼ íŠ¸ë¦¬ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ì¶”ê°€    ë¶€ëª¨ ë…¸ë“œì™€ ë¹„êµí•˜ì—¬ í™ ì†ì„±ì´ ìœ ì§€ë  ë•Œê¹Œì§€ Swap (Heapify-up)  ì‹œê°„ ë³µì¡ë„: O(log N)âœ… ì˜ˆì œ (ìµœëŒ€ í™, push(45))ì´ˆê¸° ìƒíƒœ:        50       /  \\     30    40    /  \\   /   10  20 35(1) 45ë¥¼ ë§ˆì§€ë§‰ì— ì¶”ê°€:        50       /  \\     30    40    /  \\   / \\   10  20 35  45(2) ë¶€ëª¨(40)ì™€ ë¹„êµ í›„ Swap:        50       /  \\     30    45    /  \\   / \\   10  20 35  40â³ ì‹œê°„ ë³µì¡ë„: O(log N)ğŸ”¹ ì‚­ì œ (pop, remove)  ë£¨íŠ¸ ë…¸ë“œë¥¼ ì œê±°  ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë£¨íŠ¸ë¡œ ì´ë™  ìì‹ ë…¸ë“œ ì¤‘ ë” í° ê°’ê³¼ Swapí•˜ì—¬ í™ ì†ì„±ì„ ìœ ì§€ (Heapify-down)  ì‹œê°„ ë³µì¡ë„: O(log N)âœ… ì˜ˆì œ (ìµœëŒ€ í™, pop())ì´ˆê¸° ìƒíƒœ:        50       /  \\     30    40    /  \\   / \\   10  20 35  45(1) ë£¨íŠ¸(50) ì œê±° í›„, ë§ˆì§€ë§‰ ë…¸ë“œ(45) ì´ë™:        45       /  \\     30    40    /  \\   /   10  20 35(2) ìì‹ ì¤‘ ë” í° ê°’(40)ê³¼ Swap:        45       /  \\     30    40    /  \\   /   10  20 35â³ ì‹œê°„ ë³µì¡ë„: O(log N)4. í™ì˜ êµ¬í˜„ ë°©ë²•ğŸ”¹ ë°°ì—´(Array) ê¸°ë°˜ í™ êµ¬í˜„í™ì€ ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„.ë…¸ë“œì˜ ì¸ë±ìŠ¤ë¥¼ í™œìš©í•˜ì—¬ ë¶€ëª¨/ìì‹ ë…¸ë“œë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤ë‹¤.            ë…¸ë“œ      ì¸ë±ìŠ¤      ë¶€ëª¨ ë…¸ë“œ      ì™¼ìª½ ìì‹      ì˜¤ë¥¸ìª½ ìì‹                  Root      1      -      2      3              A      2      1      4      5              B      3      1      6      7      ìˆ˜ì‹  ë¶€ëª¨ ë…¸ë“œ: parent(i) = i / 2  ì™¼ìª½ ìì‹: left(i) = 2 * i  ì˜¤ë¥¸ìª½ ìì‹: right(i) = 2 * i + 15. í™ì˜ í™œìš©âœ… ìš°ì„ ìˆœìœ„ í (Priority Queue)  std::priority_queue&lt;T&gt; (C++ STL) ë‚´ë¶€ì ìœ¼ë¡œ í™ìœ¼ë¡œ êµ¬í˜„  O(log N)ì— ì‚½ì…/ì‚­ì œ ê°€ëŠ¥âœ… í™ ì •ë ¬ (Heap Sort)  O(N log N)ì˜ ì‹œê°„ ë³µì¡ë„  std::make_heap(), std::sort_heap() í•¨ìˆ˜ í™œìš© ê°€ëŠ¥âœ… ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ (Dijkstraâ€™s Algorithm)  ê·¸ë˜í”„ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì„ ë•Œ ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ì—¬ O(E log V)ì— ìµœì í™” ê°€ëŠ¥6. C++ êµ¬í˜„#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define MAX_LEN 1001template&lt;typename T&gt;struct heap {    T *v;    int cnt;    int max_size;    const bool is_max;    heap(bool is_max, int size) : is_max(is_max), max_size(size) {        v = new T[size+1];        cnt = 0;    }    ~heap() {        delete[] v;    }    void clear() {         cnt = 0;     }    T&amp; operator[] (int index) {        if (index &lt; 1 || index &gt; cnt) throw out_of_range(\"Index out of range\");        return v[index];    }    int size() {        return cnt;    }    T top() {        if (cnt &lt; 1) throw out_of_range(\"heap is empty\");         return v[1];    }    bool empty() {        return cnt == 0;    }    void push(const T&amp; x) {        if (cnt &gt;= max_size) throw out_of_range(\"heap is full\");        v[++cnt] = x;        int cur = cnt;        int parent = cnt / 2;        while (cur &gt; 1 &amp;&amp; cmp(v[cur], v[parent])) {            swap(v[cur], v[parent]);            cur = parent;            parent /= 2;        }    }    void push(T&amp;&amp; x) {        if (cnt &gt;= max_size) throw out_of_range(\"heap is full\");        v[++cnt] = move(x);        int cur = cnt;        int parent = cnt / 2;        while (cur &gt; 1 &amp;&amp; cmp(v[cur], v[parent])) {            swap(v[cur], v[parent]);            cur = parent;            parent /= 2;        }    }    void pop() {        if (cnt &lt; 1) throw out_of_range(\"heap is empty\");         swap(v[cnt--], v[1]);        int cur = 1, child;        while (true) {            child = cur * 2;            if (child &gt; cnt) break;            if (child+1 &lt;= cnt &amp;&amp; cmp(v[child+1], v[child])) child += 1;            if (!cmp(v[child], v[cur])) break;            swap(v[cur], v[child]);            cur = child;        }    }    bool cmp(T&amp; a, T&amp; b) {        return is_max ? a &gt; b : a &lt; b;    }};ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "Jekyll ì‹œí–‰ ì°©ì˜¤ë“¤ ì •ë¦¬",
    "url": "/posts/Trial_Error/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2025-01-30 14:57:40 +0900",
    





    
    "snippet": "Github Pages ì‹œí–‰ì°©ì˜¤ë“¤  ë§í¬ëŠ” https:// ë¡œ ì‹œì‘í•´ì•¼ htmlproofer ê²€ì‚¬ì—ì„œ ì˜¤ë¥˜ê°€ ë‚˜ì§€ ì•ŠìŒ      markdown ë¬¸ì„œì—ì„œ ìƒëŒ€ê²½ë¡œë¡œ í¬í•¨ëœ ë¦¬ì†ŒìŠ¤ëŠ” ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜í•´ì¤˜ì•¼ í•¨.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/ma...",
    "content": "Github Pages ì‹œí–‰ì°©ì˜¤ë“¤  ë§í¬ëŠ” https:// ë¡œ ì‹œì‘í•´ì•¼ htmlproofer ê²€ì‚¬ì—ì„œ ì˜¤ë¥˜ê°€ ë‚˜ì§€ ì•ŠìŒ      markdown ë¬¸ì„œì—ì„œ ìƒëŒ€ê²½ë¡œë¡œ í¬í•¨ëœ ë¦¬ì†ŒìŠ¤ëŠ” ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜í•´ì¤˜ì•¼ í•¨.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md\" %} {% assign img_url = remote_url | remove: \"lecture.md\" | append: \"capture/\" %} {% capture remote_content %} &lt;!--remote_content ë³€ìˆ˜ì— remote resource ì €ì¥ --&gt;     {% remote_include https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md %} {% endcapture %} {{ remote_content  &lt;!--remote_contentì—ì„œ ìƒëŒ€ê²½ë¡œë¡œ í¬í•¨ëœ ë¦¬ì†ŒìŠ¤ë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜ --&gt; | replace: './capture/', img_url  }}      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "Multi-level Feedack Queue êµ¬í˜„í•˜ê¸°",
    "url": "/posts/MFQ/",
    "categories": "Project, OS",
    "tags": "OS, MFQ",
    "date": "2025-01-22 17:30:53 +0900",
    





    
    "snippet": "ë©€í‹° ë ˆë²¨ í”¼ë“œë°± í(MFQ) ìŠ¤ì¼€ì¤„ë§ì½”ë“œ êµ¬ì¡°  ë°ì´í„° êµ¬ì¡°          Process êµ¬ì¡°ì²´: ê° í”„ë¡œì„¸ìŠ¤ë¥¼ í‘œí˜„í•˜ëŠ” êµ¬ì¡°ì²´.      waitq, finishedq, global_io_q: ëŒ€ê¸° í, ì™„ë£Œ í, ê¸€ë¡œë²Œ I/O í.        ìŠ¤ì¼€ì¤„ëŸ¬ í´ë˜ìŠ¤          SchedulerBase (ì¶”ìƒ í´ë˜ìŠ¤): ìŠ¤ì¼€ì¤„ëŸ¬ì˜ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤...",
    "content": "ë©€í‹° ë ˆë²¨ í”¼ë“œë°± í(MFQ) ìŠ¤ì¼€ì¤„ë§ì½”ë“œ êµ¬ì¡°  ë°ì´í„° êµ¬ì¡°          Process êµ¬ì¡°ì²´: ê° í”„ë¡œì„¸ìŠ¤ë¥¼ í‘œí˜„í•˜ëŠ” êµ¬ì¡°ì²´.      waitq, finishedq, global_io_q: ëŒ€ê¸° í, ì™„ë£Œ í, ê¸€ë¡œë²Œ I/O í.        ìŠ¤ì¼€ì¤„ëŸ¬ í´ë˜ìŠ¤          SchedulerBase (ì¶”ìƒ í´ë˜ìŠ¤): ìŠ¤ì¼€ì¤„ëŸ¬ì˜ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ ì •ì˜.      Scheduler&lt;Container&gt; (í…œí”Œë¦¿ í´ë˜ìŠ¤): íŠ¹ì • ì»¨í…Œì´ë„ˆ(RR, SRTN, FCFS)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤ì¼€ì¤„ë§ì„ ìˆ˜í–‰.        í•¨ìˆ˜          parse_process: ì…ë ¥ íŒŒì¼ì„ íŒŒì‹±í•˜ì—¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ëŒ€ê¸° íì— ì‚½ì….      add_process: í”„ë¡œì„¸ìŠ¤ë¥¼ ì ì ˆí•œ íë¡œ ì‚½ì….      process_io_queue: I/O íì—ì„œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ì™„ë£Œëœ í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¤ì‹œ ì‹¤í–‰ íì— ì¶”ê°€.      run: ì „ì²´ ìŠ¤ì¼€ì¤„ë§ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰.      print_results: ìµœì¢… ê²°ê³¼ ì¶œë ¥.      print_queue_status: í˜„ì¬ í ìƒíƒœ ì¶œë ¥.      ì½”ë“œ ë™ì‘ ë°©ì‹1. ì´ˆê¸°í™” ë‹¨ê³„  parse_process í•¨ìˆ˜ë¥¼ í†µí•´ ì…ë ¥ íŒŒì¼ì—ì„œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì½ì–´ waitqì— ì €ì¥.  í”„ë¡œì„¸ìŠ¤ëŠ” ë„ì°© ì‹œê°„(arrival_time)ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ë¨.2. ì‹¤í–‰ ë‹¨ê³„run í•¨ìˆ˜ì˜ ë°˜ë³µ ë£¨í”„ì—ì„œ ë‹¤ìŒ ë‹¨ê³„ê°€ ìˆ˜í–‰ëœë‹¤:  ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ ì¶”ê°€          waitqì—ì„œ í˜„ì¬ cpu_clockê³¼ ì¼ì¹˜í•˜ëŠ” ë„ì°© ì‹œê°„ì´ ìˆëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ì ì ˆí•œ ìš°ì„ ìˆœìœ„ í(Q0~Q3)ì— ì¶”ê°€.        CPU ìŠ¤ì¼€ì¤„ë§          ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ íë¶€í„° ì‹¤í–‰(Q0 â†’ Q1 â†’ Q2 â†’ Q3).      ìŠ¤ì¼€ì¤„ëŸ¬ì˜ run í•¨ìˆ˜ í˜¸ì¶œ.        ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ì ìš©          Q0 (RR, TQ=2):                  í”„ë¡œì„¸ìŠ¤ê°€ ìµœëŒ€ 2ê°œì˜ íƒ€ì„ í€€í…€ ë™ì•ˆ ì‹¤í–‰.          íƒ€ì„ í€€í…€ ì´ˆê³¼ ì‹œ Q1ë¡œ ì´ë™.          CPU burstê°€ ì™„ë£Œë˜ë©´ I/O ìˆ˜í–‰.                    Q1 (RR, TQ=6):                  ìµœëŒ€ 6ê°œì˜ íƒ€ì„ í€€í…€ ì ìš©, ì´ˆê³¼ ì‹œ Q2ë¡œ ì´ë™.                    Q2 (SRTN):                  ë‚¨ì€ CPU burst ì‹œê°„ì´ ê°€ì¥ ì§§ì€ í”„ë¡œì„¸ìŠ¤ë¥¼ ìš°ì„  ì‹¤í–‰.          ì„ ì ë  ê²½ìš° Q3ë¡œ ì´ë™.                    Q3 (FCFS):                  ì„ ì…ì„ ì¶œ(FIFO) ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬.                      I/O ì²˜ë¦¬          global_io_qì—ì„œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì²˜ë¦¬í•˜ë©°, í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ì˜ I/O ì‹œê°„ì´ ê°ì†Œ.      I/Oê°€ ì™„ë£Œë˜ë©´ ì›ë˜ íë³´ë‹¤ ë†’ì€ ìš°ì„ ìˆœìœ„ íë¡œ ë³µê·€.        í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ í™•ì¸          ëª¨ë“  CPU burstì™€ I/Oê°€ ì™„ë£Œë˜ë©´ finishedqë¡œ ì´ë™.      3. ìµœì¢… ê²°ê³¼ ì¶œë ¥print_results í•¨ìˆ˜ë¥¼ í†µí•´ ë‹¤ìŒ í•­ëª©ì„ ì¶œë ¥í•œë‹¤:  í”„ë¡œì„¸ìŠ¤ì˜ ë„ì°© ì‹œê°„, ì¢…ë£Œ ì‹œê°„, ë°˜í™˜ ì‹œê°„(Turnaround Time), ëŒ€ê¸° ì‹œê°„(Waiting Time).  í‰ê·  ë°˜í™˜ ì‹œê°„ ë° ëŒ€ê¸° ì‹œê°„.ì‹¤í–‰ ê³¼ì • ì˜ˆì‹œì…ë ¥ ì˜ˆì‹œ31 0 0 2 6 3 72 1 1 1 83 2 2 3 4 3 5 1 4ì¶œë ¥ ì˜ˆì‹œ[Scheduling Results]---------------------------------------------------  PID |    Arrival |     Finish | Turnaround |   Waiting---------------------------------------------------    2 |          1 |         14 |         13 |          5    1 |          0 |         21 |         21 |          8    3 |          2 |         34 |         32 |         19---------------------------------------------------Average Turnaround Time: 22Average Waiting Time: 10.6667ì£¼ìš” ì„¤ê³„ ê³ ë ¤ì‚¬í•­  í ê°„ ì´ë™ ê·œì¹™:          CPU burstê°€ ëë‚˜ë©´ I/O ì‘ì—…ì„ ìˆ˜í–‰í•œ í›„ ì ì ˆí•œ íë¡œ ì´ë™.      íƒ€ì„ í€€í…€ì´ ë§Œë£Œë˜ë©´ í•˜ìœ„ íë¡œ ì´ë™.      SRTN íì—ì„œëŠ” ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ê°€ ë“¤ì–´ì˜¬ ë•Œ ì„ ì  ë°œìƒ.        í´ëŸ­ ì¦ê°€ ê·œì¹™:          í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë  ë•Œë§Œ cpu_clockì´ ì¦ê°€í•˜ë„ë¡ êµ¬í˜„.        I/O ì²˜ë¦¬:          I/O íëŠ” ë³„ë„ì˜ ê¸€ë¡œë²Œ íë¡œ ìœ ì§€ë˜ë©° í”„ë¡œì„¸ìŠ¤ëŠ” ì¼ì • ì‹œê°„ í›„ ì‹¤í–‰ íë¡œ ëŒì•„ì˜´.        í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ ì²˜ë¦¬:          ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ë©´ finishedqë¡œ ì´ë™í•˜ê³  ì™„ë£Œ ì‹œê°„ì„ ê¸°ë¡.      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "íƒœì–‘ê³„ ì‹œë®¬ë ˆì´ì…˜",
    "url": "/posts/Solar_System/",
    "categories": "Project, Graphics",
    "tags": "OpenGL, Solar-System",
    "date": "2025-01-19 20:12:54 +0900",
    





    
    "snippet": "êµ¬í˜„ë°ì´í„° ì´ˆê¸°í™”í–‰ì„±ê³¼ ë§ì˜ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ì‘ì—…ì€ user_init() í•¨ìˆ˜ì—ì„œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë  ë•Œ í˜¸ì¶œë˜ì–´ í•„ìš”í•œ ë°ì´í„°ì™€ ê·¸ë˜í”½ ë¦¬ì†ŒìŠ¤ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.1. ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •      init_pos ì´ˆê¸°í™”:    for (int i = 0; i &lt; NUM_SPHERE; i++) {    init_pos[i] = (...",
    "content": "êµ¬í˜„ë°ì´í„° ì´ˆê¸°í™”í–‰ì„±ê³¼ ë§ì˜ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ì‘ì—…ì€ user_init() í•¨ìˆ˜ì—ì„œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë  ë•Œ í˜¸ì¶œë˜ì–´ í•„ìš”í•œ ë°ì´í„°ì™€ ê·¸ë˜í”½ ë¦¬ì†ŒìŠ¤ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.1. ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •      init_pos ì´ˆê¸°í™”:    for (int i = 0; i &lt; NUM_SPHERE; i++) {    init_pos[i] = (float)rand() / (float)RAND_MAX * 2 * PI;}              ê° í–‰ì„±ì˜ ì´ˆê¸° ê³µì „ ìœ„ì¹˜ë¥¼ ëœë¤ ê°’ìœ¼ë¡œ ì„¤ì •.      ì´ˆê¸° ìœ„ì¹˜ëŠ” [0, 2Ï€] ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ, í–‰ì„±ì´ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ì‹œ ì„œë¡œ ë‹¤ë¥¸ ìœ„ì¹˜ì— ë°°ì¹˜ë˜ë„ë¡ ë³´ì¥.      2. OpenGL ì´ˆê¸°í™”      í…ìŠ¤ì²˜ ë¡œë“œ:    glGenTextures(19, textures);for (uint i = 0; i &lt; 19; i++) {    glBindTexture(GL_TEXTURE_2D, textures[i]);    int width, height, comp = 3;    unsigned char* pimage0 = stbi_load(meshes[i], &amp;width, &amp;height, &amp;comp, 3);    // í…ìŠ¤ì²˜ ë°ì´í„°ë¥¼ GPUì— ì—…ë¡œë“œ    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pimage);    glGenerateMipmap(GL_TEXTURE_2D);    // í…ìŠ¤ì²˜ íŒŒë¼ë¯¸í„° ì„¤ì •    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);}              ê° í–‰ì„±ì— ëŒ€í•œ í…ìŠ¤ì²˜ ì´ë¯¸ì§€(meshes ë°°ì—´)ë¥¼ ì½ì–´ë“¤ì—¬ OpenGL í…ìŠ¤ì²˜ë¡œ ì„¤ì •.            ì •ì  ë°ì´í„° ì´ˆê¸°í™”:    update_circle_vertices(NUM_TESS);update_vertex_buffer(NUM_TESS);update_ring_vertices(NUM_TESS);update_ring_vertex_buffer(NUM_TESS);              í–‰ì„±ê³¼ ë§ì„ êµ¬ì„±í•˜ëŠ” ì •ì  ë°ì´í„°ë¥¼ ìƒì„±í•˜ê³ , ì´ë¥¼ GPU ë²„í¼ì— ì—…ë¡œë“œ.              í–‰ì„±ì€ êµ¬ì²´ë¡œ, ë§ì€ ì›í˜•ì˜ í‰ë©´ìœ¼ë¡œ ì •ì˜.            update_circle_vertices(NUM_TESS)                  êµ¬ì²´ì˜ ì •ì  ë°ì´í„° ìƒì„±                    for (int i = 0; i &lt;= NUM_TESS; i++) {        float theta = PI * i / NUM_TESS; // ìœ„ë„        for (int j = 0; j &lt;= NUM_TESS; j++) {            float p = PI * 2.0f / float(NUM_TESS) * float(j); // ê²½ë„            float x = sin(theta) * cos(p); float y = sin(theta) * sin(p); float z = cos(theta);            vertex_list.push_back({ vec3(x, y, z), vec3(x, y, z), vec2((p / (2 * PI)), (1.0f - (theta / PI))) });            if (i == 0 || i == NUM_TESS) break;        }    }                          êµ¬ë©´ì¢Œí‘œê³„ ì„¤ëª…          ìœ„ë„(theta)ì™€ ê²½ë„(p)ë¥¼ ì´ìš©í•˜ì—¬ êµ¬ì²´ í‘œë©´ì˜ ì •ì  ì¢Œí‘œ (x, y, z)ë¥¼ ê³„ì‚°.          ì •ì ì˜ ìœ„ì¹˜ì™€ ë²•ì„  ë²¡í„°(normal)ëŠ” ë™ì¼í•˜ê²Œ (x, y, z)ë¡œ ì„¤ì • (êµ¬ì˜ ì¤‘ì‹¬ìœ¼ë¡œë¶€í„°ì˜ ë°©í–¥).          í…ìŠ¤ì²˜ ì¢Œí‘œ(texcoord):          u = p / (2Ï€): ê²½ë„ì— ë”°ë¥¸ ìˆ˜í‰ í…ìŠ¤ì²˜ ì¢Œí‘œ.          v = 1 - theta / Ï€: ìœ„ë„ì— ë”°ë¥¸ ìˆ˜ì§ í…ìŠ¤ì²˜ ì¢Œí‘œ.          ê·¹ì§€ë°©(ìœ„ë„ theta = 0 ë˜ëŠ” theta = Ï€)ì˜ ì •ì ì€ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì²˜ë¦¬.                if (i == 0 || i == NUM_TESS) break;                    2. update_vertex_buffer(NUM_TESS)                  êµ¬ì²´ì˜ ì •ì  ë°ì´í„°ë¥¼ GPUë¡œ ì „ì†¡                      update_circle_vertices()ì—ì„œ ìƒì„±ëœ ì •ì  ë°ì´í„°ë¥¼ GPUì— ì—…ë¡œë“œí•˜ì—¬ ë Œë”ë§ì— ì‚¬ìš©.                                ì´ì „ ë²„í¼ ì‚­ì œ:              if (vertex_buffer) glDeleteBuffers(1, &amp;vertex_buffer); vertex_buffer = 0;  if (index_buffer) glDeleteBuffers(1, &amp;index_buffer); index_buffer = 0;                                      ì´ì „ì— ì‚¬ìš©í–ˆë˜ ì •ì  ë° ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ì‚­ì œí•˜ì—¬ ë©”ëª¨ë¦¬ ë‚­ë¹„ë¥¼ ë°©ì§€.                                ì¸ë±ìŠ¤ ë°°ì—´ ìƒì„±:                          ì‚¼ê°í˜•ìœ¼ë¡œ êµ¬ë¥¼ ë Œë”ë§í•˜ê¸° ìœ„í•´ ì¸ë±ìŠ¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±.                          index_list.clear();  for (uint i = 0; i &lt; N; i++) {      index_list.push_back(0);      index_list.push_back(i + 1);      index_list.push_back(i + 2);  }  uint k;  for (k = 1; k &lt; (N + 1) * (N - 2); k += (N + 1)) {      for (uint j = k; j &lt; k + N; j++) {          index_list.push_back(j);          index_list.push_back(j + N + 1);          index_list.push_back(j + N + 2);          index_list.push_back(j);          index_list.push_back(j + N + 2);          index_list.push_back(j + 1);      }  }  for (uint i = k; i &lt; k + N; i++) {      index_list.push_back(i);      index_list.push_back(k + 1 + N);      index_list.push_back(i + 1);  }                                ì‚¼ê°í˜•ì„ êµ¬ì„±í•˜ëŠ” ì •ì ì˜ ì¸ë±ìŠ¤ë¥¼ ì •ì˜:                          êµ¬ì˜ ê° ìœ„ë„ì™€ ê²½ë„ ì‚¬ì´ì˜ ì‚¬ê°í˜•ì„ ë‘ ê°œì˜ ì‚¼ê°í˜•ìœ¼ë¡œ ë¶„í• .              ê° ì‚¼ê°í˜•ì€ ì„¸ ê°œì˜ ì •ì  ì¸ë±ìŠ¤ë¡œ ì •ì˜.                                            GPUì— ë²„í¼ ì—…ë¡œë“œ:            glGenBuffers(1, &amp;vertex_buffer);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);glBufferData(GL_ARRAY_BUFFER, sizeof(vertex)*vertex_list.size(), &amp;vertex_list[0], GL_STATIC_DRAW);glGenBuffers(1, &amp;index_buffer);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(uint)*index_list.size(), &amp;index_list[0], GL_STATIC_DRAW);                                      ìƒì„±ëœ ì •ì (vertex_list)ê³¼ ì¸ë±ìŠ¤(index_list) ë°ì´í„°ë¥¼ GPUë¡œ ì „ì†¡.                                          3. update_ring_vertices(NUM_TESS)                  ë§(ê³ ë¦¬)ì˜ ì •ì  ë°ì´í„° ìƒì„±                          ë§ì€ í‰ë©´ì— ê·¸ë ¤ì§.                                ë§ì˜ ì •ì  ê³„ì‚°:                ring_vertex_list.clear();for (uint i = 0; i &lt;= N; i++) {    float theta = 2.0f * PI * i / float(N); // ì›í˜• ê°ë„    float x = cos(theta); float y = sin(theta);    ring_vertex_list.push_back({ vec3(0, 0, 0), vec3(x, y, 0), vec2(0, 0) });   // ë‚´ë¶€ ì›    ring_vertex_list.push_back({ vec3(x, y, 0), vec3(x, y, 0), vec2(1, 0) });   // ì™¸ë¶€ ì›}                          ë§ì˜ ì •ì ì€ ë‚´ë¶€ ì›ê³¼ ì™¸ë¶€ ì›ì˜ ì¢Œí‘œë¡œ êµ¬ì„±.          vec3(x, y, 0)ì€ ê°ë„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°ëœ ì •ì ì˜ ìœ„ì¹˜.                    4. update_ring_vertex_buffer(NUM_TESS)                              ë§ ì •ì  ë°ì´í„°ë¥¼ GPUë¡œ ì „ì†¡                                ì•ë©´(ì •ë©´) ì •ì˜:                          ring_index_list.push_back(2 * i);ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1) + 1);                                      ì—¬ê¸°ì„œ ì •ì˜ëœ ì‚¼ê°í˜•ì€ ë§ì˜ ì•ë©´(ì‹œê³„ ë°©í–¥)ì„ ê·¸ë¦¼.                                ë’·ë©´ ì •ì˜:                          ring_index_list.push_back(2 * i);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * (i + 1) + 1);ring_index_list.push_back(2 * i + 1);                                      ì—¬ê¸°ì„œëŠ” ì•ë©´ ì‚¼ê°í˜•ê³¼ ë™ì¼í•œ ì˜ì—­ì„ ë°˜ëŒ€ ë°©í–¥(ë°˜ì‹œê³„ ë°©í–¥)ìœ¼ë¡œ ì •ì˜í•˜ì—¬ ë’·ë©´ì„ ê·¸ë¦¼.                                OpenGL ê¸°ë³¸ ì„¤ì •ì—ì„œëŠ” ì‚¼ê°í˜•ì˜ ì •ì  ì—°ê²° ìˆœì„œ(ì‹œê³„ ë°©í–¥ ë˜ëŠ” ë°˜ì‹œê³„ ë°©í–¥)ì— ë”°ë¼ì•ë©´ê³¼ ë’·ë©´ì„ êµ¬ë¶„í•˜ê¸° ë•Œë¬¸ì— ì–‘ë©´ ëª¨ë‘ ë Œë”ë§í•˜ë ¤ë©´ ë‘ ë°©í–¥ì˜ ì‚¼ê°í˜•ì„ ê°ê° ì •ì˜í•´ì•¼ í•œë‹¤.                              3. ì¹´ë©”ë¼ì™€ ì¡°ëª… ì„¤ì •      ì¹´ë©”ë¼ ì´ˆê¸°í™”:      cam.eye = vec3(2000, 0, 0); // ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜  cam.at = vec3(0, 0, 0);     // ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ì§€ì   cam.up = vec3(0, 0, 1);     // ìœ„ìª½ ë°©í–¥              ì¹´ë©”ë¼ëŠ” íƒœì–‘ê³„ ì „ì²´ë¥¼ ê´€ì°°í•  ìˆ˜ ìˆë„ë¡ ë°°ì¹˜.            ì¡°ëª… ì„¤ì •:      light.position = vec4(0.0f, 0.0f, 0.0f, 1.0f); // íƒœì–‘ì„ ì¡°ëª… ìœ„ì¹˜ë¡œ ì„¤ì •  light.ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f);  light.diffuse = vec4(0.8f, 0.8f, 0.8f, 1.0f);  light.specular = vec4(1.0f, 1.0f, 1.0f, 1.0f);              íƒœì–‘ì„ ê´‘ì›ì˜ ìœ„ì¹˜ë¡œ ì„¤ì •í•˜ë©°, í™˜ê²½ê´‘, ë‚œë°˜ì‚¬, ì •ë°˜ì‚¬ë¥¼ êµ¬ì„±.      ë°ì´í„° ì—…ë°ì´íŠ¸ì—…ë°ì´íŠ¸ ì‘ì—…ì€ ë§¤ í”„ë ˆì„ë§ˆë‹¤ í˜¸ì¶œë˜ëŠ” update() í•¨ìˆ˜ì—ì„œ ìˆ˜í–‰ë¨.ì´ í•¨ìˆ˜ëŠ” ì‹œê°„(t)ì— ë”°ë¼ í–‰ì„±ì˜ ìœ„ì¹˜ì™€ íšŒì „ ìƒíƒœë¥¼ ë™ì ìœ¼ë¡œ ê³„ì‚°í•œë‹¤.1. ì‹œê°„ ê³„ì‚°      ì‹œê°„ ê´€ë¦¬:      if (!isPause) t = float(glfwGetTime()) - bt;  else bt = float(glfwGetTime()) - t;              glfwGetTime()ì„ ì‚¬ìš©í•˜ì—¬ ì‹œë®¬ë ˆì´ì…˜ì´ ì‹œì‘ëœ ì´í›„ì˜ ê²½ê³¼ ì‹œê°„ì„ ì–»ìŒ.      isPause ë³€ìˆ˜ë¡œ ì• ë‹ˆë©”ì´ì…˜ì„ ì¼ì‹œ ì •ì§€í•˜ê±°ë‚˜ ì¬ê°œ ê°€ëŠ¥.      2. ê³µì „ ìœ„ì¹˜ ê³„ì‚°      ê³µì „ ì†ë„:    speed = t * 100 / radius[i];              ê³µì „ ì†ë„ëŠ” í–‰ì„±ì˜ í¬ê¸°(radius[i])ì— ë°˜ë¹„ë¡€í•˜ì—¬ ê³„ì‚°.      ì´ëŠ” í–‰ì„±ì˜ ë°˜ì§€ë¦„ì´ í´ìˆ˜ë¡ ê³µì „ ì†ë„ê°€ ëŠë ¤ì§ì„ ì˜ë¯¸.            ìœ„ì¹˜ ë³€í™˜:    mat4 trans_mat = {    cosf(speed), -sinf(speed), 0, 0,    sinf(speed),  cosf(speed), 0, 0,    0,            0,           1, 0,    0,            0,           0, 1};vec3 temp_pos = vec3(0, 1, 0); temp_pos = mat3(trans_mat) * temp_pos;temp_pos *= rot_rad[i];              í–‰ì„±ì˜ ê³µì „ ìš´ë™ì€ ì›í˜• íšŒì „ í–‰ë ¬(trans_mat) ì„ ì‚¬ìš©í•´ ê³„ì‚°.      ê³µì „ ë°˜ì§€ë¦„(rot_rad[i])ì„ ê³±í•˜ì—¬ í–‰ì„±ì´ ì¤‘ì‹¬ì²´ë¡œë¶€í„°ì˜ ìœ„ì¹˜ë¥¼ ê²°ì •.      3. ìì „ ìš´ë™ ê³„ì‚°      íšŒì „ í–‰ë ¬:    mat4 rot_mat = {    cosf(speed), -sinf(speed), 0, 0,    sinf(speed),  cosf(speed), 0, 0,    0,            0,           1, 0,    0,            0,           0, 1};rot_mat = mat4::rotate(vec3(1, 0, 0), axis[i]) * rot_mat;              ìì „ ìš´ë™ì€ í–‰ì„±ì˜ ìì „ì¶•(axis[i])ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ íšŒì „ìœ¼ë¡œ ê³„ì‚°.      í–‰ì„±ì˜ íšŒì „ ìƒíƒœëŠ” í–‰ì„± í‘œë©´ì— í…ìŠ¤ì²˜ë¥¼ ì ìš©í•  ë•Œ ì‚¬ìš©.      4. ë§ ë°ì´í„° ì—…ë°ì´íŠ¸      ë§ ìœ„ì¹˜ ê³„ì‚°:    float speed = t * 10 / radius[i + 6];vec3 temp_pos = vec3(offset[(i + 6) * 3 + 0], offset[(i + 6) * 3 + 1], offset[(i + 6) * 3 + 2]);memcpy(ring_offset + i * 3, (float*)temp_pos, 3 * sizeof(float));              ë§ì˜ ìœ„ì¹˜ëŠ” í•´ë‹¹ í–‰ì„±ì˜ ê³µì „ ìœ„ì¹˜ì™€ ë™ê¸°í™”.      ë§ì˜ íšŒì „ ìƒíƒœëŠ” ë³„ë„ë¡œ ê³„ì‚°í•˜ì—¬ íšŒì „ íš¨ê³¼ë¥¼ ë¶€ì—¬.      5. ì…°ì´ë”ì— ë°ì´í„° ì „ë‹¬      í–‰ì„± ë°ì´í„° ì—…ë°ì´íŠ¸:    glUniform1fv(glGetUniformLocation(program, \"radius\"), NUM_SPHERE, radius);glUniformMatrix4fv(glGetUniformLocation(program, \"rotate_mat\"), NUM_SPHERE, GL_TRUE, rotate_mat);glUniform3fv(glGetUniformLocation(program, \"location\"), NUM_SPHERE, offset);              ê° í–‰ì„±ì˜ í¬ê¸°(radius), ìœ„ì¹˜(offset), íšŒì „ ìƒíƒœ(rotate_mat)ë¥¼ GLSL ì…°ì´ë”ë¡œ ì „ë‹¬.            ë§ ë°ì´í„° ì—…ë°ì´íŠ¸:    glUniform1fv(glGetUniformLocation(program, \"radius\"), 4, ring_radius);glUniformMatrix4fv(glGetUniformLocation(program, \"rotate_mat\"), 2, GL_TRUE, rotate_mat);glUniform3fv(glGetUniformLocation(program, \"location\"), 2, ring_offset);      ì¹´ë©”ë¼ ì¡°ì‘  ì¹´ë©”ë¼ íšŒì „: ì¹´ë©”ë¼ê°€ íŠ¹ì • ì¶•ì„ ì¤‘ì‹¬ìœ¼ë¡œ íšŒì „.  ì¤Œ(í™•ëŒ€/ì¶•ì†Œ): ì¹´ë©”ë¼ì™€ ëŒ€ìƒ ê°„ì˜ ê±°ë¦¬ë¥¼ ì¡°ì ˆ.  íŒ¨ë‹(panning): ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ë¥¼ í‰í–‰ ì´ë™.1. mouse í•¨ìˆ˜: ë§ˆìš°ìŠ¤ ì…ë ¥ ì²˜ë¦¬ì‚¬ìš©ìê°€ ë²„íŠ¼ì„ í´ë¦­í•˜ê±°ë‚˜ ë†“ì„ ë•Œ í˜¸ì¶œ.if (button == GLFW_MOUSE_BUTTON_LEFT || button == GLFW_MOUSE_BUTTON_MIDDLE || button == GLFW_MOUSE_BUTTON_RIGHT) {    dvec2 pos; glfwGetCursorPos(window, &amp;pos.x, &amp;pos.y);    vec2 npos = vec2(float(pos.x) / float(window_size.x - 1), float(pos.y) / float(window_size.y - 1));    prev = npos;                 // ë§ˆìš°ìŠ¤ ì´ì „ ìœ„ì¹˜ ì €ì¥    prev_at = cam.at;            // ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ëŒ€ìƒ ì €ì¥    prev_eye = cam.eye;          // ì¹´ë©”ë¼ ìœ„ì¹˜ ì €ì¥    prev_pan = panning;          // ì´ì „ íŒ¨ë‹ ë³€í™˜ ì €ì¥    prev_view = cam.view_matrix; // ì´ì „ ë·° í–‰ë ¬ ì €ì¥    if (action == GLFW_PRESS) {        if (button == GLFW_MOUSE_BUTTON_MIDDLE) key_ctrl = true;        if (button == GLFW_MOUSE_BUTTON_RIGHT) key_shift = true;        tb.begin(cam.view_matrix, npos.x, npos.y); // íŠ¸ë™ë³¼ ì´ˆê¸°í™”        prev_mouse = npos;    } else if (action == GLFW_RELEASE) {        if (button == GLFW_MOUSE_BUTTON_MIDDLE) key_ctrl = false;        if (button == GLFW_MOUSE_BUTTON_RIGHT) key_shift = false;        tb.end(); // íŠ¸ë™ë³¼ ì¶”ì  ì¢…ë£Œ    }}2. motion í•¨ìˆ˜: ë§ˆìš°ìŠ¤ ì´ë™ ì²˜ë¦¬if(!tb.is_tracking()) return;vec2 npos = vec2( float(x)/float(window_size.x-1), float(y)/float(window_size.y-1) );if (key_shift) { // ì¤Œ    float rate = (npos.y - prev_mouse.y);    if (rate &gt;= 0.99f) rate = 0.99f;    cam.eye = (1 - rate) * prev_eye + rate * cam.at; // ì¹´ë©”ë¼ì™€ ëŒ€ìƒ ê°„ ê±°ë¦¬ ì¡°ì •    cam.view_matrix = mat4::look_at(cam.eye, cam.at, cam.up);}else if (key_ctrl) {    // í‰í–‰ ì´ë™ ë³€í™˜    panning = mat4::translate((npos.x - prev.x) * 300, (prev.y - npos.y) * 300, 0);    cam.view_matrix = panning * prev_view;    cam.eye = ((mat3)cam.view_matrix).inverse() * -vec3(cam.view_matrix.at(3), cam.view_matrix.at(7), cam.view_matrix.at(11));    cam.at = (cam.eye - prev_eye) + prev_at; // ëŒ€ìƒ ìœ„ì¹˜ ê°±ì‹ }else {    // íŠ¸ë™ë³¼ ì—…ë°ì´íŠ¸    cam.view_matrix = tb.update(npos.x, npos.y, cam.at);    cam.eye = ((mat3)cam.view_matrix).inverse() * -vec3(cam.view_matrix.at(3), cam.view_matrix.at(7), cam.view_matrix.at(11));    vec3 u = vec3(cam.view_matrix._11, cam.view_matrix._12, cam.view_matrix._13);    vec3 n = vec3(cam.view_matrix._31, cam.view_matrix._32, cam.view_matrix._33);    cam.up = n.cross(u); // ìƒˆë¡œìš´ ìƒë‹¨ ë²¡í„° ê³„ì‚°}ê¸°ëŠ¥  ì¤Œ:          ë§ˆìš°ìŠ¤ ì´ë™ì˜ Yì¶• ë³€í™”ëŸ‰ìœ¼ë¡œ ì¤Œ ë¹„ìœ¨(rate)ì„ ê³„ì‚°.      ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ cam.eyeë¥¼ ì¡°ì •í•˜ì—¬ ëŒ€ìƒ cam.atê³¼ì˜ ê±°ë¦¬ë¥¼ ë³€ê²½.        íŒ¨ë‹ ëª¨ë“œ:          ë§ˆìš°ìŠ¤ ì´ë™ì˜ X, Y ë³€í™”ëŸ‰ìœ¼ë¡œ ì¹´ë©”ë¼ë¥¼ í‰í–‰ ì´ë™.      ì´ë™ í–‰ë ¬ panningì„ ìƒì„±í•˜ì—¬ ì¹´ë©”ë¼ì˜ ë·° í–‰ë ¬ì— ì ìš©.      ì¹´ë©”ë¼ ìœ„ì¹˜(cam.eye)ì™€ ëŒ€ìƒ(cam.at)ì„ ê°±ì‹ .        íšŒì „ ëª¨ë“œ:          íŠ¸ë™ë³¼(trackball)ì„ ì‚¬ìš©í•´ ì¹´ë©”ë¼ íšŒì „ êµ¬í˜„.      íŠ¸ë™ë³¼ì€ ë§ˆìš°ìŠ¤ ì´ë™ì— ë”°ë¼ ì¹´ë©”ë¼ì˜ ë·° í–‰ë ¬ì„ íšŒì „ ë³€í™˜.      ìƒˆë¡œìš´ ë·° í–‰ë ¬(cam.view_matrix)ê³¼ ì¹´ë©”ë¼ ìœ„ì¹˜(cam.eye), ìƒë‹¨ ë²¡í„°(cam.up)ë¥¼ ê³„ì‚°.      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ë¯¸ë‹ˆ ì‰˜ ë§Œë“¤ê¸°",
    "url": "/posts/Swsh/",
    "categories": "Project, C_CPP",
    "tags": "mini_shell",
    "date": "2025-01-10 17:01:45 +0900",
    





    
    "snippet": "ë¯¸ë‹ˆì‰˜ (swsh) ë™ì‘ ê³¼ì •1. ì´ˆê¸° ì„¤ì •1.1 í™˜ê²½ ë³€ìˆ˜ ì„¤ì •  custom_binary = \"./commands/bin:\"ì„ ê¸°ì¡´ PATH í™˜ê²½ ë³€ìˆ˜ì™€ í•©ì³ì„œ ìƒˆë¡œìš´ PATHë¥¼ ì„¤ì •í•œë‹¤.  ì´ë¥¼ í†µí•´ ì‚¬ìš©ìê°€ ì‹¤í–‰ íŒŒì¼ì„ ./commands/bin/ ë””ë ‰í† ë¦¬ì—ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ í•¨.1.2 ì‹œê·¸ë„ í•¸ë“¤ë§  SIGINT (Ctrl+C)ì™€ SIGTS...",
    "content": "ë¯¸ë‹ˆì‰˜ (swsh) ë™ì‘ ê³¼ì •1. ì´ˆê¸° ì„¤ì •1.1 í™˜ê²½ ë³€ìˆ˜ ì„¤ì •  custom_binary = \"./commands/bin:\"ì„ ê¸°ì¡´ PATH í™˜ê²½ ë³€ìˆ˜ì™€ í•©ì³ì„œ ìƒˆë¡œìš´ PATHë¥¼ ì„¤ì •í•œë‹¤.  ì´ë¥¼ í†µí•´ ì‚¬ìš©ìê°€ ì‹¤í–‰ íŒŒì¼ì„ ./commands/bin/ ë””ë ‰í† ë¦¬ì—ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ í•¨.1.2 ì‹œê·¸ë„ í•¸ë“¤ë§  SIGINT (Ctrl+C)ì™€ SIGTSTP (Ctrl+Z)ë¥¼ ë¬´ì‹œí•˜ë„ë¡ ì„¤ì •.  SIGCHLD ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ì—¬ ì¢…ë£Œëœ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ì •ë¦¬í•˜ëŠ” í•¸ë“¤ëŸ¬ chld_handler ë“±ë¡.2. ì…ë ¥ ë° íŒŒì‹±2.1 ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬  read(0, input, 256)ì„ ì´ìš©í•´ ìµœëŒ€ 256ë°”ì´íŠ¸ê¹Œì§€ ì…ë ¥ì„ ì½ìŒ.  ì…ë ¥ì„ split_commands(input, &amp;cmd_cnt)ë¡œ ë¶„ë¦¬í•˜ì—¬ ëª…ë ¹ì–´ ëª©ë¡ì„ ìƒì„±.2.2 ëª…ë ¹ì–´ íŒŒì‹± (argparse.c)  split_commands í•¨ìˆ˜:          | ê¸°í˜¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ëª…ë ¹ì–´ë¥¼ ì—¬ëŸ¬ ê°œë¡œ ë¶„ë¦¬í•¨.      parse_redirectionì„ ì‚¬ìš©í•´ &gt;, &lt;, &gt;&gt; ë“± ì…ì¶œë ¥ ë¦¬ë‹¤ì´ë ‰ì…˜ì„ ì²˜ë¦¬.      parse_commandë¥¼ í†µí•´ ëª…ë ¹ì–´ì™€ ì¸ìë¥¼ íŒŒì‹±í•˜ì—¬ COMMAND êµ¬ì¡°ì²´ì— ì €ì¥.      3. ëª…ë ¹ ì‹¤í–‰3.1 íŒŒì´í”„ ì„¤ì •  ëª…ë ¹ì–´ ê°œìˆ˜(cmd_cnt)ë¥¼ í™•ì¸í•˜ê³  í•„ìš”í•˜ë©´ pipe(pipe_fds)ë¥¼ ìƒì„±.  prev_pipe_fdë¥¼ ì´ìš©í•˜ì—¬ ì´ì „ ëª…ë ¹ì˜ ì¶œë ¥ì„ í˜„ì¬ ëª…ë ¹ì˜ ì…ë ¥ìœ¼ë¡œ ì—°ê²°.3.2 ëª…ë ¹ ì‹¤í–‰ ê³¼ì •  ê° ëª…ë ¹ì„ fork()í•˜ì—¬ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•œ í›„ ì‹¤í–‰.  setup_redirectionì„ ì´ìš©í•´ ì…ë ¥/ì¶œë ¥ ë¦¬ë‹¤ì´ë ‰ì…˜ì„ ì²˜ë¦¬.  execvp(cmd-&gt;cmd, cmd-&gt;argv)ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‹¤í–‰ íŒŒì¼ì„ ì‹¤í–‰.  íŒŒì´í”„ì˜ ì½ê¸°/ì“°ê¸° íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°ë¥¼ ì ì ˆíˆ ë‹«ìŒ.  waitpid(-1, &amp;status, 0)ë¥¼ ì´ìš©í•´ ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°.3.3 ë‚´ë¶€ ëª…ë ¹ ì‹¤í–‰ (inline.c)  cd, pwd, exitëŠ” ë³„ë„ë¡œ fork() ì—†ì´ ì‹¤í–‰.          cd: chdir(path)ë¥¼ í˜¸ì¶œí•˜ì—¬ í˜„ì¬ ë””ë ‰í† ë¦¬ë¥¼ ë³€ê²½.      pwd: getcwd()ë¥¼ í˜¸ì¶œí•˜ì—¬ í˜„ì¬ ë””ë ‰í† ë¦¬ë¥¼ ì¶œë ¥.      exit: exit(status)ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‰˜ ì¢…ë£Œ.      4. ì •ë¦¬ ë° ì¢…ë£Œ  ì‹¤í–‰ì´ ëë‚œ í›„ restore_redirectionì„ í˜¸ì¶œí•˜ì—¬ ì›ë˜ì˜ í‘œì¤€ ì…ë ¥/ì¶œë ¥ ìƒíƒœ ë³µêµ¬.  COMMAND_freeë¥¼ ì´ìš©í•´ ë™ì  í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ í•´ì œ.  free(cmds)ë¥¼ í˜¸ì¶œí•˜ì—¬ COMMAND ëª©ë¡ì„ í•´ì œ.  ë‹¤ìŒ ì…ë ¥ì„ ê¸°ë‹¤ë¦¬ë©° ë£¨í”„ë¥¼ ë°˜ë³µ.ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ì›¹í˜ì´ì§€ ì œëª© ìˆ˜ì§‘ê¸°",
    "url": "/posts/Title_Collector/",
    "categories": "Project, C_CPP",
    "tags": "Title_Collector",
    "date": "2025-01-04 16:59:17 +0900",
    





    
    "snippet": "êµ¬í˜„ ì •ë¦¬1. êµ¬ì„± ìš”ì†Œ1.1 TaskQueuewget ì‘ì—…ì„ ë‹¤ë£¨ëŠ” Task Queue  í—¤ë”: task_queue.h  êµ¬í˜„: task_queue.cí•¨ìˆ˜:  TaskQueue_init: TaskQueue ì´ˆê¸°í™”.  TaskQueue_push: Task ì¶”ê°€.  TaskQueue_pop: Taskë¥¼ Queueì—ì„œ í•˜ë‚˜ êº¼ëƒ„.  TaskQueue_de...",
    "content": "êµ¬í˜„ ì •ë¦¬1. êµ¬ì„± ìš”ì†Œ1.1 TaskQueuewget ì‘ì—…ì„ ë‹¤ë£¨ëŠ” Task Queue  í—¤ë”: task_queue.h  êµ¬í˜„: task_queue.cí•¨ìˆ˜:  TaskQueue_init: TaskQueue ì´ˆê¸°í™”.  TaskQueue_push: Task ì¶”ê°€.  TaskQueue_pop: Taskë¥¼ Queueì—ì„œ í•˜ë‚˜ êº¼ëƒ„.  TaskQueue_destroy: Queueì—ì„œ ì‚¬ìš©í•œ ìì›ì„ ì •ë¦¬.Task Structure:typedef struct Task {    char url[MAX_DOMAIN_SIZE];    char filename[16];    bool final; // ìŠ¤ë ˆë“œ ì¢…ë£Œë¥¼ ìœ„í•œ ì‘ì—… ì¢…ë£Œ ì§€ì‹œì    struct Task *next;} Task;1.2 ìŠ¤ë ˆë“œ í’€wget ì‘ì—…ì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ìŠ¤ë ˆë“œ í’€  í—¤ë”: task_queue.h  êµ¬í˜„: task_queue.cí•¨ìˆ˜:  thread_pool_init: ìŠ¤ë ˆë“œ í’€ ì´ˆê¸°í™”.  thread_pool_add_task: Task Queueì— Task ì¶”ê°€.  thread_pool_wait: ëª¨ë“  Task ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°.  thread_pool_destroy: íì— ì¢…ë£Œ Taskë¥¼ ì¶”ê°€í•´ ëª¨ë“  ìŠ¤ë ˆë“œ ì¢…ë£Œ í›„ ìì› ì •ë¦¬.1.3 ë©”ëª¨ë¦¬ í’€ìˆ˜ì§‘í•œ Domain, Title ìŒì„ ì €ì¥í•˜ê¸° ìœ„í•œ BST ì „ìš© ë©”ëª¨ë¦¬ í’€  í—¤ë”: memory_pool.h  êµ¬í˜„: memory_pool.cí•¨ìˆ˜:  MemoryPool_init: ë©”ëª¨ë¦¬ í’€ ì´ˆê¸°í™”.  MemoryPool_alloc: ë©”ëª¨ë¦¬ í’€ì—ì„œ ìì› í• ë‹¹.  MemoryPool_free: ë©”ëª¨ë¦¬ í’€ë¡œ ìì› ë°˜í™˜.  MemoryPool_destroy: ë©”ëª¨ë¦¬ í’€ ì •ë¦¬.1.4 Binary Search Tree (BST)ìˆ˜ì§‘í•œ Domain, Title ìŒì„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ í˜•íƒœë¡œ ì €ì¥  í—¤ë”: bst.h  êµ¬í˜„: bst.cí•¨ìˆ˜:  BST_new: BST ë…¸ë“œ ìƒì„±.  BST_insert: Domain, Title ìŒ ì¶”ê°€.  BST_search: Domain ê²€ìƒ‰.  BST_print_inorder: ë””ë²„ê¹… ìš© BST Inorder ì¶œë ¥ í•¨ìˆ˜.1.5 Collectê³¼ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ê¸°ëŠ¥ë“¤ ì§‘í•©  í—¤ë”: collect.h  êµ¬í˜„: collect.cí•¨ìˆ˜:  wget: í˜ì´ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ê³  titleì„ ì¶”ì¶œí•´ì„œ BSTì— ì €ì¥.  find_title: HTML fileì—ì„œ title íƒœê·¸ ì¶”ì¶œ.  get_domain_name: URLì—ì„œ Domain Nameì„ ì¶”ì¶œ.  concat_string: ì—¬ëŸ¬ ê°œì˜ ë¬¸ìì—´ì„ ì—°ê±¸.1.6 BackupStackload ëª…ë ¹ ì‹¤í–‰ ì‹œ ë‚¨ì•„ìˆë˜ ê¸°ì¡´ ëª…ë ¹ì„ ìŠ¤íƒì— ë°±ì—…í•¨  êµ¬í˜„: main.cí•¨ìˆ˜:  backup: ë‚¨ì€ ëª…ë ¹ì„ ì…ë ¥ìœ¼ë¡œë¶€í„° ì €ì¥.  restore: ì €ì¥ëœ ëª…ë ¹ì„ ì…ë ¥ìœ¼ë¡œ ë³µì›.2. ì‘ì—… íë¦„  ëª…ë ¹ì–´ë¥¼ ì½ì–´ë“¤ì„.          ì½ì§€ ëª»í–ˆì„ ê²½ìš°                  í˜„ì¬ ì…ë ¥ì´ í‘œì¤€ ì…ë ¥ì´ê³  ë‚¨ì€ ëª…ë ¹ì–´ê°€ ì—†ì„ ê²½ìš° ìì›ì„ ì •ë¦¬í•˜ê³  ì¢…ë£Œ          ë¦¬ë‹¤ì´ë ‰íŠ¸ ëì„ ê²½ìš°                          ë‚¨ì€ ëª…ë ¹ì–´ê°€ ì—†ìœ¼ë©´ í‘œì¤€ ì…ë ¥ìœ¼ë¡œ ë³µêµ¬              ë‚¨ì•˜ì„ ê²½ìš° ëª…ë ¹ì–´ ë°±ì—…ìœ¼ë¡œë¶€í„° ë³µêµ¬                                          ì½ì—ˆì„ ê²½ìš° ê°œí–‰ë¬¸ì ê¸°ì¤€ìœ¼ë¡œ í† í°í™”        ì‘ì—… ìˆ˜í–‰          URLì˜ ê²½ìš°, thread_poolì— ì‘ì—… ì¶”ê°€      print, statì˜ ê²½ìš° ëª¨ë“  thread ì‘ì—… ì™„ë£Œ ëŒ€ê¸° í›„ ëª…ë ¹ ìˆ˜í–‰      loadì˜ ê²½ìš° load ì´í›„ì— ë‚¨ì•„ìˆëŠ” ëª…ë ¹ ë°±ì—… í›„ ì…ë ¥ ë¦¬ë‹¤ì´ë ‰ì…˜ ë° 1ë²ˆìœ¼ë¡œ ì´ë™      quitì˜ ê²½ìš° ìì› ì •ë¦¬ í›„ ì¢…ë£Œ      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "string.h ì§ì ‘ êµ¬í˜„í•˜ê¸°",
    "url": "/posts/Stringh/",
    "categories": "Project, C_CPP",
    "tags": "string.h",
    "date": "2025-01-03 16:40:20 +0900",
    





    
    "snippet": "ë¬¸ìì—´ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„1. ê°œìš”  C í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ &lt;string.h&gt; ë° ê¸°íƒ€ ë¬¸ìì—´ ê´€ë ¨ í•¨ìˆ˜ë“¤ì„ ì§ì ‘ êµ¬í˜„.  ì•ìœ¼ë¡œì˜ ê³¼ì œë¥¼ ìœ„í•´ ë¬¸ìì—´ ì²˜ë¦¬ì™€ ë³€í™˜ í•¨ìˆ˜ë“¤ì„ ì¤€ë¹„.2. êµ¬í˜„ í•¨ìˆ˜2.1 ìˆ«ì ë³€í™˜ (Conversions)ë¬¸ìì—´ â†’ ìˆ«ì  int atoi2(const char *str):          ë¬¸ìì—´ strì„ intë¡œ ë³€...",
    "content": "ë¬¸ìì—´ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„1. ê°œìš”  C í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ &lt;string.h&gt; ë° ê¸°íƒ€ ë¬¸ìì—´ ê´€ë ¨ í•¨ìˆ˜ë“¤ì„ ì§ì ‘ êµ¬í˜„.  ì•ìœ¼ë¡œì˜ ê³¼ì œë¥¼ ìœ„í•´ ë¬¸ìì—´ ì²˜ë¦¬ì™€ ë³€í™˜ í•¨ìˆ˜ë“¤ì„ ì¤€ë¹„.2. êµ¬í˜„ í•¨ìˆ˜2.1 ìˆ«ì ë³€í™˜ (Conversions)ë¬¸ìì—´ â†’ ìˆ«ì  int atoi2(const char *str):          ë¬¸ìì—´ strì„ intë¡œ ë³€í™˜.      intëŠ” 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ ê°„ì£¼.        long atol2(const char *str):          ë¬¸ìì—´ strì„ longìœ¼ë¡œ ë³€í™˜.      longì€ 64ë¹„íŠ¸ ì •ìˆ˜ë¡œ ê°„ì£¼.      ìˆ«ì â†’ ë¬¸ìì—´  char *int2str(char *dest, int num):          ì •ìˆ˜ numì„ ë¬¸ìì—´ë¡œ ë³€í™˜ í›„ destì— ì €ì¥.      destê°€ NULLì¼ ê²½ìš°, ë™ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ì—¬ ë°˜í™˜.      ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ ì‹œ NULL ë°˜í™˜.      2.2 ë¬¸ìì—´ ì¡°ì‘ (String Manipulation)  char *strcpy(char *dst, const char *src):          ë¬¸ìì—´ srcë¥¼ dstë¡œ ë³µì‚¬.        char *strncpy(char *dst, const char *src, size_t count):          srcì—ì„œ ìµœëŒ€ count ë°”ì´íŠ¸ë¥¼ dstë¡œ ë³µì‚¬.        char *strcat(char *dst, const char *src):          dst ë¬¸ìì—´ì˜ ëì— srcë¥¼ ë¶™ì„.        char *strncat(char *dst, const char *src, size_t count):          dst ë¬¸ìì—´ì˜ ëì— ìµœëŒ€ count ë°”ì´íŠ¸ë§Œí¼ srcë¥¼ ë¶™ì„.        char *strdup(const char *str):          ë¬¸ìì—´ strì„ ë³µì‚¬í•˜ì—¬ ë™ì  ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ê³  í•´ë‹¹ í¬ì¸í„° ë°˜í™˜.      2.3 ë¬¸ìì—´ ê²€ì‚¬ (String Examination)  size_t strlen(const char *str):          ë¬¸ìì—´ strì˜ ê¸¸ì´ë¥¼ ë°˜í™˜.        int strcmp(const char *lhs, const char *rhs):          ë‘ ë¬¸ìì—´ lhsì™€ rhsë¥¼ ë¹„êµ.        int strncmp(const char *lhs, const char *rhs, size_t count):          lhsì™€ rhsë¥¼ ìµœëŒ€ count ë°”ì´íŠ¸ë§Œí¼ ë¹„êµ.        char *strchr(const char *str, int ch):          strì—ì„œ ë¬¸ì chê°€ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜í™˜.        char *strrchr(const char *str, int ch):          strì—ì„œ ë¬¸ì chê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜í™˜.        char *strpbrk(const char *str, const char *accept):          strì—ì„œ accept ë¬¸ìì—´ ì¤‘ í•˜ë‚˜ë¼ë„ ì²˜ìŒ ë“±ì¥í•˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜í™˜.        char *strstr(const char *str, const char *substr):          strì—ì„œ ë¶€ë¶„ ë¬¸ìì—´ substrì´ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜ë¥¼ ë°˜í™˜.        char *strtok(char *str, const char *delim):          strì„ delimìœ¼ë¡œ í† í°í™”.        char *strtok_r(char *str, const char *delim, char **saveptr):          strtokì™€ ë™ì¼í•˜ì§€ë§Œ, ë‚´ë¶€ ìƒíƒœ ëŒ€ì‹  saveptrì— ì €ì¥.      2.4 ë©”ëª¨ë¦¬ ì¡°ì‘ (Memory Manipulation)  void *memcpy(void *dest, const void *src, size_t n):          srcì—ì„œ destë¡œ n ë°”ì´íŠ¸ ë³µì‚¬.        void *memset(void *dest, int ch, size_t count):          destì—ì„œ count ë°”ì´íŠ¸ë¥¼ chë¡œ ì„¤ì •.      4. êµ¬í˜„ ì œí•œ ì‚¬í•­  C í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ê¸°íƒ€ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ ì‚¬ìš© ê¸ˆì§€.  í—ˆìš©ëœ í•¨ìˆ˜:          malloc, calloc, freeë¥¼ í¬í•¨í•œ ì¼ë¶€ ë©”ëª¨ë¦¬ ê´€ë¦¬ í•¨ìˆ˜.        í•„ìš”í•œ ê²½ìš° ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ë¥¼ ì§ì ‘ êµ¬í˜„ ê°€ëŠ¥.  ë™ì ìœ¼ë¡œ í• ë‹¹ëœ ëª¨ë“  ìì›ì€ í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì „ì— ë°˜ë“œì‹œ í•´ì œ.ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "Udemy Unreal ë©”ëª¨",
    "url": "/posts/Unreal/",
    "categories": "Study, Unreal",
    "tags": "Unreal",
    "date": "2025-01-01 13:50:56 +0900",
    





    
    "snippet": "# Lecture NoteUdemy ê°•ì˜ (https://www.udemy.com/course/unrealcourse-korean/)Object  ë°ì´í„°ì™€ ê¸°ëŠ¥ì˜ ì§‘í•©  ì•¡í„°: ë ˆë²¨ì— ë“¤ì–´ê°€ëŠ” ì˜¤ë¸Œì íŠ¸  ì»´í¬ë„ŒíŠ¸: ì•¡í„°ì— ë“¤ì–´ê°€ëŠ” ì˜¤ë¸Œì íŠ¸  ë¸”ë£¨í”„ë¦°íŠ¸ì—ì„œ ì°¸ì¡° ë°©ë²•          í™”ë©´ ì•ˆì˜ ì•¡í„° ì„ íƒ í›„ BPì˜ ì´ë²¤íŠ¸ ê·¸ë˜í”„ì—ì„œ ìš°í´ë¦­ í›„ Creat...",
    "content": "# Lecture NoteUdemy ê°•ì˜ (https://www.udemy.com/course/unrealcourse-korean/)Object  ë°ì´í„°ì™€ ê¸°ëŠ¥ì˜ ì§‘í•©  ì•¡í„°: ë ˆë²¨ì— ë“¤ì–´ê°€ëŠ” ì˜¤ë¸Œì íŠ¸  ì»´í¬ë„ŒíŠ¸: ì•¡í„°ì— ë“¤ì–´ê°€ëŠ” ì˜¤ë¸Œì íŠ¸  ë¸”ë£¨í”„ë¦°íŠ¸ì—ì„œ ì°¸ì¡° ë°©ë²•          í™”ë©´ ì•ˆì˜ ì•¡í„° ì„ íƒ í›„ BPì˜ ì´ë²¤íŠ¸ ê·¸ë˜í”„ì—ì„œ ìš°í´ë¦­ í›„ Create a Reference ì„ íƒ        Data Pin: BP ë…¸ë“œì˜ In/Out  Execution Pin: ë…¸ë“œì˜ ì‹¤í–‰ íë¦„BP &amp; Instanceì•¡í„° ì„ íƒ í›„ ì˜¤ë¥¸ìª½ì˜ ë””í…Œì¼ í˜¹ì€ íˆ´ë°”ì—ì„œ BP í´ë˜ìŠ¤ë¡œ ë³€í™˜ ê°€ëŠ¥í•˜ë‹¤.BP í¸ì§‘ í™”ë©´ì—ì„œ í•´ë‹¹ í´ë˜ìŠ¤ì˜ ì—¬ëŸ¬ ì†ì„±ë“¤ì„ í¸ì§‘í•  ìˆ˜ ìˆìœ¼ë©°ì»¨í…ì¸  ë“œë¡œì–´ì—ì„œ ì”¬ì— ë“œë˜ê·¸í•˜ëŠ” ì‹ìœ¼ë¡œ í•´ë‹¹ BPí´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.Spawn BPclass : ìŠ¤í°í•  ì•¡í„°ì˜ í´ë˜ìŠ¤transform : location, rotation, scalecollision : ìŠ¤í° ì§€ì  ì¶©ëŒ ì²˜ë¦¬instigator : ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì—¬ëŸ¬ ë°ì´í„° íƒ€ì…ì´ ê²°í•©ëœ í•€ì˜ ê²½ìš°, ìš°í´ë¦­í•´ì„œ í•€ ë¶„í• ì„ í†µí•´ ì„¸ë¶€ íƒ€ì…ìœ¼ë¡œ ë¶„ë¦¬í•  ìˆ˜ ìˆë‹¤.SpawnActorëŠ” ìŠ¤í°í•œ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ë°˜í™˜í•œë‹¤. í•´ë‹¹ ì°¸ì¡°ë¥¼ ì´ìš©í•´ ì¶”ê°€ì ì¸ ì‘ì—…ì´ ê°€ëŠ¥í•˜ë‹¤.Control Rotation  Get Control Rotation : ì»¨íŠ¸ë¡¤ëŸ¬ì˜ íšŒì „ ë²¡í„°ë¥¼ ë°˜í™˜í•œë‹¤.  Get Forward Vector : íšŒì „ ë²¡í„°ë¥¼ ì •ë©´ ë²¡í„°ë¡œ ë³€í™˜í™˜ë‹¤.          Forward Vector: ê°ì²´ì˜ ì •ë©´ ë°©í–¥ì„ ì›”ë“œ ì¢Œí‘œê³„ì—ì„œ ë‚˜íƒ€ë‚¸ ë‹¨ìœ„ ë²¡í„°      Rotator : ê°ì²´ì˜ íšŒì „ì„ í‘œí•œí•˜ëŠ” ë²¡í„°        ë¬¼ì²´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë°”ë¼ë´¤ì„ ë•Œ ì¢Œìš° íšŒì „(Zì¶• ì¤‘ì‹¬)ì„ Yaw, ìƒí•˜ íšŒì „(Yì¶• ì¤‘ì‹¬)ì„ Pitch, ë¬¼ì²´ì˜ ìˆ˜í‰ ê¸°ìš¸ê¸°(Xì¶• ì¤‘ì‹¬)ì„ Rollì´ë¼ê³  í•œë‹¤.      Pure Function  side effectê°€ ì—†ëŠ” í•¨ìˆ˜  BP ìƒì—ì„œ ì‹¤í–‰ í•€ì´ ì—†ëŠ” í•¨ìˆ˜ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "SQL ë©”ëª¨",
    "url": "/posts/SQL/",
    "categories": "Study, Database",
    "tags": "SQL",
    "date": "2024-12-30 01:59:01 +0900",
    





    
    "snippet": "Database MEMOSQL êµ¬ë¬¸ í•´ì„ ìˆœì„œ  FROM: ë°ì´í„° ì†ŒìŠ¤ë¥¼ ì§€ì •  ON: ì¡°ì¸ ì¡°ê±´ì„ ì„¤ì •  JOIN: í•„ìš”í•œ í…Œì´ë¸” ê²°í•©  WHERE: í–‰ì„ í•„í„°ë§  GROUP BY: ë°ì´í„°ë¥¼ ê·¸ë£¹í™”  HAVING: ê·¸ë£¹í™”ëœ ë°ì´í„°ì— ì¶”ê°€ ì¡°ê±´ ì ìš©  SELECT: ì„ íƒí•œ ì»¬ëŸ¼ì„ ê°€ì ¸ì˜´  DISTINCT: ì¤‘ë³µëœ í–‰ ì œê±°  ORDER BY: ê²°ê³¼ë¥¼ ì •...",
    "content": "Database MEMOSQL êµ¬ë¬¸ í•´ì„ ìˆœì„œ  FROM: ë°ì´í„° ì†ŒìŠ¤ë¥¼ ì§€ì •  ON: ì¡°ì¸ ì¡°ê±´ì„ ì„¤ì •  JOIN: í•„ìš”í•œ í…Œì´ë¸” ê²°í•©  WHERE: í–‰ì„ í•„í„°ë§  GROUP BY: ë°ì´í„°ë¥¼ ê·¸ë£¹í™”  HAVING: ê·¸ë£¹í™”ëœ ë°ì´í„°ì— ì¶”ê°€ ì¡°ê±´ ì ìš©  SELECT: ì„ íƒí•œ ì»¬ëŸ¼ì„ ê°€ì ¸ì˜´  DISTINCT: ì¤‘ë³µëœ í–‰ ì œê±°  ORDER BY: ê²°ê³¼ë¥¼ ì •ë ¬  LIMIT: ê²°ê³¼ì˜ ê°œìˆ˜ë¥¼ ì œí•œêµ¬ë¬¸ ë³„ ë¬¸ë²•                              LIMIT B, A          LIMIT A OFFSET B: Bë²ˆì§¸ í–‰ë¶€í„° Aê°œì˜ í–‰ ì„ íƒ (0-index)                    ACIDğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "C++ ì •ë¦¬",
    "url": "/posts/CPP/",
    "categories": "Study, Programming Language",
    "tags": "C++",
    "date": "2024-12-30 01:55:08 +0900",
    





    
    "snippet": "C++ ì •ë¦¬Const  ìƒìˆ˜ì— ê´€í•œ í‚¤ì›Œë“œì¼ë°˜ ë³€ìˆ˜ì—ì„œì˜ const  ë³€ìˆ˜ ì„ ì–¸ì‹œ ì´í›„ í•´ë‹¹ ë³€ìˆ˜ì— ëŒ€í•œ ë³€ê²½ì„ ë§‰ëŠ”ë‹¤.      const í‚¤ì›Œë“œ ì´í›„ì˜ êµ¬ë¬¸ì— ëŒ€í•œ ë³€ê²½ì„ ë§‰ëŠ”ë‹¤ê³  ê°„ì£¼í•  ìˆ˜ ìˆë‹¤.    // ê¸°ë³¸ ìë£Œí˜•(int, float ë“±)ì€ ë¬´ì‹œí•˜ê³  ìƒê°const int val = 10;int const val = 10;// -&gt; va...",
    "content": "C++ ì •ë¦¬Const  ìƒìˆ˜ì— ê´€í•œ í‚¤ì›Œë“œì¼ë°˜ ë³€ìˆ˜ì—ì„œì˜ const  ë³€ìˆ˜ ì„ ì–¸ì‹œ ì´í›„ í•´ë‹¹ ë³€ìˆ˜ì— ëŒ€í•œ ë³€ê²½ì„ ë§‰ëŠ”ë‹¤.      const í‚¤ì›Œë“œ ì´í›„ì˜ êµ¬ë¬¸ì— ëŒ€í•œ ë³€ê²½ì„ ë§‰ëŠ”ë‹¤ê³  ê°„ì£¼í•  ìˆ˜ ìˆë‹¤.    // ê¸°ë³¸ ìë£Œí˜•(int, float ë“±)ì€ ë¬´ì‹œí•˜ê³  ìƒê°const int val = 10;int const val = 10;// -&gt; valì— ëŒ€í•œ ë³€ê²½ ê¸ˆì§€const int *val = ...;// ì´í›„ *val = ...; ê¸ˆì§€// val = ...; ê°€ëŠ¥const int **val = ...;// **val = ...; ê¸ˆì§€// *val = ...; val = ...; ê°€ëŠ¥const int * const *val = ...;// **val = ...; *val = ...; ê¸ˆì§€// val = ...; ê°€ëŠ¥      í•¨ìˆ˜ì—ì„œì˜ const  ë°˜í™˜í˜•, ë§¤ê°œë³€ìˆ˜ì˜ constëŠ” ì¼ë°˜ ë³€ìˆ˜ì™€ ë™ì¼  ë©¤ë²„ í•¨ìˆ˜ì˜ ê²½ìš° í•¨ìˆ˜ ì‹œê·¸ë‹ˆì³ ì´í›„ì— constë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.      const ë©¤ë²„ í•¨ìˆ˜ì˜ ì œì•½ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.      class MyClass {  private:      int value = 10;      mutable int mutableValue = 0;      static int staticValue;  public:      int getValue() { // non-const ë©¤ë²„ í•¨ìˆ˜          return value;      }      void SetValue(int val) const { // const ë©¤ë²„ í•¨ìˆ˜          value = val; // ì¼ë°˜ ë©¤ë²„ ë³€ìˆ˜ ìˆ˜ì • ë¶ˆê°€          staticValue = mutableValue = 1; // static, mutable ë©¤ë²„ ë³€ìˆ˜ ìˆ˜ì • ê°€ëŠ¥      }      bool IsPositive() const { // const ë©¤ë²„ í•¨ìˆ˜          int val = GetValue();  // ì¼ë°˜ ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ ë¶ˆê°€          SetValue(0); // const ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ ê°€ëŠ¥          GetStaticValue(); // static ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ ê°€ëŠ¥          externalFunction(value); // ì™¸ë¶€ í•¨ìˆ˜ í˜¸ì¶œ ê°€ëŠ¥          return value &gt; 0;         }      static int GetStaticValue() {          staticValue = 10; // static ë©¤ë²„ í•¨ìˆ˜ëŠ” static ë©¤ë²„ í•¨ìˆ˜/ë³€ìˆ˜ë§Œ ì ‘ê·¼ ê°€ëŠ¥          return staticValue;      }  };  // ì™¸ë¶€ í•¨ìˆ˜  void externalFunction(int&amp; val) {      val = 50;  }  int MyClass::staticValue = 0;       ìƒì†, ë‹¤í˜•ì„±, Virtual  ìƒì†: ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì†ì„±ì´ë‚˜ ë©”ì†Œë“œë¥¼ ìì‹ í´ë˜ìŠ¤ê°€ ë¬¼ë ¤ ë°›ëŠ” ê²ƒ.ì½”ë“œ ì¬ì‚¬ìš©ì„± ì¦ê°€, ê°ì²´ ëª¨ë¸ë§ ìœ ì—°ì„± ì¦ê°€      ë‹¤í˜•ì„±: ê°™ì€ ì´ë¦„ì˜ ë©”ì†Œë“œë‚˜ ì—°ì‚°ìê°€ ë‹¤ë¥¸ í´ë˜ìŠ¤ì— ëŒ€í•´ ë‹¤ë¥¸ ë™ì‘ì„ í•˜ëŠ” ê²ƒ    íƒ€ì… ìºìŠ¤íŒ…                  ì—… ìºìŠ¤íŒ…ê³¼ Virtual í‚¤ì›Œë“œë‹¤í˜•ì„±ì„ ìœ„í•´ ìì‹ í´ë˜ìŠ¤ë¥¼ ë¶€ëª¨ í´ë˜ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” ê²½ìš°                    ë‹¤ìš´ ìºìŠ¤íŒ…ê³¼ RTTIë¶€ëª¨ í´ë˜ìŠ¤ì˜ ê°ì²´ë¥¼ ìì‹ í´ë˜ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” ê²½ìš°dynamic_castë¥¼ ì´ìš©í•´ ìˆ˜í–‰ë˜ë©° ëŸ°íƒ€ì„ì— ê°ì²´ì˜ íƒ€ì…ì„ í™•ì¸ í›„, ë¶ˆê°€ëŠ¥í•œ ê²½ìš° í¬ì¸í„°ëŠ” nullptr ë°˜í™˜, ì°¸ì¡°ìëŠ” std::bad_cast ì˜ˆì™¸ë¥¼ ë˜ì§„ë‹¤.              class Animal {  public:      virtual void says() { cout &lt;&lt; \"Animal says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Animal\" &lt;&lt; endl; }};  class Dog : public Animal {  public:      void says() override { cout &lt;&lt; \"Dog says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Dog\" &lt;&lt; endl; }  };  Animal* a = new Animal();  Animal* b = new Dog();  a-&gt;says(); // Animal says  a-&gt;what(); // Animal  b-&gt;says(); // Dog says  b-&gt;what(); // Animal              Dog í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë¶€ëª¨ì¸ Animalë¡œ ì—…ìºìŠ¤íŒ…í–ˆë‹¤.í•¨ìˆ˜ í˜¸ì¶œ ê²°ê³¼ë¥¼ ë³´ë©´ virtual í•¨ìˆ˜ì¸ saysëŠ” ì›ë³¸ í´ë˜ìŠ¤ì˜ í•¨ìˆ˜ë¥¼ ì˜ í˜¸ì¶œí•˜ì§€ë§Œ whatì€ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ í•¨ìˆ˜ë§Œ í˜¸ì¶œëœë‹¤.      virtual í•¨ìˆ˜ê°€ ìˆëŠ” í´ë˜ìŠ¤ëŠ” ì»´íŒŒì¼ ê³¼ì •ì—ì„œ VTableì„ ìƒì„±í•´ í•¨ìˆ˜ í˜¸ì¶œì„ ê´€ë¦¬í•œë‹¤.      VTableì€ í´ë˜ìŠ¤ë§ˆë‹¤ ìƒì„±ë˜ë©° ê°ì²´ëŠ” VTable í¬ì¸í„°ë¥¼ í†µí•´ ìì‹ ì˜ í´ë˜ìŠ¤ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê²Œ ëœë‹¤.      non virtual í•¨ìˆ˜ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ì •ì ìœ¼ë¡œ ë°”ì¸ë”©ëœë‹¤.              ê°€ìƒ í•¨ìˆ˜ê°€ í¬í•¨ëœ í´ë˜ìŠ¤ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì€ ë‹¤ìŒê³¼ ê°™ë‹¤.        Animal ê°ì²´ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:+----------------------------+| Animal í´ë˜ìŠ¤ RTTI í¬ì¸í„°   |+----------------------------+| Animal í´ë˜ìŠ¤ VTable í¬ì¸í„° | &lt;-- aê°€ ì—¬ê¸¸ ê°€ë¦¬í‚¤ê³  ìˆìŒ+----------------------------+| (Animal í´ë˜ìŠ¤ ë©¤ë²„ ë³€ìˆ˜)   |+----------------------------+      Dog ê°ì²´ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:+----------------------------+| Dog í´ë˜ìŠ¤ RTTI í¬ì¸í„°      |+----------------------------+| Dog í´ë˜ìŠ¤ VTable í¬ì¸í„°    |  &lt;-- bê°€ ì—¬ê¸¸ ê°€ë¦¬í‚¤ê³  ìˆìŒ+----------------------------+| (Animal í´ë˜ìŠ¤ ë©¤ë²„ ë³€ìˆ˜)   |  +----------------------------+| (Dog í´ë˜ìŠ¤ ë©¤ë²„ ë³€ìˆ˜)      |+----------------------------+Animal VTable:+-----------------+| &amp;Animal::speak  |  // Animalì˜ says() í•¨ìˆ˜ ì£¼ì†Œ+-----------------+      Dog VTable:+-----------------+| &amp;Dog::speak     |  // Dogì˜ says() í•¨ìˆ˜ ì£¼ì†Œ+-----------------+                          í•´ë‹¹ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì€ ë‹¤ìŒê³¼ ê°™ì€ ë°©ë²•ìœ¼ë¡œë„ í™•ì¸ í•  ìˆ˜ ìˆë‹¤.                class A {    private:        int A_num;        int A_sum;    public:        A() {             A_num = 0x12121212;            A_sum = 0x34343434;            printf(\"A ìƒì„±ì\\n\");         }        virtual void says() { printf(\"Aì˜ func\\n\"); }        virtual ~A() { printf(\"A ì†Œë©¸ì\\n\"); }            };class B : public A {    private:        int B_num;        int B_sum;    public:        B() {             B_num = 0x56565656;            B_sum = 0x78787878;            printf(\"B ìƒì„±ì\\n\");         }        void says() override { printf(\"Bì˜ func\\n\"); }        ~B() { printf(\"B ì†Œë©¸ì\\n\"); }};A* c = new B();uintptr_t* vtablePtr = *reinterpret_cast&lt;uintptr_t**&gt;(c); // vtable í¬ì¸í„°printf(\"vtablePtr: %p\\n\", vtablePtr);int* dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t));printf(\"A_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int)); printf(\"A_sum: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 2);printf(\"B_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 3);printf(\"B_sum: %x\\n\", *dataPtr);auto funcPtr = reinterpret_cast&lt;void(*)(A*)&gt;(vtablePtr[0]);funcPtr(c);cout &lt;&lt; typeid(*c).name() &lt;&lt; endl;const std::type_info* rttiInfo = reinterpret_cast&lt;const std::type_info*&gt;(vtablePtr[-1]);std::cout &lt;&lt; \"RTTI type name: \" &lt;&lt; rttiInfo-&gt;name() &lt;&lt; std::endl;// ì¶œë ¥ ê²°ê³¼// A ìƒì„±ì// B ìƒì„±ì// vtablePtr: 0x5631eb7cbcc0// A_num: 12121212// A_sum: 34343434// B_num: 56565656// B_sum: 78787878// Bì˜ func// RTTI type name: 1B                            ì†Œë©¸ìë„ í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— ì†Œë©¸ìë¥¼ ê°€ìƒ í•¨ìˆ˜ë¡œ ì„ ì–¸í•˜ì§€ ì•Šìœ¼ë©´ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì†Œë©¸ìë§Œ í˜¸ì¶œë˜ì–´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.            ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜                  ê°€ìƒ í•¨ìˆ˜ë¥¼ ì„ ì–¸ë§Œ í•œ í˜•íƒœ                virtual void func() = 0;                          ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ê°€ í•˜ë‚˜ë¼ë„ ìˆëŠ” í´ë˜ìŠ¤ëŠ” ì¶”ìƒ í´ë˜ìŠ¤ë¼ í•˜ë©° í•´ë‹¹ í´ë˜ìŠ¤ëŠ” ê°ì²´ ìƒì„±ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.          ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ëŠ” ìƒì†ëœ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„í•´ì¤˜ì•¼ í•¨          ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ë¡œë§Œ ì´ë£¨ì–´ì§„ í´ë˜ìŠ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ë¼ê³  í•¨                    í¬ì¸í„°ì™€ ì°¸ì¡°ì            íŠ¹ì§•      í¬ì¸í„°      ì°¸ì¡°ì                  NULL ì§€ì›      ì§€ì› (nullptr)      ì§€ì›í•˜ì§€ ì•ŠìŒ              ì´ˆê¸°í™”      ë‚˜ì¤‘ì— ì´ˆê¸°í™” ê°€ëŠ¥      ì„ ì–¸ê³¼ ë™ì‹œì— ì´ˆê¸°í™” í•„ìˆ˜              ëŒ€ìƒ ë³€ê²½      ê°€ëŠ¥      ë¶ˆê°€ëŠ¥              ì‚¬ìš©ë²•      *, &amp; í•„ìš”      ê°„ë‹¨ (ë³€ìˆ˜ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥)              í¬ê¸°      ë©”ëª¨ë¦¬ ì£¼ì†Œ í¬ê¸°      í¬ê¸° ì—†ìŒ              ì‚°ìˆ  ì—°ì‚°      ê°€ëŠ¥ (ptr++)      ë¶ˆê°€ëŠ¥      ì„ íƒ ê¸°ì¤€  í¬ì¸í„°ë¥¼ ì‚¬ìš©í•  ë•Œ:          ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹ ë° ê´€ë¦¬ê°€ í•„ìš”í•  ë•Œ      NULL ê°’ì„ ê°€ë¦¬í‚¤ê±°ë‚˜ ê°€ë¦¬í‚¤ëŠ” ëŒ€ìƒì„ ë³€ê²½í•´ì•¼ í•  ë•Œ      ë°°ì—´, ë¬¸ìì—´, í•˜ë“œì›¨ì–´ ì£¼ì†Œë¥¼ ë‹¤ë£° ë•Œ        ì°¸ì¡°ìë¥¼ ì‚¬ìš©í•  ë•Œ:          ë§¤ê°œë³€ìˆ˜ë¡œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ì—¬ ë³µì‚¬ë¥¼ í”¼í•˜ê³  ì‹¶ì„ ë•Œ      ë°˜í™˜ê°’ìœ¼ë¡œ ê°ì²´ë¥¼ ì°¸ì¡°í•´ì•¼ í•  ë•Œ      ê°„ë‹¨í•˜ê³  ì§ê´€ì ì¸ ì½”ë“œë¥¼ ì‘ì„±í•˜ê³  ì‹¶ì„ ë•Œ      ê°ì²´ì˜ ì´ˆê¸°í™”C++ì—ì„œ í´ë˜ìŠ¤ ìƒì„±ìëŠ” ê°ì²´ê°€ ìƒì„±ë  ë•Œ í˜¸ì¶œë˜ì–´ ë©¤ë²„ ë³€ìˆ˜ë‚˜ ê¸°íƒ€ ìì›ì„ ì´ˆê¸°í™”í•˜ëŠ” íŠ¹ë³„í•œ í•¨ìˆ˜ë‹¤.1. ë©¤ë²„ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸(Member Initialization List)  ìƒì„±ì ì •ì˜ì—ì„œ ì½œë¡ (:) ë’¤ì— ë©¤ë²„ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ë¥¼ ì´ˆê¸°í™”  ë©¤ë²„ ë³€ìˆ˜ì˜ ì´ˆê¸°í™”ê°€ ìƒì„±ìì˜ ë³¸ì²´ê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ìˆ˜í–‰ë˜ë¯€ë¡œ íš¨ìœ¨ì   const ë©¤ë²„, ì°¸ì¡°ì ë©¤ë²„ëŠ” ìƒì„± ì‹œ ì´ˆê¸°í™” ë˜ì–´ì•¼ í•˜ë¯€ë¡œ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ê°€ í•„ìˆ˜class MyClass {private:    int value;    const int constValue;    int&amp; refValue;public:    MyClass(int val, int constVal, int&amp; ref)         : value(val), constValue(constVal), refValue(ref) {}};2. ìƒì„±ì ë³¸ë¬¸ì—ì„œ ì´ˆê¸°í™”  ìƒì„±ì ë³¸ë¬¸ì—ì„œ ì§ì ‘ ë©¤ë²„ ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•˜ì—¬ ì´ˆê¸°í™”.  ì„ì‹œ ê°ì²´ ìƒì„± ê°€ëŠ¥ì„±ì´ ìˆclass MyClass {private:    int value;public:    MyClass(int val) {        value = val;    }};3. ë””í´íŠ¸ ë©¤ë²„ ì´ˆê¸°í™”(Default Member Initializer)  C++11ë¶€í„° í´ë˜ìŠ¤ ì •ì˜ì—ì„œ ë©¤ë²„ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ìˆëŠ” ë””í´íŠ¸ ì´ˆê¸°í™” êµ¬ë¬¸ì´ ë„ì…  ë©¤ë²„ ë³€ìˆ˜ ì„ ì–¸ ì‹œ ì´ˆê¸°ê°’ì„ ì§€ì •í•˜ë©°, ëª¨ë“  ìƒì„±ìì—ì„œ ë™ì¼í•œ ì´ˆê¸°ê°’ì„ ì‚¬ìš©í•˜ë ¤ëŠ” ê²½ìš° ìœ ìš©í•¨  ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ ìš°ì„  ì ìš©ë˜ì§€ë§Œ, ëª…ì‹œì  ì´ˆê¸°í™”ê°€ ìˆìœ¼ë©´ ë®ì–´ì“´ë‹¤.class MyClass {private:    int value = 0;    double rate = 1.5;public:    MyClass() {} // ë³„ë„ ì´ˆê¸°í™” ì—†ì´ ê¸°ë³¸ê°’ ì‚¬ìš©};4. ìœ„ì„ ìƒì„±ì(Delegating Constructor)  C++11ì—ì„œ ì¶”ê°€ëœ ê¸°ëŠ¥ìœ¼ë¡œ, ìƒì„±ìì—ì„œ ë‹¤ë¥¸ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ì—¬ ë©¤ë²„ë¥¼ ì´ˆê¸°í™”  ë¹„ìŠ·í•œ ì´ˆê¸°í™” ë¡œì§ì„ ì—¬ëŸ¬ ìƒì„±ìì—ì„œ ë°˜ë³µí•˜ì§€ ì•Šê³  ê³µìœ í•  ìˆ˜ ìˆë‹¤.  ì½”ë“œ ì¤‘ë³µì„ ì¤„ì´ê³ , ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì„class MyClass {private:    int value;public:    // ê¸°ë³¸ ìƒì„±ì    MyClass() : MyClass(0) {} // ìœ„ì„ ìƒì„±ì ì‚¬ìš©    // íŒŒë¼ë¯¸í„°ë¥¼ ë°›ëŠ” ìƒì„±ì    MyClass(int val) : value(val) {}};L-Value, R-Value, Move Semantics  L-Value: ë©”ëª¨ë¦¬ì— ì¡´ì¬í•˜ë©° ì°¸ì¡°í•  ìˆ˜ ìˆëŠ” ê°’  R-Value: ì„ì‹œì ì¸ ê°’ìœ¼ë¡œ ì°¸ì¡°í•  ìˆ˜ ì—†ëŠ” ê°’  Move semantics: ë³µì‚¬ ëŒ€ì‹  ë¦¬ì†ŒìŠ¤ì˜ ì†Œìœ ê¶Œì„ ì´ë™í•˜ëŠ” ê°œë…          R-Value ì°¸ì¡°(&amp;&amp;): R-Valueë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆëŠ” ì°¸ì¡°ì      std::move: L-Valueë¥¼ R-Value ìºìŠ¤íŒ…í•´ì£¼ëŠ” í•¨ìˆ˜        ì´ë™ ìƒì„±ìì™€ ì´ë™ ëŒ€ì… ì—°ì‚°ìë¥¼ êµ¬í˜„í•˜ì—¬ ì‚¬ìš©    ë³µì‚¬ ëŒ€ì‹  ì†Œìœ ê¶Œì„ ì´ì „í•˜ì—¬ ê¸°ì¡´ ê°ì²´ì˜ ë¦¬ì†ŒìŠ¤ë¥¼ ì¬í™œìš©ì›ë³¸ ê°ì²´ëŠ” ë¹„ì–´ìˆëŠ” ìƒíƒœê°€ ë¨    ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ í•´ì œë¥¼ ì¤„ì—¬ ë³µì‚¬ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê³  íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.    class MyClass {private:    int* data;    int size;public:    MyClass(int s) : size(s), data(new int[s]) { }    // ì´ë™ ìƒì„±ì    MyClass(MyClass&amp;&amp; other) noexcept : size(other.size), data(other.data) {        other.size = 0;        other.data = nullptr;  // ì†Œìœ ê¶Œ ì´ì „    }    // ì´ë™ ëŒ€ì… ì—°ì‚°ì    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept {        if (this != &amp;other) {            delete[] data;  // ê¸°ì¡´ ë¦¬ì†ŒìŠ¤ í•´ì œ            data = other.data;            size = other.size;            other.data = nullptr;            other.size = 0;        }        return *this;    }    ~MyClass() { delete[] data; }  };int main() {    MyClass obj1(10);    MyClass obj2 = std::move(obj1);  // ì´ë™ ìƒì„±ì í˜¸ì¶œ    MyClass obj3(5);    obj3 = std::move(obj2);  // ì´ë™ ëŒ€ì… ì—°ì‚°ì í˜¸ì¶œ    return 0;}      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "OpenGL íŒŒì´í”„ë¼ì¸ ì •ë¦¬",
    "url": "/posts/OpenGL_Pipeline/",
    "categories": "Project, Graphics",
    "tags": "OpenGL",
    "date": "2024-12-28 17:49:24 +0900",
    





    
    "snippet": "# OpenGL Pipeline ì •ë¦¬Pipeline ê³¼ì •1. Application (CPU) - Vertex Specificationì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ë©° API í˜¸ì¶œì„ í†µí•´ Vertex, Color, Texture ì¢Œí‘œ ë“±ì˜ ë°ì´í„°ë¥¼ ì¤€ë¹„í•œë‹¤.ì´í›„ glDrawArrays, glDrawElementsë“±ì˜ API í˜¸ì¶œì„ í†µí•´ ë Œë”ë§ ì‹œì‘2. Vertex...",
    "content": "# OpenGL Pipeline ì •ë¦¬Pipeline ê³¼ì •1. Application (CPU) - Vertex Specificationì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ë©° API í˜¸ì¶œì„ í†µí•´ Vertex, Color, Texture ì¢Œí‘œ ë“±ì˜ ë°ì´í„°ë¥¼ ì¤€ë¹„í•œë‹¤.ì´í›„ glDrawArrays, glDrawElementsë“±ì˜ API í˜¸ì¶œì„ í†µí•´ ë Œë”ë§ ì‹œì‘2. Vertex Shatder (GPU)ì •ì  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ì—¬ í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜í•œë‹¤.ëª¨ë¸, ë·°, íˆ¬ì˜ì— í–‰ë ¬ì„ ì‚¬ìš©í•œ ë³€í™˜ ìˆ˜í–‰1. ë³€í™˜ ì¢…ë¥˜(1) ëª¨ë¸ ì¢Œí‘œ â†’ ì›”ë“œ ì¢Œí‘œ (ëª¨ë¸ ë³€í™˜)  ê°ì²´ì˜ ë¡œì»¬ ì¢Œí‘œ(ëª¨ë¸ ì¢Œí‘œ)ë¥¼ ì›”ë“œ ì¢Œí‘œê³„ë¡œ ë³€í™˜.  ëª¨ë¸ ë³€í™˜ í–‰ë ¬ $M$ ì‚¬ìš©.(2) ì›”ë“œ ì¢Œí‘œ â†’ ë·° ì¢Œí‘œ (ë·° ë³€í™˜)  ì¹´ë©”ë¼(ë˜ëŠ” ê´€ì°°ì)ì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì›”ë“œ ì¢Œí‘œë¥¼ ë³€í™˜.  ë·° ë³€í™˜ í–‰ë ¬ $V$ ì‚¬ìš©.(3) ë·° ì¢Œí‘œ â†’ í´ë¦½ ì¢Œí‘œ (íˆ¬ì˜ ë³€í™˜)  3D ê³µê°„ì„ 2D í™”ë©´ì— íˆ¬ì˜.  ì›ê·¼ë²•(Perspective) ë˜ëŠ” ì§êµ(Orthographic) íˆ¬ì˜ ë°©ì‹ ì‚¬ìš©.  íˆ¬ì˜ ë³€í™˜ í–‰ë ¬ $P$ ì‚¬ìš©.2. í–‰ë ¬ ë³€í™˜(1) ëª¨ë¸-ë·°-íˆ¬ì˜ í–‰ë ¬ (MVP)      ê° ë‹¨ê³„ì—ì„œ ì ìš©ë˜ëŠ” í–‰ë ¬ì„ ê²°í•©í•˜ì—¬ ì „ì²´ ë³€í™˜ì„ í•˜ë‚˜ì˜ í–‰ë ¬ë¡œ í‘œí˜„ ê°€ëŠ¥:\\[\\text{MVP} = P \\cdot V \\cdot M\\]          $M$: ëª¨ë¸ ë³€í™˜ í–‰ë ¬.      $V$: ë·° ë³€í™˜ í–‰ë ¬.      $P$: íˆ¬ì˜ ë³€í™˜ í–‰ë ¬.            ë²„í…ìŠ¤ ì‰ì´ë”ëŠ” ì£¼ë¡œ ì•„ë˜ì™€ ê°™ì´ ë³€í™˜ì„ ìˆ˜í–‰:    gl_Position = projection * view * model * vec4(position, 1.0);      (2) ëª¨ë¸ ë³€í™˜ í–‰ë ¬ê°ì²´ì˜ ê° ì •ì ì— í–‰ë ¬ì„ ê³±í•´ ê°ì²´ì˜ ë¡œì»¬ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜í•  ìˆ˜ ìˆë‹¤.$T(Translation), R(Rotation), S (Scale)$(3) ë·° ë³€í™˜ í–‰ë ¬  ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì›”ë“œ ì¢Œí‘œê³„ë¥¼ ì¹´ë©”ë¼ ì¢Œí‘œê³„(View Space)ë¡œ ë³€í™˜.      OpenGLì—ì„œëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì¹´ë©”ë¼ê°€ ì›ì (0,0,0)ì— ìœ„ì¹˜í•˜ê³ , $-Z$ ë°©í–¥ì„ ë°”ë¼ë³´ëŠ” ê²ƒìœ¼ë¡œ ê°€ì •.        êµ¬ì„± ìš”ì†Œ          ì¹´ë©”ë¼ ìœ„ì¹˜ $\\mathbf{C}$ (Eye Position).      ì¹´ë©”ë¼ ë°©í–¥:                  $\\mathbf{F}$: ì „ë°© ë²¡í„°(Forward).          $\\mathbf{R}$: ì˜¤ë¥¸ìª½ ë²¡í„°(Right).          $\\mathbf{U}$: ìœ„ìª½ ë²¡í„°(Up).                          ë·° í–‰ë ¬ ê³„ì‚°          ì „ë°© ë²¡í„°:    \\[\\mathbf{F} = \\frac{\\mathbf{Target} - \\mathbf{C}}{||\\mathbf{Target} - \\mathbf{C}||}\\]          ì˜¤ë¥¸ìª½ ë²¡í„°:    \\[\\mathbf{R} = \\frac{\\mathbf{F} \\times \\mathbf{Up}}{||\\mathbf{F} \\times \\mathbf{Up}||}\\]          ìƒˆë¡œìš´ ìœ„ìª½ ë²¡í„°:    \\[\\mathbf{U} = \\mathbf{R} \\times \\mathbf{F}\\]          ë·° ë³€í™˜ í–‰ë ¬ $V$:      \\[\\mathbf{V} = \\begin{bmatrix}R_x &amp; R_y &amp; R_z &amp; -\\mathbf{R} \\cdot \\mathbf{C} \\\\U_x &amp; U_y &amp; U_z &amp; -\\mathbf{U} \\cdot \\mathbf{C} \\\\-F_x &amp; -F_y &amp; -F_z &amp; \\mathbf{F} \\cdot \\mathbf{C} \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\]  í–‰ë ¬ì˜ êµ¬ì„±:          ìƒë‹¨ $3 \\times 3$: ì¹´ë©”ë¼ ë°©í–¥ ë³€í™˜.      $-\\mathbf{R} \\cdot \\mathbf{C}, -\\mathbf{U} \\cdot \\mathbf{C}, \\mathbf{F} \\cdot \\mathbf{C}$: ì¹´ë©”ë¼ ìœ„ì¹˜ ë³€í™˜.            GLMì˜ glm::lookAt í•¨ìˆ˜          í•¨ìˆ˜ í”„ë¡œí† íƒ€ì…        glm::mat4 glm::lookAt(    glm::vec3 eye,        // ì¹´ë©”ë¼ì˜ ìœ„ì¹˜    glm::vec3 center,     // ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ëŒ€ìƒ ìœ„ì¹˜    glm::vec3 up          // ì¹´ë©”ë¼ì˜ ì—… ë²¡í„°);      (4) íˆ¬ì˜ ë³€í™˜ í–‰ë ¬  3D ê³µê°„ì„ 2D í™”ë©´ìœ¼ë¡œ íˆ¬ì˜.      íˆ¬ì˜ì€ ì›ê·¼ íˆ¬ì˜(Perspective Projection) ë˜ëŠ” ì§êµ íˆ¬ì˜(Orthographic Projection) ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§.        1. ì›ê·¼ íˆ¬ì˜ (Perspective Projection)          íŠ¹ì§•: ë©€ë¦¬ ìˆëŠ” ê°ì²´ëŠ” ì‘ê²Œ, ê°€ê¹Œìš´ ê°ì²´ëŠ” í¬ê²Œ ë³´ì´ë„ë¡.      êµ¬ì„± ìš”ì†Œ:                  fov: ì‹œì•¼ê°(Field of View).          aspect: í™”ë©´ ë¹„ìœ¨ (ë„ˆë¹„/ë†’ì´).          near, far: ê°€ê¹Œìš´ í‰ë©´ê³¼ ë¨¼ í‰ë©´ì˜ ê±°ë¦¬.                    í–‰ë ¬ í˜•íƒœ:      \\[\\mathbf{P} = \\begin{bmatrix}\\frac{1}{\\tan(\\frac{fov}{2}) \\cdot aspect} &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; \\frac{1}{\\tan(\\frac{fov}{2})} &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; \\frac{-(far + near)}{far - near} &amp; \\frac{-2 \\cdot far \\cdot near}{far - near} \\\\0 &amp; 0 &amp; -1 &amp; 0\\end{bmatrix}\\]      2. ì§êµ íˆ¬ì˜ (Orthographic Projection)          íŠ¹ì§•: ë©€ë¦¬ ìˆëŠ” ê°ì²´ë„ ë™ì¼í•œ í¬ê¸°ë¡œ ë³´ì„.      êµ¬ì„± ìš”ì†Œ:                  l, r: ì™¼ìª½, ì˜¤ë¥¸ìª½ í‰ë©´.          t, b: ìœ„ìª½, ì•„ë˜ìª½ í‰ë©´.          near, far: ê°€ê¹Œìš´ í‰ë©´ê³¼ ë¨¼ í‰ë©´ì˜ ê±°ë¦¬.                    í–‰ë ¬ í˜•íƒœ:      \\[\\mathbf{P}=\\begin{bmatrix}\\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{r+l}{r-l} \\\\0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t-b} \\\\0 &amp; 0 &amp; \\frac{-2}{far-near} &amp; -\\frac{far+near}{far-near} \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\]3. Primitive Assemblyì •ì ë“¤ì„ ê°€ì§€ê³  ì , ì„ , ì‚¼ê°í˜•(Primitive)ë¥¼ ë§Œë“œëŠ” ë‹¨ê³„4. RasterisationPrimitive(ê¸°ë³¸ ë„í˜•: ì , ì„ , ì‚¼ê°í˜• ë“±)ë¥¼ í”½ì…€(fragment)ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •.í´ë¦¬í•‘, ì»¬ë§, ë·°í¬íŠ¸ ë³€í™˜, ë˜ìŠ¤í„°ë¼ì´ì¦ˆë“±ì„ ìˆ˜í–‰í•¨.í´ë¦¬í•‘ (Clipping)Primitive(ì , ì„ , ì‚¼ê°í˜• ë“±)ê°€ í™”ë©´ì— í‘œì‹œë  ìˆ˜ ìˆëŠ” ë²”ìœ„ ì•ˆì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³ , í™”ë©´ ë°–ì˜ ë¶€ë¶„ì„ ì œê±°.  ëª©í‘œ:          í´ë¦½ ê³µê°„(Clip Space)ì—ì„œ í™”ë©´ì— í‘œì‹œë  ì˜ì—­ë§Œ ë‚¨ê¸°ê³ , í‘œì‹œë˜ì§€ ì•Šì„ ë¶€ë¶„ì„ ì œê±°.      í´ë¦½ ê³µê°„ì€ ì •ê·œí™”ëœ ì¢Œí‘œ ì˜ì—­(Normalized Device Coordinates, NDC)ì—ì„œ $[-1, 1]$ ë²”ìœ„ë¡œ ì œí•œ.        ê³¼ì •:          í´ë¦½ ê³µê°„ì—ì„œ ë²—ì–´ë‚œ ì ì€ ì˜ë ¤ë‚˜ê±°ë‚˜ ìƒˆë¡œìš´ ì •ì ìœ¼ë¡œ ë¶„í• .                  ì˜ˆ: ì‚¼ê°í˜•ì´ í´ë¦½ ê²½ê³„ì— ê±¸ì³ ìˆì„ ê²½ìš°, í´ë¦½ ê²½ê³„ì— ë”°ë¼ ìƒˆë¡œìš´ ì‚¼ê°í˜•ìœ¼ë¡œ ë¶„ë¦¬.                    í´ë¦¬í•‘ ì´í›„, ë‚¨ì•„ ìˆëŠ” ë¶€ë¶„ì€ í™”ë©´ì— ê·¸ë ¤ì§ˆ ì¤€ë¹„ë¥¼ í•¨.        ìœ í˜•:          View Frustum Clipping: ì‹œì•¼ ì ˆë‘ì²´(View Frustum) ì˜ì—­ ì•ˆì— ìˆëŠ” ê²ƒë§Œ ë Œë”ë§.      Near/Far Plane Clipping: ì¹´ë©”ë¼ì˜ ê·¼í‰ë©´(near plane)ê³¼ ì›í‰ë©´(far plane)ì—ì„œ ì˜ë¼ëƒ„.      ì»¬ë§ (Culling)ì¹´ë©”ë¼ì—ì„œ ë³´ì´ì§€ ì•ŠëŠ” ë©´(í”„ë¦¬ë¯¸í‹°ë¸Œ)ì„ ì œê±°í•˜ì—¬ ë Œë”ë§ íš¨ìœ¨ì„ ë†’ì´ëŠ” ì‘ì—….  ëª©í‘œ:          ì‚¼ê°í˜•(ë˜ëŠ” ê¸°íƒ€ í”„ë¦¬ë¯¸í‹°ë¸Œ)ì˜ ë’·ë©´(back face) ì„ ì œê±°í•˜ì—¬ ì²˜ë¦¬ëŸ‰ì„ ì¤„ì„.      ì£¼ë¡œ íì‡„í˜• ì˜¤ë¸Œì íŠ¸ì—ì„œ ë‚´ë¶€ ë©´ì„ ì œê±°.        ë°©ì‹:          ì»¬ë§ì€ ì‚¼ê°í˜•ì˜ ë²•ì„  ë°©í–¥(normal vector) ê³¼ ì¹´ë©”ë¼ ë°©í–¥ì„ ë¹„êµí•˜ì—¬ ìˆ˜í–‰.      ì‹œê³„ ë°©í–¥(CW, Clockwise) ë˜ëŠ” ë°˜ì‹œê³„ ë°©í–¥(CCW, Counter-clockwise) ìœ¼ë¡œ ì •ì˜ëœ ì‚¼ê°í˜•ì˜ ì •ì  ìˆœì„œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë©´ì´ ì•ë©´ì¸ì§€ ë’·ë©´ì¸ì§€ íŒë‹¨.        ìœ í˜•:          Back-face Culling: ì¹´ë©”ë¼ì—ì„œ ë³´ì´ì§€ ì•ŠëŠ” ë©´(ë’·ë©´)ì„ ì œê±°.      Front-face Culling: í•„ìš” ì‹œ ì•ë©´ì„ ì œê±°.      Frustum Culling: ì‹œì•¼ ì ˆë‘ì²´(Frustum) ë°–ì˜ ê°ì²´ë¥¼ ì œê±°.        ì¥ì :          ë¶ˆí•„ìš”í•œ ë©´ ì œê±°ë¡œ GPU ì—°ì‚°ëŸ‰ ê°ì†Œ.      ë Œë”ë§ ìµœì í™”.      ë·°í¬íŠ¸ ë³€í™˜ (Viewport Transformation)ì •ê·œí™”ëœ ì¥ì¹˜ ì¢Œí‘œ(NDC, Normalized Device Coordinates)ë¥¼ ìŠ¤í¬ë¦° ì¢Œí‘œ(Screen Coordinates)ë¡œ ë³€í™˜í•˜ëŠ” ì‘ì—…ì…ë‹ˆë‹¤.  ëª©í‘œ:          í´ë¦½ ê³µê°„ì—ì„œ ì •ê·œí™”ëœ ì¢Œí‘œ($[-1, 1]$)ë¥¼ ì‹¤ì œ í™”ë©´ì—ì„œ í”½ì…€ ìœ„ì¹˜ë¡œ ë³€í™˜.      ë Œë”ë§í•  ë·°í¬íŠ¸ ì˜ì—­ì— ë§ê²Œ ì¡°ì •.            ê³¼ì •:\\[x_{\\text{screen}} = \\frac{x_{\\text{ndc} } + 1}{2} \\cdot w_{\\text{viewport}} + x_{\\text{origin}}\\]\\[y_{\\text{screen}} = \\frac{y_{\\text{ndc} } + 1}{2} \\cdot h_{\\text{viewport}} + y_{\\text{origin}}\\]          $x_{\\text{ndc} }, y_{\\text{ndc} }$: NDC ì¢Œí‘œ.      $w_{\\text{viewport}}, h_{\\text{viewport}}$: ë·°í¬íŠ¸ì˜ ë„ˆë¹„ì™€ ë†’ì´.      $x_{\\text{origin}}, y_{\\text{origin}}$: ë·°í¬íŠ¸ì˜ ì‹œì‘ ì¢Œí‘œ.        íŠ¹ì§•:          í™”ë©´ì—ì„œ íŠ¹ì • ì˜ì—­ë§Œ ë Œë”ë§í•  ìˆ˜ë„ ìˆìŒ (ì˜ˆ: Split Screen, Render Target).      OpenGL:                  glViewport(x, y, width, height)ë¥¼ í†µí•´ ë·°í¬íŠ¸ ì„¤ì •.                    5. Fragment Shaderê° í”½ì…€(Fragment)ì— ëŒ€í•´ ìƒ‰ìƒì„ ê³„ì‚°í•œë‹¤.ì¡°ëª… ê³„ì‚°, íƒìŠ¤ì³ ë§¤í•‘ë“±ì„ ìˆ˜í–‰í•œë‹¤.6. Frame BufferFragment Shader ì¶œë ¥ì´ í™”ë©´ì˜ í”½ì…€ì— í‘œì‹œëœë‹¤.ê¹Šì´ í…ŒìŠ¤íŠ¸, ìŠ¤í…ì‹¤ í…ŒìŠ¤íŠ¸ë“±ì„ í†µí•´ ì‚¬ìš©í•  Fragmentë¥¼ ì •í•˜ê³ ,ë¸”ë Œë”©, ë””ë”ë§, ìƒ˜í”Œë§ì„ í†µí•´ ìƒ‰ìƒì„ ìì—°ìŠ¤ëŸ½ê²Œ ë Œë”ë§í•œë‹¤.CPU ì½”ë“œì™€ ì‰ì´ë” ì½”ë“œì˜ ê´€ê³„1. CPU ì½”ë“œì˜ ì—­í• CPU ì½”ë“œ(ì• í”Œë¦¬ì¼€ì´ì…˜) OpenGL íŒŒì´í”„ë¼ì¸ì„ ì œì–´í•˜ê³  ë°ì´í„°ë¥¼ ì¤€ë¹„í•œë‹¤.  ì‰ì´ë” í”„ë¡œê·¸ë¨ ê´€ë¦¬:          ì‰ì´ë” ì†ŒìŠ¤ ì½”ë“œ ì½ê¸°(ë³´í†µ .vertì™€ .frag íŒŒì¼).      ì‰ì´ë” ì»´íŒŒì¼ ë° ë§í¬.      ì‰ì´ë” ë³€ìˆ˜ì— ë°ì´í„° ì „ë‹¬(ìœ ë‹ˆí¼, ì†ì„± ë“±).        ë²„í¼ì™€ VAO/VBO ì„¤ì •:          ì •ì  ë°ì´í„°ë¥¼ GPU ë©”ëª¨ë¦¬ì— ì—…ë¡œë“œ.      ë Œë”ë§ ëŒ€ìƒ ì •ì˜.        ë Œë”ë§ ëª…ë ¹ ì „ë‹¬:          ë“œë¡œìš° í˜¸ì¶œë¡œ GPUì— ë Œë”ë§ ëª…ë ¹ ì‹¤í–‰.      2. ì‰ì´ë” ì½”ë“œ (Vertex &amp; Fragment)  Vertex Shader (.vert íŒŒì¼):          ê° ì •ì ì— ëŒ€í•´ ì²˜ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰.      ëª¨ë¸ ë³€í™˜, ë·° ë³€í™˜, íˆ¬ì˜ ë³€í™˜.        Fragment Shader (.frag íŒŒì¼):          ê° í”„ë˜ê·¸ë¨¼íŠ¸ì— ëŒ€í•´ ì²˜ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰.      ìƒ‰ìƒ, ì¡°ëª…, í…ìŠ¤ì²˜ ë§¤í•‘ì„ ê³„ì‚°.      3. ë°ì´í„° ì „ë‹¬CPUì™€ ì‰ì´ë” ì½”ë“œ ê°„ ë°ì´í„° ì „ë‹¬ì€ ë‹¤ìŒ ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤:  ìœ ë‹ˆí¼(Uniform): ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‰ì´ë”ë¡œ ê¸€ë¡œë²Œ ë°ì´í„° ì „ë‹¬ (ì˜ˆ: ë³€í™˜ í–‰ë ¬, ì¡°ëª… ë°ì´í„°).  ì†ì„±(Attribute): ê° ì •ì ì— ëŒ€í•´ ë³„ë„ì˜ ë°ì´í„° ì „ë‹¬ (ì˜ˆ: ìœ„ì¹˜, í…ìŠ¤ì²˜ ì¢Œí‘œ).  VBO(Vertex Buffer Object): ì •ì  ë°ì´í„°ë¥¼ GPU ë©”ëª¨ë¦¬ì— ì €ì¥.  í…ìŠ¤ì²˜: ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ GPUì— ì—…ë¡œë“œí•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ ì‰ì´ë”ì—ì„œ ì ‘ê·¼.ì°¸ê³ ìë£Œopengl-graphics-pipeline[OpenGL ESë¥¼ ì´ìš©í•œ 3ì°¨ì› ì»´í“¨í„° ê·¸ë˜í”½ìŠ¤ ì…ë¬¸] ì±•í„° 7 - ë˜ìŠ¤í„°ë¼ì´ì €[OpenGLë¡œ ë°°ìš°ëŠ” ì»´í“¨í„° ê·¸ë˜í”½ìŠ¤] Chapter 07. íˆ¬ìƒë³€í™˜ê³¼ ë·°í¬íŠ¸ë³€í™˜ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "OpenGL API ì •ë¦¬",
    "url": "/posts/OpenGL_API/",
    "categories": "Project, Graphics",
    "tags": "OpenGL",
    "date": "2024-12-28 17:49:24 +0900",
    





    
    "snippet": "OpenGL APIOpenGL íŒŒì´í”„ë¼ì¸ì˜ ê° ë‹¨ê³„ì—ì„œ ë°ì´í„°ë¥¼ ì„¤ì •í•˜ê±°ë‚˜ ë Œë”ë§ì„ ì œì–´í•˜ëŠ” ì—­í• ì„ í•˜ëŠ” API ì •ë¦¬1. ë°ì´í„° ê´€ë¦¬ ë° ì„¤ì • ê´€ë ¨ APIglGenBuffers  ì—­í• : í•˜ë‚˜ ì´ìƒì˜ ë²„í¼ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  ê³ ìœ í•œ IDë¥¼ í• ë‹¹.      ì‚¬ìš© ì˜ˆ:    glGenBuffers(1, &amp;vertex_buffer);            ...",
    "content": "OpenGL APIOpenGL íŒŒì´í”„ë¼ì¸ì˜ ê° ë‹¨ê³„ì—ì„œ ë°ì´í„°ë¥¼ ì„¤ì •í•˜ê±°ë‚˜ ë Œë”ë§ì„ ì œì–´í•˜ëŠ” ì—­í• ì„ í•˜ëŠ” API ì •ë¦¬1. ë°ì´í„° ê´€ë¦¬ ë° ì„¤ì • ê´€ë ¨ APIglGenBuffers  ì—­í• : í•˜ë‚˜ ì´ìƒì˜ ë²„í¼ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  ê³ ìœ í•œ IDë¥¼ í• ë‹¹.      ì‚¬ìš© ì˜ˆ:    glGenBuffers(1, &amp;vertex_buffer);              ìƒˆë¡œìš´ ë²„í¼ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  vertex_bufferì— IDë¥¼ ì €ì¥.      glBindBuffer      í•¨ìˆ˜ ì •ì˜      void glBindBuffer(GLenum target, GLuint buffer);              target: ë²„í¼ ê°ì²´ê°€ ì–´ë–¤ ìš©ë„ë¡œ ì‚¬ìš©ë ì§€ ì§€ì •í•˜ëŠ” ë²„í¼ íƒ€ì….      buffer: ë°”ì¸ë”©í•  ë²„í¼ ê°ì²´ì˜ ID. (glGenBuffersë¡œ ìƒì„±ëœ ID).        ì—­í• : ìƒì„±ëœ ë²„í¼ ê°ì²´ë¥¼ íŠ¹ì • ë²„í¼ íƒ€ì…(GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER ë“±)ê³¼ ë°”ì¸ë”©.      ì‚¬ìš© ì˜ˆ:    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);              vertex_bufferë¥¼ í˜„ì¬ í™œì„±í™”ëœ GL_ARRAY_BUFFERë¡œ ì„¤ì •.        ì£¼ìš” ë²„í¼ íƒ€ì… (target)          GL_ARRAY_BUFFER                  ì—­í• : ì •ì  ë°ì´í„°(Vertex Data)ë¥¼ ì €ì¥.          ì‚¬ìš© ë°ì´í„°:                          ì •ì  ìœ„ì¹˜(Position), ìƒ‰ìƒ(Color), í…ìŠ¤ì²˜ ì¢Œí‘œ(Texture Coordinates), ë²•ì„  ë²¡í„°(Normal) ë“±.                                ì ìš© ëŒ€ìƒ:                          ë²„í…ìŠ¤ ì…°ì´ë”ì—ì„œ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë°ì´í„°.                                          GL_ELEMENT_ARRAY_BUFFER                  ì—­í• : ì¸ë±ìŠ¤ ë°ì´í„°(Index Data)ë¥¼ ì €ì¥.          ì‚¬ìš© ë°ì´í„°:                          ì‚¼ê°í˜•ì˜ ì •ì  ì¸ë±ìŠ¤ ë°°ì—´.              ì •ì  ë°ì´í„°ë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ì ˆì•½ ë° ë Œë”ë§ íš¨ìœ¨ì„± í–¥ìƒ.                                ì ìš© ëŒ€ìƒ:                          glDrawElements ë° glDrawElementsInstanced í˜¸ì¶œì—ì„œ ì‚¬ìš©.                                          GL_UNIFORM_BUFFER                  ì—­í• : ìœ ë‹ˆí¼ ë°ì´í„°(Uniform Data)ë¥¼ ì €ì¥.          ì‚¬ìš© ë°ì´í„°:                          ì—¬ëŸ¬ ì…°ì´ë”ì—ì„œ ê³µìœ í•˜ëŠ” ì „ì—­ ë°ì´í„°(ì˜ˆ: ë³€í™˜ í–‰ë ¬, ì¡°ëª… ë°ì´í„° ë“±).                                ì ìš© ëŒ€ìƒ:                          ìœ ë‹ˆí¼ ë¸”ë¡(Uniform Block) ìœ¼ë¡œ ì„ ì–¸ëœ ë°ì´í„°ë¥¼ ì „ë‹¬.                                          (4) GL_TEXTURE_BUFFER                  ì—­í• : í…ìŠ¤ì²˜ ë°ì´í„°(Texture Data)ë¥¼ ì €ì¥.          ì‚¬ìš© ë°ì´í„°:                          í…ìŠ¤ì²˜ë¡œ ì‚¬ìš©ë  1D ë°°ì—´ ë°ì´í„°ë¥¼ ì €ì¥.                                ì ìš© ëŒ€ìƒ:                          í…ìŠ¤ì²˜ ë²„í¼ë¥¼ ì‚¬ìš©í•  ë•Œ.                                          glBufferData  ì—­í• : ë°”ì¸ë”©ëœ ë²„í¼ ê°ì²´ì— ë°ì´í„°ë¥¼ ì—…ë¡œë“œ.      ì‚¬ìš© ì˜ˆ:    glBufferData(GL_ARRAY_BUFFER, sizeof(vertex) * vertex_list.size(), &amp;vertex_list[0], GL_STATIC_DRAW);              vertex_listì˜ ë°ì´í„°ë¥¼ GPUë¡œ ë³µì‚¬.      GL_STATIC_DRAW: ë°ì´í„°ê°€ ìì£¼ ë³€ê²½ë˜ì§€ ì•ŠìŒì„ ëª…ì‹œ.      glGetAttribLocation  ì—­í• : ì…°ì´ë” í”„ë¡œê·¸ë¨ì—ì„œ íŠ¹ì • ì†ì„±(attribute)ì˜ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜´.      ì‚¬ìš© ì˜ˆ:    GLuint loc = glGetAttribLocation(program, \"position\");              ì…°ì´ë” í”„ë¡œê·¸ë¨(program)ì—ì„œ \"position\" ì†ì„±ì˜ ìœ„ì¹˜ë¥¼ ë°˜í™˜.      glEnableVertexAttribArray  ì—­í• : íŠ¹ì • ì†ì„±ì„ í™œì„±í™”í•˜ì—¬ GPUê°€ ë°ì´í„°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •.      ì‚¬ìš© ì˜ˆ:    glEnableVertexAttribArray(loc);              ì†ì„±(loc)ì„ í™œì„±í™”.      glVertexAttribPointer  ì—­í• : ì…°ì´ë” ì†ì„±ì— ë°ì´í„°ì˜ ë ˆì´ì•„ì›ƒ(êµ¬ì¡°)ì„ ì •ì˜.      ì‚¬ìš© ì˜ˆ:    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, sizeof(vertex), (GLvoid*)0);              ì…°ì´ë” ì†ì„± locì— ëŒ€í•´:                  3: ë°ì´í„° ê°œìˆ˜(ì˜ˆ: vec3).          GL_FLOAT: ë°ì´í„° íƒ€ì….          GL_FALSE: ì •ê·œí™” ì—¬ë¶€.          sizeof(vertex): ì •ì  ë°ì´í„°ì˜ í¬ê¸°(Stride).          (GLvoid*)0: ë°ì´í„°ì˜ ì‹œì‘ ìœ„ì¹˜(Offset).                    glGetUniformLocation  ì—­í• : ì…°ì´ë” í”„ë¡œê·¸ë¨ì—ì„œ íŠ¹ì • ìœ ë‹ˆí¼ ë³€ìˆ˜ì˜ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜´.      ì‚¬ìš© ì˜ˆ:    GLint uloc = glGetUniformLocation(program, \"radius\");              \"radius\" ìœ ë‹ˆí¼ ë³€ìˆ˜ì˜ ìœ„ì¹˜ë¥¼ ë°˜í™˜.      glUniform*  ì—­í• : íŠ¹ì • ìœ ë‹ˆí¼ ë³€ìˆ˜ì— ê°’ì„ ì„¤ì •.      ì‚¬ìš© ì˜ˆ:    glUniform1fv(uloc, NUM_CIRCLES, radius);              uloc ìœ„ì¹˜ì— radius ë°ì´í„°ë¥¼ ì „ë‹¬.      2. ì…°ì´ë” ê´€ë ¨ APIglCreateProgram  ì—­í• : ìƒˆë¡œìš´ ì…°ì´ë” í”„ë¡œê·¸ë¨ ê°ì²´ë¥¼ ìƒì„±.      ì‚¬ìš© ì˜ˆ:    GLuint program = glCreateProgram();              ì…°ì´ë” í”„ë¡œê·¸ë¨ IDë¥¼ ìƒì„±.      glUseProgram  ì—­í• : íŠ¹ì • ì…°ì´ë” í”„ë¡œê·¸ë¨ì„ í™œì„±í™”.      ì‚¬ìš© ì˜ˆ:    glUseProgram(program);              í˜„ì¬ ë Œë”ë§ì— ì‚¬ìš©í•  ì…°ì´ë” í”„ë¡œê·¸ë¨ì„ ì„¤ì •.      3. ë Œë”ë§ ê´€ë ¨ APIglClear  ì—­í• : ì»¬ëŸ¬ ë²„í¼, ê¹Šì´ ë²„í¼ ë“±ì„ ì´ˆê¸°í™”.      ì‚¬ìš© ì˜ˆ:    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);              ì»¬ëŸ¬ ë²„í¼ì™€ ê¹Šì´ ë²„í¼ë¥¼ ì´ˆê¸°í™”.      glDrawElementsInstanced  ì—­í• : ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹¤ìˆ˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë Œë”ë§.      ì‚¬ìš© ì˜ˆ:    glDrawElementsInstanced(GL_TRIANGLES, index_list.size(), GL_UNSIGNED_INT, nullptr, 21);              GL_TRIANGLES: ì‚¼ê°í˜• ë Œë”ë§.      index_list.size(): ì¸ë±ìŠ¤ ë°ì´í„° ê°œìˆ˜.      GL_UNSIGNED_INT: ì¸ë±ìŠ¤ ë°ì´í„° íƒ€ì….      21: ì¸ìŠ¤í„´ìŠ¤ì˜ ê°œìˆ˜.      glDrawArrays  ì—­í• : ì •ì  ë°ì´í„°ë¥¼ ìˆœì„œëŒ€ë¡œ ì½ì–´ì™€ ë Œë”ë§.      ì‚¬ìš© ì˜ˆ:    glDrawArrays(GL_TRIANGLES, 0, NUM_TESS * 3);              GL_TRIANGLES: ì‚¼ê°í˜• ë Œë”ë§.      0: ì²« ë²ˆì§¸ ì •ì ë¶€í„° ì‹œì‘.      NUM_TESS * 3: ì •ì  ê°œìˆ˜.      glfwSwapBuffers  ì—­í• : ë”ë¸” ë²„í¼ë§ ë°©ì‹ì—ì„œ í˜„ì¬ ë Œë”ë§ëœ ë²„í¼ë¥¼ í™”ë©´ì— ì¶œë ¥.      ì‚¬ìš© ì˜ˆ:    glfwSwapBuffers(window);      4. ìœˆë„ìš° ë° ì´ë²¤íŠ¸ ê´€ë ¨ APIglfwSetWindowSizeCallback  ì—­í• : ìœˆë„ìš° í¬ê¸° ë³€ê²½ ì‹œ í˜¸ì¶œë˜ëŠ” ì½œë°± í•¨ìˆ˜ë¥¼ ì„¤ì •.      ì‚¬ìš© ì˜ˆ:    glfwSetWindowSizeCallback(window, reshape);      glfwPollEvents  ì—­í• : ì´ë²¤íŠ¸ íì—ì„œ ëŒ€ê¸° ì¤‘ì¸ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬.      ì‚¬ìš© ì˜ˆ:    glfwPollEvents();      ìš”ì•½            API      ì—­í•       ê´€ë ¨ ì‘ì—…                  glGenBuffers / glBindBuffer      ë²„í¼ ìƒì„± ë° ë°”ì¸ë”©      GPU ë©”ëª¨ë¦¬ ê´€ë¦¬              glBufferData      ë²„í¼ì— ë°ì´í„° ì—…ë¡œë“œ      ì •ì , ì¸ë±ìŠ¤ ë°ì´í„° ì „ì†¡              glGetAttribLocation      ì…°ì´ë” ì†ì„± ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°      ì†ì„± ë°”ì¸ë”©              glEnableVertexAttribArray      ì†ì„± í™œì„±í™”      ì†ì„± ì‚¬ìš© ì„¤ì •              glVertexAttribPointer      ì†ì„±ê³¼ ë°ì´í„° ì—°ê²°      ì…°ì´ë” ë°ì´í„° ë§¤í•‘              glGetUniformLocation      ìœ ë‹ˆí¼ ë³€ìˆ˜ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°      ì…°ì´ë” ë³€ìˆ˜ ì„¤ì •              glUniform*      ìœ ë‹ˆí¼ ê°’ ì „ë‹¬      ê°’ ì„¤ì •              glDrawElementsInstanced      ì¸ìŠ¤í„´ìŠ¤ ë Œë”ë§      ë‹¤ì¤‘ ê°ì²´ ë Œë”ë§              glDrawArrays      ì •ì  ìˆœì°¨ ë Œë”ë§      ë‹¨ì¼ ê°ì²´ ë Œë”ë§              glClear      í™”ë©´ ì´ˆê¸°í™”      í™”ë©´ ì¤€ë¹„              glfwSwapBuffers      ë Œë”ë§ëœ í™”ë©´ ì¶œë ¥      ë”ë¸” ë²„í¼ë§      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "OpenGL ë°ì´í„° ì²˜ë¦¬ ê³¼ì •",
    "url": "/posts/OpenGL_Flow/",
    "categories": "Project, Graphics",
    "tags": "Math, Elastic_Collision",
    "date": "2024-12-25 20:06:20 +0900",
    





    
    "snippet": "# OpenGL íŒŒì´í”„ë¼ì¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë°ì´í„° ì´ë™ê³¼ ì²˜ë¦¬ íë¦„ ì •ë¦¬1. CPU ë°ì´í„° ì¤€ë¹„(1) ì •ì  ë° ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° ì´ˆê¸°í™”  CPU ì½”ë“œì—ì„œ ì •ì (Vertex) ë°ì´í„°ì™€ ì›ì˜ ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„°(ìœ„ì¹˜, ë°˜ì§€ë¦„, ìƒ‰ìƒ ë“±)ë¥¼ ì¤€ë¹„.          update_circle_vertices(NUM_TESS):                  ì›ì˜ ê¼­ì§“...",
    "content": "# OpenGL íŒŒì´í”„ë¼ì¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë°ì´í„° ì´ë™ê³¼ ì²˜ë¦¬ íë¦„ ì •ë¦¬1. CPU ë°ì´í„° ì¤€ë¹„(1) ì •ì  ë° ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° ì´ˆê¸°í™”  CPU ì½”ë“œì—ì„œ ì •ì (Vertex) ë°ì´í„°ì™€ ì›ì˜ ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„°(ìœ„ì¹˜, ë°˜ì§€ë¦„, ìƒ‰ìƒ ë“±)ë¥¼ ì¤€ë¹„.          update_circle_vertices(NUM_TESS):                  ì›ì˜ ê¼­ì§“ì  ë°ì´í„°ë¥¼ ê³„ì‚°í•˜ì—¬ vertex_listì— ì €ì¥          ì •ì  ë°ì´í„°ëŠ” ì›ì  (0, 0)ì—ì„œ ì‹œì‘í•˜ì—¬ NUM_TESSê°œì˜ ì‚¼ê°í˜•ìœ¼ë¡œ ì›ì„ ì •ì˜í•œë‹¤.                    update_vertex_buffer(NUM_TESS):                  GPU ë©”ëª¨ë¦¬ì— ì •ì  ë²„í¼ì™€ ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ìƒì„± ë° ì—…ë¡œë“œ.                    void update_circle_vertices(uint N) {        vertex_list.clear();        vertex_list.push_back({ vec3(0,0,0), vec3(0.0f,0.0f,-1.0f), vec2(0.5f) });        for (uint k = 0; k &lt;= N; k++) {            float t = PI * 2.0f / float(N) * float(k);            float c = cos(t), s = sin(t);            vertex_list.push_back({ vec3(c,s,0.0f) , vec3(0.0f,0.0f,-1.0f), vec2(c * 0.5f + 0.5f,s * 0.5f + 0.5f) });        }    }    void update_vertex_buffer(uint N) {        // ... buffer clear        for (uint k = 0; k &lt; N; k++) {            index_list.push_back(0);            index_list.push_back(k + 1);            index_list.push_back(k + 2);        }        // ... buffer upload    }                update_circle_verticesì—ì„œ í•œ ì ì„ ì›ì ì„ ê¸°ì¤€ìœ¼ë¡œ ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ íšŒì „ì‹œì¼œ vertexë¥¼ ë§Œë“¤ê³ update_vertex_bufferì—ì„œ ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ë³€ í•˜ë‚˜ì”©ì„ ê³µìœ í•˜ëŠ” ì‚¼ê°í˜•ì„ ë§Œë“¤ë„ë¡ indexë¥¼ êµ¬ì„±í•œë‹¤.            (2) ë²„í¼ ë°ì´í„° ì—…ë¡œë“œ  ì •ì  ë°ì´í„° (vertex_list)ëŠ” glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);ë¥¼ í†µí•´ GPUì— ì—…ë¡œë“œ.  ì¸ë±ìŠ¤ ë°ì´í„° (index_list)ëŠ” glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);ë¥¼ í†µí•´ GPUì— ì—…ë¡œë“œ.(3) ìœ ë‹ˆí¼ ë°ì´í„° ì„¤ì •  CPUì—ì„œ ì›ì˜ ì†ì„± ë°ì´í„°ë¥¼ ì‰ì´ë”ì— ì „ë‹¬.          glUniform* í•¨ìˆ˜ë¡œ radius, offset, solid_color ë“± ë°ì´í„°ë¥¼ ì‰ì´ë”ì˜ ìœ ë‹ˆí¼ ë³€ìˆ˜ì— ì„¤ì •í•œë‹¤.      2. ë²„í…ìŠ¤ ì‰ì´ë” ë‹¨ê³„ (circ.vert)ë²„í…ìŠ¤ ì‰ì´ë”ëŠ” ì •ì  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ë©°, ì—¬ê¸°ì„œëŠ” ì¸ìŠ¤í„´ìŠ¤í™”ë¥¼ í†µí•´ ê° ì›ì„ ê°œë³„ì ìœ¼ë¡œ ì„¤ì •í•œë‹¤.(1) ì…ë ¥ ë°ì´í„°  ì •ì  ì†ì„±: position, normal, texcoord (ì •ì ì˜ ìœ„ì¹˜, ë²•ì„  ë²¡í„°, í…ìŠ¤ì²˜ ì¢Œí‘œ).  ìœ ë‹ˆí¼:          radius[21]: ê° ì›ì˜ ë°˜ì§€ë¦„.      offset[21]: ê° ì›ì˜ ì¤‘ì‹¬ ìœ„ì¹˜.      aspect_ratio: í™”ë©´ì˜ ì¢…íš¡ë¹„.        ë‚´ì¥ ë³€ìˆ˜: gl_InstanceID (í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ì¸ìŠ¤í„´ìŠ¤ ID).(2) ì²˜ë¦¬ ë‚´ìš©  ê° ì •ì ì„ í•´ë‹¹ ì›ì˜ ë°˜ì§€ë¦„(radius[gl_InstanceID])ìœ¼ë¡œ ìŠ¤ì¼€ì¼ë§ (Scale).  íšŒì „(Rotate)ì€ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ìƒëµ  ê° ì •ì ì˜ ìœ„ì¹˜ë¥¼ í•´ë‹¹ ì›ì˜ ì¤‘ì‹¬ ìœ„ì¹˜(offset[gl_InstanceID])ë¡œ ì´ë™ (Translate).  í™”ë©´ì˜ ì¢…íš¡ë¹„(aspect_ratio)ë¥¼ ê³ ë ¤í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •.(3) ì¶œë ¥ ë°ì´í„°  gl_Position: ìµœì¢… ë³€í™˜ëœ ì •ì ì˜ í´ë¦½ ê³µê°„ ì¢Œí‘œ.  norm, tc: ë²•ì„  ë²¡í„°ì™€ í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ í”„ë˜ê·¸ë¨¼íŠ¸ ì‰ì´ë”ë¡œ ì „ë‹¬.3. ë˜ìŠ¤í„°í™” ë° í”„ë˜ê·¸ë¨¼íŠ¸ ì‰ì´ë” ë‹¨ê³„ (circ.frag)ë˜ìŠ¤í„°í™” ë‹¨ê³„ì—ì„œ ì‚¼ê°í˜• í”„ë¦¬ë¯¸í‹°ë¸Œê°€ í”½ì…€(fragment)ë¡œ ë³€í™˜ë˜ë©°, ê° í”½ì…€ì€ í”„ë˜ê·¸ë¨¼íŠ¸ ì‰ì´ë”ì—ì„œ ì²˜ë¦¬ëœë‹¤.(1) ì…ë ¥ ë°ì´í„°  ì¸í„°í´ë ˆì´ì…˜ëœ ë°ì´í„°:          tc: í…ìŠ¤ì²˜ ì¢Œí‘œ (ê° í”½ì…€ì˜ ìƒëŒ€ ìœ„ì¹˜).      instanceID: ì²˜ë¦¬ ì¤‘ì¸ ì¸ìŠ¤í„´ìŠ¤ ID (flat, ë³€í•˜ì§€ ì•ŠìŒ).        ìœ ë‹ˆí¼ ë°ì´í„°:          bUseSolidColor: ë‹¨ìƒ‰ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ëŠ” í”Œë˜ê·¸.      solid_color[21]: ê° ì›ì˜ ìƒ‰ìƒ.      (2) ì²˜ë¦¬ ë‚´ìš©  bUseSolidColorê°€ trueì¼ ê²½ìš°:          í”½ì…€ ìƒ‰ìƒì„ solid_color[instanceID]ì—ì„œ ê°€ì ¸ì˜´.        bUseSolidColorê°€ falseì¼ ê²½ìš°:          í”½ì…€ ìƒ‰ìƒì„ í…ìŠ¤ì²˜ ì¢Œí‘œ tcë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì„¤ì •.      (3) ì¶œë ¥ ë°ì´í„°  fragColor: ìµœì¢… í”½ì…€ ìƒ‰ìƒ. í™”ë©´ì— í‘œì‹œë  ê²°ê³¼ê°’.4. í”„ë ˆì„ ë²„í¼ ë° ë Œë”ë§  glfwSwapBuffersë¥¼ í†µí•´ í˜„ì¬ í”„ë ˆì„ì„ í™”ë©´ì— ì¶œë ¥í•¨.ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ì™„ì „ íƒ„ì„± ì¶©ëŒ ìˆ˜ì‹",
    "url": "/posts/Elastic_Collision/",
    "categories": "Project, Graphics",
    "tags": "Math, Elastic_Collision",
    "date": "2024-12-25 19:59:52 +0900",
    





    
    "snippet": "# ì™„ì „ íƒ„ì„± ì¶©ëŒ êµ¬í˜„ì™„ì „ íƒ„ì„± ì¶©ëŒì—ì„œ ë‘ ë¬¼ì²´ì˜ ì†ë„ ë³€í™” ìœ ë„ì™„ì „ íƒ„ì„± ì¶©ëŒ(elastic collision)ì€ ìš´ë™ëŸ‰ê³¼ ìš´ë™ì—ë„ˆì§€ê°€ ëª¨ë‘ ë³´ì¡´ëœë‹¤.ë‹¤ìŒì€ ë‘ ë¬¼ì²´ì˜ ì¶©ëŒ ì „í›„ ì†ë„ë¥¼ ìœ ë„í•˜ëŠ” ê³¼ì •ì´ë‹¤.1. ìš´ë™ëŸ‰ ë³´ì¡´ë²•ì¹™ë‘ ë¬¼ì²´ì˜ ì§ˆëŸ‰ì„ ê°ê° $m_1$, $m_2$ë¼ê³  í•˜ê³ , ì¶©ëŒ ì „ ì†ë„ë¥¼ $v_1$, $v_2$, ì¶©ëŒ í›„ ì†ë„ë¥¼ $V_1$...",
    "content": "# ì™„ì „ íƒ„ì„± ì¶©ëŒ êµ¬í˜„ì™„ì „ íƒ„ì„± ì¶©ëŒì—ì„œ ë‘ ë¬¼ì²´ì˜ ì†ë„ ë³€í™” ìœ ë„ì™„ì „ íƒ„ì„± ì¶©ëŒ(elastic collision)ì€ ìš´ë™ëŸ‰ê³¼ ìš´ë™ì—ë„ˆì§€ê°€ ëª¨ë‘ ë³´ì¡´ëœë‹¤.ë‹¤ìŒì€ ë‘ ë¬¼ì²´ì˜ ì¶©ëŒ ì „í›„ ì†ë„ë¥¼ ìœ ë„í•˜ëŠ” ê³¼ì •ì´ë‹¤.1. ìš´ë™ëŸ‰ ë³´ì¡´ë²•ì¹™ë‘ ë¬¼ì²´ì˜ ì§ˆëŸ‰ì„ ê°ê° $m_1$, $m_2$ë¼ê³  í•˜ê³ , ì¶©ëŒ ì „ ì†ë„ë¥¼ $v_1$, $v_2$, ì¶©ëŒ í›„ ì†ë„ë¥¼ $V_1$, $V_2$ë¼ê³  í•  ë•Œ, ìš´ë™ëŸ‰ ë³´ì¡´ë²•ì¹™ì€ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ëœë‹¤:\\[(1) \\quad m_1 v_1 + m_2 v_2 = m_1 V_1 + m_2 V_2\\]2. ìš´ë™ì—ë„ˆì§€ ë³´ì¡´ë²•ì¹™\\[\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 V_1^2 + \\frac{1}{2} m_2 V_2^2\\]ì •ë¦¬í•˜ë©´:\\[(2) \\quad m_1 v_1^2 + m_2 v_2^2 = m_1 V_1^2 + m_2 V_2^2\\]3. ìƒëŒ€ì†ë„ ê´€ê³„ì™„ì „ íƒ„ì„± ì¶©ëŒì—ì„œ ë‘ ë¬¼ì²´ì˜ ìƒëŒ€ì†ë„ëŠ” ì¶©ëŒ ì „ í›„ì— ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë™ì¼í•˜ë‹¤:\\[(3) \\quad v_1 - v_2 = -(V_1 - V_2)\\]ì´ëŠ” (1)ê³¼ (2)ë¡œë¶€í„° ìœ ë„ ê°€ëŠ¥í•˜ë‹¤.4. ì†ë„ ê³„ì‚° ìœ ë„ì‹ (3)ì„ ì •ë¦¬í•˜ë©´:\\[V_1 = V_2 + v_2 - v_1\\]ì´ë¥¼ ì‹ (1)ì— ëŒ€ì…í•˜ë©´:\\[m_1 v_1 + m_2 v_2 = m_1 (V_2 + v_2 - v_1) + m_2 V_2\\]ì •ë¦¬í•˜ë©´:\\[m_1 v_1 + m_2 v_2 = m_1 V_2 + m_1 v_2 - m_1 v_1 + m_2 V_2\\]\\[m_1 v_1 + m_2 v_2 + m_1 v_1 - m_1 v_2 = (m_1 + m_2) V_2\\]\\[V_1 = \\frac{(m_1 - m_2) v_1 + 2 m_2 v_2}{m_1 + m_2}\\]ë§ˆì°¬ê°€ì§€ë¡œ, $V_2$ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:\\[V_2 = \\frac{(m_2 - m_1) v_2 + 2 m_1 v_1}{m_1 + m_2}\\]ë¬¼ì²´ì˜ í¬ê¸°ë¥¼ í¬í•¨í•œ ì†ë„ ê³„ì‚°ë¬¼ì²´ì˜ í¬ê¸°ê°€ ì¡´ì¬í•˜ë©´ ìœ„ì—ì„œ êµ¬í•œ ê°’ì— ì¶”ê°€ì ì¸ ê³„ì‚°ì´ í•„ìš”í•˜ë‹¤.ìœ„ì˜ ì‹ì€ ë‘ ë¬¼ì²´ì˜ ì¶©ëŒ ë°©í–¥ì´ ë‘ ë¬¼ì²´ì˜ ì¤‘ì‹¬ì„ ì´ì€ ì§ì„ ê³¼ ê°™ì„ ë•Œ ì„±ë¦½í•œë‹¤.ë”°ë¼ì„œ ê·¸ë¦¼ì—ì„œì™€ ê°™ì´ ë‘ ë¬¼ì²´ê°€ $u_1$, $u_2$ë¡œ ì¶©ëŒí•  ë•Œ, ì†ë„ ë²¡í„°ë¥¼ ë¶„í•´í•˜ì—¬ê³µì˜ ì¤‘ì‹¬ì„ ì‡ëŠ” ë°©í–¥ì˜ ì†ë„ë¼ë¦¬ ê³„ì‚°í•œ í›„, ë‚˜ë¨¸ì§€ ì„±ë¶„ì˜ ì†ë„ë¥¼ í•©í•´ì¤˜ì•¼ í•œë‹¤.ë²¡í„°ë¥¼ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ë¶„í•´í•˜ëŠ” ë°©ë²•ì€ ë²¡í„°ì˜ ë‚´ì ì„ ì´ìš©í•˜ë©´ ëœë‹¤.ì†ë„ ë²¡í„°ê°€ $\\vec{A}$, ì¶©ëŒ ë°©í–¥ ë²¡í„°ê°€ $\\vec{B}$ì¼ ë•Œ, $\\vec{A}$ì™€ $\\vec{B}$ë¥¼ ë‚´ì í•˜ë©´ $\\vec{B}$ë°©í–¥ì— ëŒ€í•œ $\\vec{A}$ì˜ í¬ê¸°ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.ë‹¤ë¥¸ ë°©í–¥ì˜ í¬ê¸°ëŠ” $\\vec{B}$ë¥¼ 90ë„ íšŒì „ì‹œí‚¨ ë²¡í„°ì— ëŒ€í•´ ê³„ì‚°í•˜ë©´ ëœë‹¤.íšŒì „ê° $\\theta$ì— ë”°ë¥¸ íšŒì „ ê³µì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\\[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = \\begin{bmatrix}\\cos \\theta &amp; -\\sin \\theta \\\\\\sin \\theta &amp; \\cos \\theta\\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\\]ìƒì„¸ êµ¬í˜„ì€ elastic í•¨ìˆ˜ì— ì‘ì„±ë˜ì–´ ìˆë‹¤.ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "OOP ì •ë¦¬",
    "url": "/posts/OOP/",
    "categories": "Study, OOP",
    "tags": "OOP",
    "date": "2024-12-19 23:56:56 +0900",
    





    
    "snippet": "OOPíŠ¹ì§•      ì¶”ìƒí™”    ëŒ€ìƒì˜ ê³µí†µì ì¸ íŠ¹ì„±ë“¤ì„ ë¬¶ì–´ í‘œí˜„í•˜ëŠ” ê²ƒ (abstract, interface class)        ìƒì†          ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ì†ì„±ê³¼ ë©”ì„œë“œë¥¼ ë¬¼ë ¤ë°›ëŠ” ê²ƒ      ì½”ë“œ ì¬ì‚¬ìš©ì„±ê³¼ í™•ì¥ì„±ì„ ë†’ì„      ë¶€ëª¨ í´ë˜ìŠ¤ì˜ public, protected ë©¤ë²„ë¥¼ ìƒì†ë°›ëŠ”ë‹¤.            ìº¡ìŠí™”      ...",
    "content": "OOPíŠ¹ì§•      ì¶”ìƒí™”    ëŒ€ìƒì˜ ê³µí†µì ì¸ íŠ¹ì„±ë“¤ì„ ë¬¶ì–´ í‘œí˜„í•˜ëŠ” ê²ƒ (abstract, interface class)        ìƒì†          ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ì†ì„±ê³¼ ë©”ì„œë“œë¥¼ ë¬¼ë ¤ë°›ëŠ” ê²ƒ      ì½”ë“œ ì¬ì‚¬ìš©ì„±ê³¼ í™•ì¥ì„±ì„ ë†’ì„      ë¶€ëª¨ í´ë˜ìŠ¤ì˜ public, protected ë©¤ë²„ë¥¼ ìƒì†ë°›ëŠ”ë‹¤.            ìº¡ìŠí™”          ë°ì´í„°ì™€ ë©”ì„œë“œë¥¼ ë¬¶ê³ , ë°ì´í„°ì— ëŒ€í•œ ì§ì ‘ ì ‘ê·¼ì„ ë§‰ëŠ” ê²ƒ            ë‹¤í˜•ì„±          ê°™ì€ ì´ë¦„ì˜ ë©”ì„œë“œë‚˜ ì—°ì‚°ìê°€ ë‹¤ë¥¸ ë™ì‘ì„ í•˜ëŠ” ê²ƒ      ì˜¤ë²„ë¡œë”©ê³¼ ì˜¤ë²„ë¼ì´ë”©ì„ í†µí•´ êµ¬í˜„                  ì˜¤ë²„ë¡œë”©: ì´ë¦„ì€ ê°™ì§€ë§Œ ì‹œê·¸ë‹ˆì³ê°€ ë‹¤ë¥¸ ê²ƒ          ì˜¤ë²„ë¼ì´ë”©: ìƒìœ„ í´ë˜ìŠ¤ì˜ ë©”ì†Œë“œë¥¼ ì¬ì •ì˜ í•˜ëŠ” ê²ƒ                    SOLID ì›ì¹™      ë‹¨ì¼ ì±…ì„ ì›ì¹™ (SRP)    í´ë˜ìŠ¤ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì±…ì„ì„ ê°€ì§€ê³  í•˜ë‚˜ì˜ ì´ìœ ë¡œë§Œ ë³€ê²½ë˜ì–´ì•¼ í•œë‹¤.        ê°œë°© íì‡„ ì›ì¹™ (OCP)    í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤. ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šê³  ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.        ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™ (LSP)    ìƒìœ„ íƒ€ì…ì˜ ê°ì²´ë¥¼ í•˜ìœ„ íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•´ë„ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•´ì•¼ í•œë‹¤.        ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ (ISP)    í´ë¼ì´ì–¸íŠ¸ëŠ” ìì‹ ì´ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë©”ì„œë“œì— ì˜ì¡´í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤. ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„¸ë¶„í™”í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ê°€ í•„ìš”í•œ ê¸°ëŠ¥ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì œí•œí•œë‹¤.        ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ (DIP)    ê³ ìˆ˜ì¤€ ëª¨ë“ˆ(ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë“±)ì€ ì €ìˆ˜ì¤€ ëª¨ë“ˆ(êµ¬í˜„ ì„¸ë¶€ ì‚¬í•­)ì— ì˜ì¡´í•´ì„œëŠ” ì•ˆ ëœë‹¤. ê³ ìˆ˜ì¤€, ì €ìˆ˜ì¤€ ëª¨ë‘ ë‘˜ ë‹¤ ì¶”ìƒí™”(ì¸í„°í˜ì´ìŠ¤ë‚˜ ì¶”ìƒ í´ë˜ìŠ¤)ì— ì˜ì¡´í•´ì•¼ í•œë‹¤.    DIP ìœ„ë°˜     class EmailService {     public:         void SendEmail(const string&amp; message) {             cout &lt;&lt; \"Sending Email: \" &lt;&lt; message &lt;&lt; endl;         } }; // ê³ ìˆ˜ì¤€ ëª¨ë“ˆ: Notificationì€ EmailServiceì— ì§ì ‘ ì˜ì¡´ class Notification {     private:         EmailService emailService; // ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì§ì ‘ ì˜ì¡´     public:         void Notify(const string&amp; message) {             emailService.SendEmail(message); // EmailServiceì— ì§ì ‘ ì ‘ê·¼         } };        DIP ì ìš©     class IMessageService {     public:         virtual void SendMessage(const std::string&amp; message) = 0; }; // ê³ ìˆ˜ì¤€ ëª¨ë“ˆ class Notification {     private:         IMessageService* messageService;     public:         Notification(IMessageService* service) : messageService(service) {}         void Notify(const std::string&amp; message) {             messageService-&gt;SendMessage(message);         } }; // ì €ìˆ˜ì¤€ ëª¨ë“ˆ class EmailService : public IMessageService {     public:         void SendMessage(const std::string&amp; message) override {             // ì´ë©”ì¼ ì „ì†¡ ë¡œì§         } };      ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "OS Scheduling",
    "url": "/posts/OS_Scheduling/",
    "categories": "Study, OS",
    "tags": "Scheduling",
    "date": "2024-12-19 13:50:56 +0900",
    





    
    "snippet": "# OSScheduling  ìì›ì„ í• ë‹¹ë°›ì„ í”„ë¡œì„¸ìŠ¤ë¥¼ ê²°ì •í•˜ëŠ” ê³¼ì •  Process 5-state model  ë‹¤ìŒ ê²½ìš°ì— ë°œìƒ          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)  ...",
    "content": "# OSScheduling  ìì›ì„ í• ë‹¹ë°›ì„ í”„ë¡œì„¸ìŠ¤ë¥¼ ê²°ì •í•˜ëŠ” ê³¼ì •  Process 5-state model  ë‹¤ìŒ ê²½ìš°ì— ë°œìƒ          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)        ì´ ì¤‘ 1, 4ë²ˆì—ì„œë§Œ ë°œìƒí•  ê²½ìš° ë¹„ì„ ì  (non-preemptive), ë„¤ ê°€ì§€ ì „ë¶€ì—ì„œ ë°œìƒí•  ê²½ìš° ì„ ì  (preemptive) ìŠ¤ì¼€ì¤„ë§ì´ë¼ í•œë‹¤.  ì•Œê³ ë¦¬ì¦˜First Come First Served (FCFS, FIFO)  ê°€ì¥ ê°„ë‹¨í•œ ë¹„ì„ ì  ìŠ¤ì¼€ì¤„ë§ ë°©ë²•  ì‘ì—… íì— ë„ì°©í•œ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•œë‹¤.  ì‘ì—… ìˆœì„œì— ë”°ë¼ ì½˜ë³´ì´ íš¨ê³¼ê°€ ë°œìƒ í•  ìˆ˜ ìˆë‹¤.          ì½˜ë³´ì´ íš¨ê³¼: í•˜ë‚˜ì˜ ê¸´ ì‘ì—…ì´ CPUë¥¼ ì˜¤ë˜ ì ìœ í•˜ì—¬ ë’¤ì— ëŒ€ê¸°í•˜ëŠ” ì§§ì€ ì‘ì—…ë“¤ì´ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ê²Œ ë˜ëŠ” í˜„ìƒ      Shortest Job First (SJB)  ë¹„ì„ ì   ì‹¤í–‰ ì‹œê°„(burst time)ì´ ì§§ì€ í”„ë¡œì„¸ìŠ¤ë¶€í„° ì‹¤í–‰  ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ê°€ ê³„ì† ìì› í• ë‹¹ì„ ë°›ì§€ ëª»í•˜ëŠ” Starvation ë°œìƒ ê°€ëŠ¥Shortest Remaining Time First (SRTF)  ì„ ì í˜•  ë‚¨ì€ ì‹œê°„ì´ ê°€ì¥ ì§§ì€ í”„ë¡œì„¸ìŠ¤ë¶€í„° ì‹¤í–‰  Starvation ë°œìƒ ê°€ëŠ¥Priority Scheduling  ì„ ì í˜•, ë¹„ì„ ì í˜•  ì„ ì í˜•ì˜ ê²½ìš° Starvation ë°œìƒ ê°€ëŠ¥          ì˜¤ë˜ ëŒ€ê¸°í•œ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ë†’ì—¬ì„œ í•´ê²° ê°€ëŠ¥ (aging)      Round Robin (RR)  ì„ ì í˜•  ì¼ì •í•œ ì‹œê°„ ê°„ê²©ë™ì•ˆë§Œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì²˜ë¦¬í•˜ê³  ë‚¨ì€ ì‘ì—…ì€ íì˜ ë§¨ ë’¤ë¡œ ë³´ëƒ„Multilevel Feedback Queue  ì„ ì í˜•  ìš°ì„ ìˆœìœ„ê°€ ë‹¤ë¥¸ ì—¬ëŸ¬ê°œì˜ íë¥¼ ì‚¬ìš©  í”„ë¡œì„¸ìŠ¤ëŠ” ë‹¤ë¥¸ íë¡œ ì´ë™ ê°€ëŠ¥ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ìµœì¥ ê³µí†µ ë¶€ë¶„ ìˆ˜ì—´",
    "url": "/posts/LCS/",
    "categories": "Study, Algorithm",
    "tags": "DP, LCS",
    "date": "2024-11-30 01:19:44 +0900",
    





    
    "snippet": "ìµœì¥ ê³µí†µ ë¶€ë¶„ ìˆ˜ì—´(LCS: Longest Common Subsequence)LCS ê¸¸ì´ êµ¬í•˜ê¸°DP[i][j]: A[..i], B[..j]ê¹Œì§€ì˜ LCSê¸¸ì´      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j ...",
    "content": "ìµœì¥ ê³µí†µ ë¶€ë¶„ ìˆ˜ì—´(LCS: Longest Common Subsequence)LCS ê¸¸ì´ êµ¬í•˜ê¸°DP[i][j]: A[..i], B[..j]ê¹Œì§€ì˜ LCSê¸¸ì´      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])  LCS ë¬¸ìì—´ êµ¬í•˜ê¸°  ì—­ì¶”ì  (Backtracking) ë°©ì‹DP í…Œì´ë¸”ì„ ì´ìš©í•´ (N, M)ì—ì„œ (0, 0)ê¹Œì§€ ì—­ì¶”ì í•˜ì—¬ LCSë¥¼ ë³µì›.          A[i] == B[j]ì´ë©´ LCSì— í¬í•¨ë¨ â†’ i-1, j-1ë¡œ ì´ë™      DP[i-1][j], DP[i][j-1]ë¥¼ ë¹„êµí•´ í° ìª½ìœ¼ë¡œ ì´ë™      def LCS(A: str, B: str) -&gt; str:    N, M = len(A), len(B)    DP = [[0] * (M + 1) for _ in range(N + 1)]    # DP í…Œì´ë¸” ì±„ìš°ê¸°    for i in range(1, N + 1):        for j in range(1, M + 1):            if A[i - 1] == B[j - 1]:  # ë¬¸ìê°€ ê°™ìœ¼ë©´                DP[i][j] = DP[i - 1][j - 1] + 1            else:                DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])    # LCS ì—­ì¶”ì  (Backtracking)    i, j = N, M    lcs = []    while i &gt; 0 and j &gt; 0:        if A[i - 1] == B[j - 1]:  # ê°™ì€ ë¬¸ìëŠ” LCSì— í¬í•¨            lcs.append(A[i - 1])            i -= 1            j -= 1        elif DP[i - 1][j] &gt; DP[i][j - 1]:  # ìœ„ìª½ì´ í¬ë‹¤ë©´ ìœ„ë¡œ ì´ë™            i -= 1        else:  # ì™¼ìª½ì´ í¬ë‹¤ë©´ ì™¼ìª½ìœ¼ë¡œ ì´ë™            j -= 1    return ''.join(reversed(lcs))  # ì—­ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜ì‹œê°„ ë³µì¡ë„  DP í…Œì´ë¸”ì„ ì±„ìš°ëŠ” ê³¼ì •: O(N Ã— M)  LCS ì—­ì¶”ì  ê³¼ì •: O(N + M)  ì „ì²´ ì‹œê°„ ë³µì¡ë„: O(N Ã— M)ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ì •ë ¬ ì•Œê³ ë¦¬ì¦˜",
    "url": "/posts/Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 01:15:21 +0900",
    





    
    "snippet": "ì •ë ¬Bubble Sortì¸ì ‘í•œ ë‘ ì›ì†Œë¥¼ ë¹„êµí•˜ì—¬ ì—­ìˆœì´ë©´ êµí™˜í•œë‹¤.# seq = []# ì´ në²ˆ ë°˜ë³µfor i in range(n - 1, -1, -1):    is_swapped = False    # ë§¤ ë°˜ë³µ í›„ì— seq[i + 1:]ì€ ì •ë ¬ëœ ìƒíƒœì´ë¯€ë¡œ     # seq[:i] ê¹Œì§€ë§Œ í™•ì¸    for j in range(i):        i...",
    "content": "ì •ë ¬Bubble Sortì¸ì ‘í•œ ë‘ ì›ì†Œë¥¼ ë¹„êµí•˜ì—¬ ì—­ìˆœì´ë©´ êµí™˜í•œë‹¤.# seq = []# ì´ në²ˆ ë°˜ë³µfor i in range(n - 1, -1, -1):    is_swapped = False    # ë§¤ ë°˜ë³µ í›„ì— seq[i + 1:]ì€ ì •ë ¬ëœ ìƒíƒœì´ë¯€ë¡œ     # seq[:i] ê¹Œì§€ë§Œ í™•ì¸    for j in range(i):        if seq[j] &gt; seq[j + 1]:            seq[j], seq[j + 1] = seq[j + 1] &gt; seq[j]            is_swapped = True    if not is_swapped:        breakSelection Sortí˜„ì¬ i = [0, n)ì¼ ë•Œ seq[i:]ì—ì„œ ê°€ì¥ ì‘ì€ ì›ì†Œì™€ seq[i]ë¥¼ êµí™˜í•œë‹¤.# seq = []for cur in range(n):    min_index = cur    for i in range(cur, n):        if seq[min_index] &gt; seq[i]:            min_index = i    seq[min_index], seq[cur] = seq[cur], seq[min_index]Insertion Sortí˜„ì¬ i = [1, n)ì¼ ë•Œ seq[:i]ì—ì„œ seq[i]ë¥¼ ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ì°¾ì•„ ì‚½ì…í•œë‹¤.# seq = []for cur in range(1, n):    while cur &gt; 0 and seq[cur] &lt; seq[cur - 1]:        seq[cur], seq[cur - 1] = seq[cur - 1], seq[cur]        cur -= 1Quick Sortpivotì„ ê¸°ì¤€ìœ¼ë¡œ ë°°ì—´ì„ ì–‘ìª½ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì •ë ¬í•œë‹¤.# seq = []def partition(left, right):    # [left, right] ë²”ìœ„ë¥¼ ì¬ë°°ì¹˜    pivot = seq[(left + right) // 2]    while left &lt;= right:        # leftë¥¼ pivotë³´ë‹¤ í° ì›ì†Œê°€ ë‚˜íƒ€ë‚˜ëŠ” ì§€ì ê¹Œì§€ ì´ë™        while seq[left] &lt; pivot:            left += 1        # rightë¥¼ pivotë³´ë‹¤ ì‘ì€ ì›ì†Œê°€ ë‚˜íƒ€ë‚˜ëŠ ì§€ì ê¹Œì§€ ì´ë™        while seq[right] &gt; pivot:            right -= 1                # ì¬ë°°ì¹˜ê°€ ì•ˆëë‚¬ìœ¼ë©´        if left &lt;= right:            # seq[left]ëŠ” pivotë³´ë‹¤ í¬ê³              # seq[right]ëŠ” pivotë³´ë‹¤ ì‘ìœ¼ë¯€ë¡œ             # ì„œë¡œ êµí™˜            seq[left], seq[right] = seq[right], seq[left]            # í•œ ì¹¸ì”© ì´ë™            left, right = left + 1, right - 1    return leftdef quick_sort(left, right):    print(seq, left, right)    if left &gt;= right:        return        mid = partition(left, right)    quick_sort(left, mid - 1)    quick_sort(mid, right)Merge Sortë°°ì—´ì„ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ê³  ê° ë°°ì—´ì„ ì •ë ¬í•œ ë’¤ í•˜ë‚˜ë¡œ í•©ì¹œë‹¤.# seq = []def merge(left, mid, right):    # seq[left:mid + 1]ê³¼ seq[mid + 1:right]ë¥¼ í•©ì¹¨    tmp = []    i, j = left, mid + 1    # ë‘ ë¶€ë¶„ ë°°ì—´ì—ì„œ ì‘ì€ ê°’ì„ ì±„ì›Œ ë„£ìŒ    while i &lt;= mid and j &lt;= right:        if seq[i] &lt; seq[j]:            tmp.append(seq[i])            i += 1        else:            tmp.append(seq[j])            j += 1    # ë¶€ë¶„ ë°°ì—´ì—ì„œ ë‚¨ì€ ê²ƒì„ ë’¤ì— ì¶”ê°€í•¨    while i &lt;= mid:         tmp.append(seq[i])        i += 1    while j &lt;= right:        tmp.append(seq[j])        j += 1    # ì •ë ¬ëœ ë°°ì—´ì„ ì›ë³¸ ë°°ì—´ì— ì˜®ê¹€    seq[left:left+len(tmp)] = tmp[:]def merge_sort(left, right):    # ê¸¸ì´ 2 ì´ìƒì˜ ë°°ì—´ì— ëŒ€í•´ ë¶„í•     if left &gt;= right:        return    mid = (left + right) // 2    # ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ”    merge_sort(left, mid)    merge_sort(mid + 1, right)    # ë‚˜ëˆˆ ë°°ì—´ì„ í•©ì¹¨    merge(left, mid, right)ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "í¸ì§‘ ê±°ë¦¬",
    "url": "/posts/Edit_distance/",
    "categories": "Study, Algorithm",
    "tags": "DP",
    "date": "2024-11-30 01:02:24 +0900",
    





    
    "snippet": "í¸ì§‘ ê±°ë¦¬ë¬¸ìì—´ Aë¥¼ ë¬¸ìì—´ Bë¡œ ë°”ê¾¸ëŠ”ë° í•„ìš”í•œ ì—°ì‚°(ë¬¸ì ì¶”ê°€, ì‚­ì œ, êµì²´)ì˜ ìµœì†Œ íšŸìˆ˜DP[i][j]: A[..i]ë¥¼ B[..j]ë¡œ í¸ì§‘í•˜ëŠ” ì—°ì‚°ì˜ ìµœì†Œ íšŸìˆ˜A[i] == B[j]ë¼ë©´ í•´ë‹¹ ìœ„ì¹˜ì— ëŒ€í•´ì„œëŠ” í¸ì§‘í•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]ë¼ë©´ í¸ì§‘ì´ í•„ìš”í•˜ë‹¤.ì¶”ê°€í•˜ëŠ” ê²½ìš°ëŠ” A[i]...",
    "content": "í¸ì§‘ ê±°ë¦¬ë¬¸ìì—´ Aë¥¼ ë¬¸ìì—´ Bë¡œ ë°”ê¾¸ëŠ”ë° í•„ìš”í•œ ì—°ì‚°(ë¬¸ì ì¶”ê°€, ì‚­ì œ, êµì²´)ì˜ ìµœì†Œ íšŸìˆ˜DP[i][j]: A[..i]ë¥¼ B[..j]ë¡œ í¸ì§‘í•˜ëŠ” ì—°ì‚°ì˜ ìµœì†Œ íšŸìˆ˜A[i] == B[j]ë¼ë©´ í•´ë‹¹ ìœ„ì¹˜ì— ëŒ€í•´ì„œëŠ” í¸ì§‘í•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]ë¼ë©´ í¸ì§‘ì´ í•„ìš”í•˜ë‹¤.ì¶”ê°€í•˜ëŠ” ê²½ìš°ëŠ” A[i]ì— ë¬¸ìì—´ì„ í•˜ë‚˜ ì¶”ê°€í•´ì„œ B[j]ê°€ ë˜ì–´ì•¼ í•˜ë¯€ë¡œ DP[i][j - 1] + 1, ì¦‰ A[..i]ë¥¼ B[..j - 1]ë¡œ ë³€ê²½í•˜ëŠ” ìµœì†Œ íšŸìˆ˜ì— 1ì„ ë”í•´ì¤€ë‹¤.ë³€ê²½ì€ A[i]ë¥¼ B[j]ë¡œ ë°”ê¾¸ëŠ” ê²ƒì´ë¯€ë¡œ DP[i - 1][j - 1] + 1ì‚­ì œëŠ” DP[i - 1][j] + 1ì´ ëœë‹¤.(A[..i - 1]ë¡œ B[j]ë¥¼ ë§Œë“¤ì—ˆìœ¼ë¯€ë¡œ A[i]ë¥¼ ì‚­ì œ)ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ìœ„ìƒ ì •ë ¬",
    "url": "/posts/Topology_Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 00:01:14 +0900",
    





    
    "snippet": "ìœ„ìƒì •ë ¬ë¹„ìˆœí™˜ ìœ í–¥ ê·¸ë˜í”„(DAG)ì— ëŒ€í•´ì„œ ì •ì ì„ ì„ í˜•ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ê²ƒê° ë…¸ë“œì— ì„ í–‰ ì¡°ê±´ì´ ì¡´ì¬í•  ë•Œ ì‚¬ìš© ê°€ëŠ¥ì •ë ¬ ë°©ë²•  ê° ë…¸ë“œì˜ ì§„ì… ì°¨ìˆ˜ ê¸°ë¡  ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì ì„ íì— ì‚½ì…  íì— ë‹´ê¸´ ì •ì ì—ì„œ ë‚˜ê°€ëŠ” ê°„ì„ ì„ ì œê±°í•˜ê³  í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì •ì ì˜ ì§„ì… ì°¨ìˆ˜ë¥¼ ê°ì†Œ  2-3ê³¼ì •ì„ íê°€ ë¹„ê±°ë‚˜ ëª¨ë“  ì •ì ì„ íƒìƒ‰í•  ë•Œê¹Œì§€ ë°˜ë³µêµ¬í˜„graph ...",
    "content": "ìœ„ìƒì •ë ¬ë¹„ìˆœí™˜ ìœ í–¥ ê·¸ë˜í”„(DAG)ì— ëŒ€í•´ì„œ ì •ì ì„ ì„ í˜•ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ê²ƒê° ë…¸ë“œì— ì„ í–‰ ì¡°ê±´ì´ ì¡´ì¬í•  ë•Œ ì‚¬ìš© ê°€ëŠ¥ì •ë ¬ ë°©ë²•  ê° ë…¸ë“œì˜ ì§„ì… ì°¨ìˆ˜ ê¸°ë¡  ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì ì„ íì— ì‚½ì…  íì— ë‹´ê¸´ ì •ì ì—ì„œ ë‚˜ê°€ëŠ” ê°„ì„ ì„ ì œê±°í•˜ê³  í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì •ì ì˜ ì§„ì… ì°¨ìˆ˜ë¥¼ ê°ì†Œ  2-3ê³¼ì •ì„ íê°€ ë¹„ê±°ë‚˜ ëª¨ë“  ì •ì ì„ íƒìƒ‰í•  ë•Œê¹Œì§€ ë°˜ë³µêµ¬í˜„graph = defaultdict(list)indegree = [0] * (n + 1)# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë° ì§„ì… ì°¨ìˆ˜ ì´ˆê¸°í™”# for _ in range(k):#     a, b = map(int, input().split())#     graph[a].append(b)#     indegree[b] += 1# ì§„ì… ì°¨ìˆ˜ 0ì¸ ì •ì  íì— ì¶”ê°€q = deque(filter(lambda x: indegree[x] == 0, range(1, n + 1)))while q:    cur = st.popleft()    print(q)    if cur in graph:        for nxt in graph[cur]:            indegree[nxt] -= 1            if indegree[nxt] == 0:                st.append(nxt)ğŸ”— ì›ë³¸ íŒŒì¼ ë³´ê¸°"
  },
  
  {
    "title": "ë¸”ë¡œê·¸ ì†Œê°œ",
    "url": "/posts/Introduce/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2024-11-15 10:28:00 +0900",
    





    
    "snippet": "ì•Œê³ ë¦¬ì¦˜, ìë£Œêµ¬ì¡° ë° ë‹¤ì–‘í•œ í”„ë¡œê·¸ë˜ë° ê´€ë ¨ ë‚´ìš©ì„ ì •ë¦¬í•œ ê°œì¸ í•™ìŠµ ì €ì¥ì†Œì…ë‹ˆë‹¤.",
    "content": "ì•Œê³ ë¦¬ì¦˜, ìë£Œêµ¬ì¡° ë° ë‹¤ì–‘í•œ í”„ë¡œê·¸ë˜ë° ê´€ë ¨ ë‚´ìš©ì„ ì •ë¦¬í•œ ê°œì¸ í•™ìŠµ ì €ì¥ì†Œì…ë‹ˆë‹¤."
  }
  
]

