[
  
  {
    "title": "RDP on UDP",
    "url": "/posts/RDP-on-UDP/",
    "categories": "Project, Network",
    "tags": "RDP",
    "date": "2025-03-12 16:31:36 +0900",
    





    
    "snippet": "RDT on UDP1. 목표  UDP 소켓 프로그래밍을 활용하여 신뢰할 수 있는 데이터 전송 (RDT) 프로토콜 개발을 목표로 한다.  단계별로 구현하며, 다음 네 가지 버전을 차례대로 개발한다.          RDT 1.0      RDT 2.2      RDT 3.0      RDT 3.0 + 파이프라이닝      2. 구현 세부 정보상위 버전의...",
    "content": "RDT on UDP1. 목표  UDP 소켓 프로그래밍을 활용하여 신뢰할 수 있는 데이터 전송 (RDT) 프로토콜 개발을 목표로 한다.  단계별로 구현하며, 다음 네 가지 버전을 차례대로 개발한다.          RDT 1.0      RDT 2.2      RDT 3.0      RDT 3.0 + 파이프라이닝      2. 구현 세부 정보상위 버전의 RDT는 이전 버전을 기반으로 구축된다. 따라서 각 버전을 순서대로 구현한다.2.1 공통 기능  기본 절차          일대일 상황만 가정하며 다중 사용자 사례는 고려하지 않는다.      [Receiver]                  소켓을 열고 포트 10090에 바인딩하여 Sender의 전송을 기다린다.                    [Sender]                  Receiver의 IP와 포트 번호로 소켓을 생성하고, 사용자 입력으로 지정된 파일을 전송한다.          파일 전송 완료 후 연결을 종료한다.                    [Receiver]                  파일 전송이 완료되면 연결을 종료한다.                      매개변수          [Sender]: 실행 시 다음 4가지 매개변수를 받는다.&lt;receiver's IP address&gt; &lt;window size&gt; &lt;source file name&gt; &lt;log file name&gt;      [Receiver]: 실행 시 다음 2가지 매개변수를 받는다.&lt;result file name&gt; &lt;log file name&gt;      매개변수가 충분히 제공되지 않으면 프로그램을 종료한다.        패킷          각 RDT 버전에 맞게 사용자 지정 패킷 헤더를 설계한다.      페이로드의 크기가 너무 커서 헤더 공간이 부족해지지 않도록 주의한다.      비트 오류와 패킷 손실은 Sender 측에서만 발생한다고 가정한다.        로그 파일          Sender와 Receiver 모두 로그 파일을 작성해야 한다.      제공되는 logHandler.py 또는 logHandler_fct.py 중 하나를 사용하여 구현하도록 한다.        라이브러리 사용          비표준 라이브러리는 사용 금지.      HTTP 직접 처리 등 과제 해결에 직접적으로 영향을 주는 라이브러리도 사용 금지.      허용 모듈 예시: sys, os, threading, time, socket      2.2 각 RDT 프로토콜 버전RDT 1.0  가정: 신뢰할 수 있는 채널  기능: Receiver가 Sender로부터 지정된 파일을 받음  특징:          헤더는 고려하지 않는다      window size는 1로 고정      RDT 2.2  요구사항: RDT 1.0의 모든 기능 포함  가정: 기본 채널에서 비트 오류가 발생할 수 있음  기능:          UDP 방식의 Check Sum 계산을 통해 패킷 손상 여부 확인      NAK-free 프로토콜을 구현하여 정상 패킷과 손상된 패킷 모두 올바르게 처리        특징: window size는 1로 고정RDT 3.0  요구사항: RDT 2.2의 모든 기능 포함  가정: 기본 채널에서 패킷 손실이 발생할 수 있음  기능:          Sender가 0.01초 동안 ACK를 수신하지 못하면 해당 패킷을 손실로 간주하고 재전송      Sender와 Receiver 모두 중복된 패킷을 처리해야 함        특징: window size는 1로 고정RDT 3.0 + 파이프라이닝  요구사항: RDT 3.0의 모든 기능 포함  가정: RDT 3.0에 파이프라이닝을 적용  기능:          Sender는 ACK를 기다리지 않고 window size에 맞게 여러 패킷을 전송 가능→ window size는 Sender가 전송할 수 있는 미확인 패킷의 최대 개수      Selective Repeat 전략을 사용하여 패킷 손실 복구 수행      Receiver도 window size에 맞춘 버퍼를 사용하며, Sender로부터 입력받은 window size를 공유하여 동기화를 맞춤                  단, 이 소켓 통신은 신뢰할 수 있다고 가정 (비트 오류와 패킷 손실 없음)                    테스트: window size는 최소 5에서 최대 10 사이의 값으로 시험한다. Selective Response 딜레마에 빠지지 않는 최소 Sequence Number Size를 사용하도록 한다.      가정: Sender가 window 크기만큼 패킷을 전송하기 전에 ACK가 도착하지 않을 정도로 RTT(왕복 시간)가 항상 충분히 큼      3.3 요약 표                   RDT 1.0      RDT 2.2      RDT 3.0      RDT 3.0 + 파이프라이닝                  소켓      O      O      O      O              헤더      X      O      O      O              타이머      X      X      O      O              파이프라이닝      X      X      X      O      4. 시나리오전반 사항  전송 및 로깅 기능을 위한 코드가 제공된다.  PASender.py          config.txt의 값을 편집하여 다양한 비트 오류 및 패킷 손실 상황을 시뮬레이션할 수 있다.      Sender 측에서는 이 PASender를 활용하여 손실 환경을 구성한다.      Receiver 측은 비트 오류와 패킷 손실이 없는 것으로 가정하고 기본 전송 기능을 사용한다.        logHandler.py / logHandler_fct.py          전체 패킷 처리 과정을 기록하는 로그 파일을 생성한다.        make_test_file.py          전송할 테스트 파일을 생성할 수 있는 스크립트      각 버전별 시나리오RDT 1.0  파일 크기: 약 1KB의 작은 파일 전송  조건: 비트 오류 및 패킷 손실 없음 (loss_rate = 0, corrupt_rate = 0)  예시 로그 (Sender 측):    0.000 pkt: 0 | Send DATA0.001 pkt: 0 | Send DATAFile transfer is finished.        특이사항: RDT 1.0은 Sender 측 로그만 작성해도 된다.RDT 2.2  파일 크기: 약 1MB의 중간 크기 파일 전송  조건: 패킷 손상 처리, NAK 방지 필요  예시 로그:          Sender 측:        0.000 pkt: 0 | Send DATA0.006 pkt: 0 | Sent Successfully0.007 pkt: 1 | Send DATA0.014 pkt: 1 | Wrong Sequence Number0.015 pkt: 1 | Send DATA Again0.021 pkt: 1 | Sent SuccessfullyFile transfer is finished.                    Receiver 측:        0.003 ACK: 0 | Send ACK 0.010 ACK: 1 | DATA Corrupted 0.011 ACK: 0 | Send ACK Again 0.018 ACK: 1 | Send ACK     File transfer is finished.                     RDT 3.0  파일 크기: 약 50MB의 대용량 파일 전송  조건: 패킷 드롭(손실) 처리 필요  예시 로그:          Sender 측:        0.000 pkt: 0 | Send DATA 0.010 pkt: 0 | TIMEOUT 0.012 pkt: 0 | Send DATA Again 0.018 pkt: 0 | Sent Successfully  File transfer is finished.                    Receiver 측:        0.015 ACK: 0 | Send ACK  File transfer is finished.                             RDT 3.0 + 파이프라이닝  파일 크기: 약 50MB의 대용량 파일 전송  조건: 파이프라이닝 및 Selective Repeat 수행  예시 로그 (일부):          Sender 측:        0.000 pkt: 0 | Send DATA 0.001 pkt: 1 | Send DATA 0.002 pkt: 2 | Send DATA 0.003 pkt: 3 | Send DATA 0.004 pkt: 0 | Sent Successfully 0.005 pkt: 4 | Send DATA 0.005 pkt: 1 | Sent Successfully 0.007 pkt: 3 | Wrong Sequence 0.007 pkt: 3 | Sent Successfully: Mark 0.007 pkt: 5 | Send DATA 0.009 pkt: 4 | Wrong Sequence 0.009 pkt: 4 | Sent Successfully: Mark 0.011 pkt: 5 | Wrong Sequence 0.011 pkt: 5 | Sent Successfully: Mark 0.012 pkt: 2 | TIMEOUT 0.013 pkt: 2 | Send DATA Again 0.017 pkt: 2 | Sent Successfully     File transfer is finished.                    Receiver 측:        0.002 ACK: 0 | Send ACK 0.003 ACK: 1 | Send ACK 0.005 ACK: 3 | Wrong Sequence: Buffer 0.005 ACK: 3 | Send ACK 0.007 ACK: 4 | Wrong Sequence: Buffer 0.007 ACK: 4 | Send ACK 0.009 ACK: 5 | Wrong Sequence: Buffer 0.009 ACK: 5 | Send ACK 0.015 ACK: 2 | Send ACK     File transfer is finished.                    🔗 원본 파일 보기🔗 RDT 1.0🔗 RDT 2.2🔗 RDT 3.0🔗 RDT 3.0+"
  },
  
  {
    "title": "Simple REST Server",
    "url": "/posts/Simple_REST_Server/",
    "categories": "Project, Network",
    "tags": "REST",
    "date": "2025-03-10 17:36:13 +0900",
    





    
    "snippet": "ImplementationHTTP 모듈(Flask 등)을 사용하지 않고, Python의 기본 socket 모듈과 스레딩(threading) 등을 이용하여 간단한 RESTful API를 구현한다. 전체적으로 사용자 정보 관리와 고정 메시지 응답, 그리고 Preflight 요청(CORS 처리) 등을 지원하며, 각 HTTP 메서드(GET, POST, PUT...",
    "content": "ImplementationHTTP 모듈(Flask 등)을 사용하지 않고, Python의 기본 socket 모듈과 스레딩(threading) 등을 이용하여 간단한 RESTful API를 구현한다. 전체적으로 사용자 정보 관리와 고정 메시지 응답, 그리고 Preflight 요청(CORS 처리) 등을 지원하며, 각 HTTP 메서드(GET, POST, PUT, DELETE, OPTIONS)에 대해 별도의 핸들러를 구현하였다.1. main.py      역할:서버의 엔트리 포인트로, 소켓을 생성하고 클라이언트 연결을 기다리며 각 연결마다 새로운 스레드를 생성하여 요청을 처리함.        구현:          소켓 생성 및 바인딩:                  HOST와 PORT를 설정하고, 소켓 옵션 SO_REUSEADDR를 설정하여 주소 재사용을 허용함.                    신호 처리:                  SIGINT (Ctrl+C) 시, 서버 소켓을 닫고 프로그램 종료를 수행.                    클라이언트 처리:                  무한 루프 내에서 클라이언트의 연결을 accept하고, 각 클라이언트에 대해 RequestHandler 인스턴스를 생성한 후, 별도의 스레드로 handler.run()을 실행하여 비동기적으로 요청을 처리하도록 함.                    2. request_handler.py      역할:클라이언트로부터 수신한 HTTP 패킷을 파싱하고, 적절한 HTTP 메서드 핸들러(GET, POST, OPTIONS, PUT, DELETE 등)를 호출하여 응답을 생성함.        핵심 내용:          공유 변수와 동기화:                  USER: 사용자 정보를 저장하는 전역 딕셔너리(서버 실행 동안만 유지).          LOCK: 여러 스레드에서 사용자 정보를 안전하게 접근하기 위한 락.                    패킷 파서:                  packet_parser() 함수는 수신한 HTTP 패킷을 헤더와 바디로 분리한다. 헤더 부분은 각 줄을 “:” 기준으로 키/값으로 파싱하여 딕셔너리로 변환한다.                    RequestHandler 클래스:                  생성자에서 각 HTTP 메서드(GET, POST, OPTIONS, PUT, DELETE)에 대해 해당하는 모듈의 handler 함수를 매핑한다.          run() 메서드에서는 소켓으로부터 데이터를 읽어와 패킷을 파싱하고, 요청된 HTTP 메서드에 해당하는 핸들러를 호출한 후, 생성된 응답 패킷을 클라이언트에게 전송한다.          만약 지원하지 않는 메서드가 요청되면, NotAllowed 핸들러를 호출하여 405 응답을 반환한다.                    3. response.py      역할:HTTP 응답 메시지를 생성하는 유틸리티 함수들을 제공한다.        핵심 내용:          상태 코드 매핑:                  STATUS_CODE 딕셔너리로 각 상태 코드(200, 201, 400, 404 등)를 HTTP/1.1 상태 메시지와 매핑함.                    헤더 생성:                  create_header() 함수는 HTTP 버전, 상태 코드, 서버 정보, 필수 헤더(Access-Control-Allow-Origin, Date 등)를 포함하는 응답 헤더를 생성한다.                    전체 응답 생성:                  create_response() 함수는 지정된 코드와 (선택적) 응답 본문, 그리고 Preflight 요청일 경우 필요한 CORS 관련 옵션(Access-Control-Allow-Methods, Access-Control-Allow-Headers 등)을 처리하여 최종 응답 패킷을 구성한 후 바이트 문자열로 반환한다.                    4. method_handler.py      역할:모든 HTTP 메서드 핸들러가 상속받아야 하는 추상 기본 클래스(ABC)를 정의함.        핵심 내용:          Method 클래스는 handler라는 클래스 메서드를 정의하고 있으며, 구체적인 메서드(GET, POST, PUT, DELETE, OPTIONS 등)는 이를 오버라이드하여 구현한다.      이를 통해 모든 메서드 핸들러가 동일한 인터페이스를 갖도록 강제하였음.      5. delete.py      역할:DELETE HTTP 메서드를 처리하며, 사용자 정보 삭제 요청을 처리함.        핵심 내용:          경로가 /user/&lt;id&gt;인 경우, URL에서 사용자 id를 추출하여, 공유 USER 딕셔너리에서 해당 사용자를 삭제함.      동기화(LOCK)를 사용해 여러 스레드에서 동시에 접근할 때 안전하게 처리.      사용자가 존재하지 않으면 404, 존재하면 삭제 후 200 응답을 반환함.      6. get.py      역할:GET HTTP 메서드를 처리합니다. 두 가지 주요 엔드포인트 /hi와 /user에 대해 각각 다른 응답을 반환한다.        핵심 내용:          /hi 엔드포인트:                  고정 메시지 응답으로, JSON 형식으로 {\"message\": \"hi\"}를 반환함.                    /user 엔드포인트:                  URL 쿼리 스트링에서 id 값을 추출하여, 해당 사용자가 USER 딕셔너리에 존재하는지 확인.          사용자 정보가 존재하면 JSON 형태로 반환(200), 없으면 404 응답을 반환.                    7. not_allowed.py      역할:지원하지 않는 HTTP 메서드에 대해 405 Method Not Allowed 응답을 생성한다.        핵심 내용:          NotAllowed 클래스는 Method를 상속받아, 호출 시 response.create_response(405)를 반환함.      RequestHandler에서 정의되지 않은 메서드가 요청되었을 때 이 핸들러가 호출되도록 함.      8. options.py      역할:OPTIONS HTTP 메서드를 처리하여, 클라이언트에서 Preflight 요청 시 필요한 CORS 정보를 제공한다.        핵심 내용:          요청 URL이 /user로 시작하는 경우, URL의 세부 경로에 따라 허용되는 메서드와 헤더가 달라집니다.                  사용자 목록(컬렉션) 요청: /user인 경우, 허용 메서드로 GET, POST, OPTIONS를 반환한다.          특정 사용자 요청: /user/&lt;id&gt;인 경우, 허용 메서드로 DELETE, PUT, OPTIONS를 반환한다.                    응답에 Access-Control-Allow-Methods, Access-Control-Allow-Headers, Access-Control-Max-Age 등의 헤더를 포함시켜 Preflight 요청을 처리함.      9. post.py      역할:POST HTTP 메서드를 처리한다.        핵심 내용:          /echo 엔드포인트:                  클라이언트가 보낸 본문(body)을 그대로 응답으로 반환한다.                    /user 엔드포인트 (사용자 등록):                  요청 본문을 JSON으로 파싱하여 id, name, gender 필드가 모두 존재하는지 확인함.          필수 필드가 누락되면 400 Bad Request 응답을 반환.          이미 동일한 id가 존재하면 409 Conflict 응답 반환.          모든 조건이 충족되면, LOCK을 사용해 USER 딕셔너리에 신규 사용자를 추가하고 201 Created 응답을 반환한다.                    10. put.py      역할:PUT HTTP 메서드를 처리하여, 특정 사용자의 정보를 수정한다.        핵심 내용:          URL에서 /user/&lt;id&gt; 형식으로 사용자 id를 추출한다.      요청 본문을 JSON으로 파싱한 후, 수정 가능한 정보가 올바른지 검증함.                  수정 가능 정보는 오직 name만 허용된다.          만약 JSON 데이터에 id나 gender가 포함되거나, name 필드가 누락된 경우 400 Bad Request를 반환하도록 함.                    현재 저장된 이름과 동일한 경우엔 무의미한 수정으로 간주하여 422 Unprocessable Entity 응답을 반환한다.      올바른 요청이면 사용자 정보를 업데이트하고 200 OK 응답을 반환한다.      🔗 원본 파일 보기"
  },
  
  {
    "title": "Manacher 알고리즘",
    "url": "/posts/Manacher/",
    "categories": "Study, Algorithm",
    "tags": "Palindrome, Manacher",
    "date": "2025-02-06 08:42:47 +0900",
    





    
    "snippet": "문자열 내에서 가장 긴 팰린드롬 부분 문자열(Longest Palindromic Substring)을 $O(n)$ 시간에 찾을 수 있는 알고리즘. 일반적으로 팰린드롬 부분 문자열 문제를 단순 확장 방식(Expand Around Center)으로 풀면 $O(n^2)$ 시간이 걸리지만, Manacher 알고리즘을 사용하면 이를 선형 시간에 해결할 수 있다...",
    "content": "문자열 내에서 가장 긴 팰린드롬 부분 문자열(Longest Palindromic Substring)을 $O(n)$ 시간에 찾을 수 있는 알고리즘. 일반적으로 팰린드롬 부분 문자열 문제를 단순 확장 방식(Expand Around Center)으로 풀면 $O(n^2)$ 시간이 걸리지만, Manacher 알고리즘을 사용하면 이를 선형 시간에 해결할 수 있다.1. 핵심 아이디어Manacher 알고리즘의 핵심 아이디어는 다음과 같다.  문자열의 변형(Preprocessing)          짝수 길이 팰린드롬까지 다룰 수 있도록, 길이 N의 원본 문자열 각 문자 사이사이에 특정 구분 문자(대개 #)를 삽입해 길이 2N + 1의 확장 문자열로 만든다.      예를 들어, 문자열 abba를 #a#b#b#a#와 같이 변형.        팰린드롬의 중심(Center)과 오른쪽 경계(Right Boundary) 추적          변형된 문자열에서, 특정 구간 동안 알고 있는 가장 오른쪽에 도달하는 팰린드롬을 추적한다.      알고리즘이 진행되는 과정에서 “현재까지 확인한 팰린드롬 중 가장 오른쪽 끝”을 R이라 하고, 그 팰린드롬의 중심을 C라고 한다.      현재 인덱스 i에 대해서 팰린드롬 반경 P[i]를 초기화할 때, i의 좌우 대칭 원소 i'(= 2C - i)의 정보를 활용. (즉, 기존에 구해놓은 팰린드롬 정보를 재활용)      4. 시간 복잡도  각 인덱스에서 팰린드롬 반경을 확장할 때, 이미 확장한 부분은 재활용하며 중복 계산을 하지 않는다.  따라서 각 문자를 중심으로 하는 최대 팰린드롬 확장 연산이 전체적으로 $O(n)$ 시간 안에 끝남.  전처리에 걸리는 시간(구분 문자 삽입)도 $O(n)$ 이므로, $O(n)$ 시간 알고리즘이다.Rust 구현use std::cmp::min;fn manacher(s: Vec&lt;u8&gt;) -&gt; u64 {    let e = s.len() * 2 + 1;    let mut extended = vec![0; e];    for i in 0..s.len() {        extended[i * 2 + 1] = s[i];    }    let mut r = 0; // 현재까지의 팰린드롬 중 가장 긴 것의 오른쪽 끝    let mut p = 0; // 현재까지의 팰린드롬 중 가장 긴 것의 중심    let mut dp = vec![0; e];    let mut ans = 0;    for i in 0..e {        // DP[i] 초기화        // i &gt; r 이라면 검증된 팰린드롬을 벗어났음을 의미 =&gt; DP[i] = 0        // 이외의 경우, 다음과 같은 3가지 케이스가 존재        // 1) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬 안에 존재         //    - p를 기준으로 현재 문자 i의 대칭점(2 * p - i)과 동일한 길이만큼 팰린드롬임이 보장됨        //    - 따라서 DP[i] = DP[2 * p - i]        // 2) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬과 겹치는 경우        //    - 검증된 가장 긴 팰린드롬까지는 팰린드롬임이 보장됨        //    - 따라서 DP[i] = r - i        // 3) 현재 문자 기준 팰린드롬이 검증된 가장 긴 팰린드롬을 넘어가는 경우        //    - 검증된 가장 긴 팰린드롬까지는 팰린드롬임이 보장됨        //    - 따라서 DP[i] = r - i        //        // 1)의 경우 DP[2 * p - i] &lt; r - i (검증된 가장 긴 팰린드롬을 넘어가지 않아야 하므로)        // 2), 3)의 경우 r - i &lt;= DP[2 * p - i] (검증된 가장 긴 팰린드롬과 겹치거나 넘어가야 하므로)        // =&gt; DP[2 * p - i] 와 r - i 중 작은 값으로 초기화        // 출처 : https://sam0308.tistory.com/127        if i &lt;= r {            dp[i] = min(dp[p * 2 - i], r - i);        }        // 팰린드롬 확장        while             i &gt;= dp[i] + 1 &amp;&amp; // 현재 문자 i 기준 좌측 끝 (i - dp[i] - 1 &gt;= 0)            i + dp[i] + 1 &lt; e &amp;&amp; // 현재 문자 i 기준 우측 끝             extended[i - dp[i] - 1] == extended[i + dp[i] + 1] {            dp[i] += 1;        }        // 팰린드롬 확장 반영        if r &lt; i + dp[i] {            r = i + dp[i];            p = i;        }        ans += (dp[i] + 1) as u64 / 2;    }    ans}🔗 원본 파일 보기CPP 구현#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdint&gt;#include &lt;algorithm&gt;#include &lt;sstream&gt;using namespace std;string manacher(string&amp; s) {    size_t s_len = s.length();    size_t e_len = s_len * 2 + 1;    vector&lt;char&gt; extended(e_len, 0);    for (size_t i = 0; i &lt; s_len; ++i) {        extended[i * 2 + 1] = s[i];    }    size_t r = 0, p = 0;    vector&lt;size_t&gt; dp(e_len, 0);    for (size_t i = 0; i &lt; e_len; ++i) {        if (i &lt;= r) {            dp[i] = min(dp[p * 2 - i], r - i);        }        while (            (i &gt;= dp[i] + 1) &amp;&amp;             (i + dp[i] + 1 &lt; e_len) &amp;&amp;            (extended[i - dp[i] - 1] == extended[i + dp[i] + 1])        ) {            dp[i] += 1;        }        if (r &lt; i + dp[i]) {            r = i + dp[i];            p = i;        }    }    size_t idx = distance(dp.begin(), max_element(dp.begin(), dp.end()));    stringstream ss;    for (int i = idx - dp[idx] + 1; i &lt; idx + dp[idx]; i += 2) {        ss &lt;&lt; extended[i];    }        return ss.str();}🔗 원본 파일 보기"
  },
  
  {
    "title": "Trie 구현",
    "url": "/posts/Trie/",
    "categories": "Study, Algorithm",
    "tags": "Trie",
    "date": "2025-02-03 14:11:04 +0900",
    





    
    "snippet": "Trie 자료구조 (C++ 구현)문자열을 저장하고 효율적으로 검색하기 위한 트리 기반의 자료구조.  단어 삽입: 단어를 효율적으로 추가할 수 있음.  단어 검색: 저장된 단어가 존재하는지 빠르게 확인할 수 있음.  접두사 검색: 주어진 접두사를 갖는 단어가 존재하는지 탐색할 수 있음.1. TrieNode 구조체Trie의 기본 구성 단위는 TrieNod...",
    "content": "Trie 자료구조 (C++ 구현)문자열을 저장하고 효율적으로 검색하기 위한 트리 기반의 자료구조.  단어 삽입: 단어를 효율적으로 추가할 수 있음.  단어 검색: 저장된 단어가 존재하는지 빠르게 확인할 수 있음.  접두사 검색: 주어진 접두사를 갖는 단어가 존재하는지 탐색할 수 있음.1. TrieNode 구조체Trie의 기본 구성 단위는 TrieNode이다.  children: 알파벳 26개(대문자 ‘A’ ~ ‘Z’)에 대응하는 자식 노드를 저장하는 포인터 배열          TrieNode* children[26]: 각 인덱스는 해당 알파벳에 해당하는 자식 노드 가리킴.        isEnd: 현재 노드가 단어의 끝(종료 노드)인지를 나타내는 값          단어 삽입 시 마지막 문자에 해당하는 노드에서 isEnd를 true로 설정함함.      struct TrieNode {    TrieNode* children[26]; // 26개의 자식 노드    bool isEnd;             // 단어의 끝을 나타내는 플래그    TrieNode() {        isEnd = false;        for (int i = 0; i &lt; 26; i++)             children[i] = nullptr;    }};2. Trie 클래스class Trie {private:    TrieNode* root; // Trie의 루트 노드public:    Trie() {         root = new TrieNode(); // 루트 노드 초기화    }    // ...};3. 메소드 설명3.1. 단어 삽입 (insert)  문자열을 Trie에 삽입한다.  동작 과정:          루트 노드에서 시작.      단어의 각 문자에 대해, 해당 문자를 인덱스(c - 'A')로 변환.      만약 해당 인덱스에 자식 노드가 없다면 새로운 TrieNode를 생성.      해당 자식 노드로 이동.      단어의 마지막 문자까지 처리한 후, 마지막 노드의 isEnd를 true로 설정.      void insert(const string&amp; word) {    TrieNode* node = root;    for (char c : word) {        int index = c - 'A';        if (!node-&gt;children[index]) {            node-&gt;children[index] = new TrieNode();        }        node = node-&gt;children[index];    }    node-&gt;isEnd = true;}3.2. 단어 검색 (search)  Trie에 특정 단어 존재 여부 확인.  동작 과정:          루트 노드에서 시작하여 단어의 각 문자를 따라 이동.      만약 경로 상에 해당 문자를 위한 노드가 없다면 false를 반환.      단어의 모든 문자를 탐색한 후, 마지막 노드의 isEnd가 true이면 단어가 존재함을 의미한다.      bool search(const string&amp; word) {    TrieNode* node = root;    for (char c : word) {        int index = c - 'A';        if (!node-&gt;children[index])             return false;        node = node-&gt;children[index]; // 다음 노드로 이동    }    return node-&gt;isEnd;}3.3. 접두사 검색 (startsWith)  Trie에 특정 접두사로 시작하는 단어가 있는지 확인.  동작 과정:          루트 노드에서 시작하여 접두사의 각 문자를 따라 이동.      만약 경로 상에 해당 문자를 위한 노드가 없다면 false를 반환.      접두사의 모든 문자를 탐색했다면, 해당 경로가 존재함을 의미하므로 true를 반환.      bool startsWith(const string&amp; prefix) {    TrieNode* node = root;    for (char c : prefix) {        int index = c - 'A';        if (!node-&gt;children[index])             return false;        node = node-&gt;children[index];    }    return true;}4. 메모리 관리~Trie() {    deleteNode(root);}private:void deleteNode(TrieNode* node) {    if (!node) return;    for (int i = 0; i &lt; 26; i++) {        deleteNode(node-&gt;children[i]);    }    delete node;}재귀적으로 모든 자식 노드를 해제하여 메모리 누수를 방지.활용 예시  자동완성(Autocomplete): 사용자가 입력한 접두사를 바탕으로 가능한 단어들을 빠르게 검색 가능.  사전 검색: 단어가 존재하는지 여부를 빠르게 판단할 수 있다.  문자열 집합 관리: 문자열들의 집합을 관리할 때 빠른 검색 및 삽입이 필요한 경우 사용.시간 복잡도  삽입 시간 복잡도: O(L), L: 문자열의 길이  탐색 시간 복잡도: O(L)CPP 구현#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct TrieNode {    TrieNode* children[26]; // 26개의 자식 노드    bool isEnd; // 단어의 끝을 나타내는 플래그    TrieNode() {        isEnd = false;        for (int i = 0; i &lt; 26; i++) children[i] = nullptr;    }};class Trie {private:    TrieNode* root;public:    Trie() { root = new TrieNode(); }    // 단어 삽입    void insert(const string&amp; word) {        TrieNode* node = root;        for (char c : word) {            int index = c - 'A';            if (!node-&gt;children[index]) {                node-&gt;children[index] = new TrieNode();            }            node = node-&gt;children[index];        }        node-&gt;isEnd = true;    }    // 단어 검색    bool search(const string&amp; word) {        TrieNode* node = root;        for (char c : word) {            int index = c - 'A';            if (!node-&gt;children[index]) return false;            node = node-&gt;children[index];        }        return node-&gt;isEnd;    }    // 접두사 검색    bool startsWith(const string&amp; prefix) {        TrieNode* node = root;        for (char c : prefix) {            int index = c - 'A';            if (!node-&gt;children[index]) return false;            node = node-&gt;children[index];        }        return true;    }    ~Trie() {        deleteNode(root);    }private:    // 동적 메모리 해제 (트라이 트리 전체 삭제)    void deleteNode(TrieNode* node) {        if (!node) return;        for (int i = 0; i &lt; 26; i++) {            deleteNode(node-&gt;children[i]);        }        delete node;    }};🔗 원본 파일 보기python 구현from typing import Listclass Node:    def __init__(self):        self.next: List[Node | None] = [None] * 26        self.end = Falseclass Trie:    def __init__(self):        self.root = Node()    def insert(self, s: str):        node = self.root        for ch in s:            ch = ord(ch) - ord('a')            if not node.next[ch]:                node.next[ch] = Node()            node = node.next[ch]        node.end = True        def search(self, s:str):        node = self.root        for ch in s:            ch = ord(ch) - ord('a')            if not node.next[ch]:                return False            node = node.next[ch]        return node.end    def print(self):        result = []        self.dfs(self.root, \"\", result)        print(result)    def dfs(self, node, word, result):        if node.end:            result.append(word)        for i in range(26):            if node.next[i]:                self.dfs(node.next[i], word+str(chr(i+ord('a'))), result)🔗 원본 파일 보기"
  },
  
  {
    "title": "게임 보드 관련 잡설",
    "url": "/posts/Bot_note_3/",
    "categories": "Project, Discord_Bot",
    "tags": "Bot",
    "date": "2025-02-02 18:09:53 +0900",
    





    
    "snippet": "점수판과 재생 정보는 board.rs에서 다룸register_channel.rs에서 등록한 텍스트 채널에스레드 생성후 점수판과 재생 정보 embed를 갱신하는 방식고려사항  text channel 등록없이 play 하는 경우  …24-05-22현재 board와 guild_queue가 분리되어 있어 트랙 이벤트가 발생할 때 board에 접근하기 불편함....",
    "content": "점수판과 재생 정보는 board.rs에서 다룸register_channel.rs에서 등록한 텍스트 채널에스레드 생성후 점수판과 재생 정보 embed를 갱신하는 방식고려사항  text channel 등록없이 play 하는 경우  …24-05-22현재 board와 guild_queue가 분리되어 있어 트랙 이벤트가 발생할 때 board에 접근하기 불편함.두 기능은 같이 동작하므로 결합시킬 예정GuildQueue와 Board를 합치는 과정중pub async fn register_channel(&amp;self, channel: GuildChannel) {    let mut inner = self.inner.lock();    let channel_id = channel.id.into();    let http = inner.http.clone();    inner.board.set(http, channel).await;    inner.channel = Some(channel_id);}inner.board.set(http, channel).await; 라인에서 future is not Send as this value is used across an await 에러가 발생함.parking_lot::MutexGuard가 not Send라서 발생하는 것 같은데, GuildQueue의 Mutex를 tokio::sync::Mutex로 변경할지GuildQueue와 Board를 분리할 지 생각해봐야겠다.24-05-23board와 guild_queue를 다음과 같이 결합함. 상기한 문제가 됐던 부분 또한 다음과 같이 수정함.pub struct GuildQueueCore {    // ...    board: Arc&lt;tokio::sync::Mutex&lt;Board&gt;&gt;,}pub async fn register_channel(&amp;self, channel: &amp;GuildChannel) {    let board_lock = {        let mut inner = self.inner.lock();        let channel_id = channel.id.into();        inner.channel = Some(channel_id);        inner.board.clone()    };        let mut board = board_lock.lock().await;    board.set(channel).await;}기존 코드 구조에서 GuildQueue는 동기적으로 동작했으므로 변경을 줄이기 위해 Board만 tokio::sync::Mutex로 감쌈.inner의 MutexGuard는 not Send이기 때문에 블록으로 감싸서 await 구문 전에 drop 시켜줌.음악의 재생과 메세지의 업데이트를 QueueHandler에서 다루기 위해서 하나로 합쳤는데, async/await를 사용하지 않던 부분에 Board를 끼워넣다보니 전체적인 구조가 이상해진 느낌.나중에 고쳐야 할 듯🔗 원본 파일 보기"
  },
  
  {
    "title": "음성 관련",
    "url": "/posts/Bot_note_2/",
    "categories": "Project, Discord_Bot",
    "tags": "Bot",
    "date": "2025-02-02 18:06:00 +0900",
    





    
    "snippet": "구버전에서 dca(Ogg to DCA converter)라고 명명한 ogg packet을 이어붙인 자체 포맷대신 symphonia crate를 사용해 음성 바이트 스트림을 생성함.Input::Lazy 의 FlowYoutubeDl::into()     YoutubeDl::create_async (Compose trait 구현 사항)        Http...",
    "content": "구버전에서 dca(Ogg to DCA converter)라고 명명한 ogg packet을 이어붙인 자체 포맷대신 symphonia crate를 사용해 음성 바이트 스트림을 생성함.Input::Lazy 의 FlowYoutubeDl::into()     YoutubeDl::create_async (Compose trait 구현 사항)        HttpRequest::create_async (Compose trait 구현 사항)            HttpRequest::create_stream                reqwest::Client::get -&gt; reqwest::Response                reqwest::Response::bytes_stream -&gt; Box&lt;tokio_io::StreamReader&gt;                 Box&lt;tokio_io::StreamReader&gt; -&gt; songbird::HttpStream            songbird::HttpStream::stream -&gt; AsyncAdapterStream        songbird::HttpStream -&gt; songbird::AudioStream    return songbird::AudioStream create_stream에서 resume를 이용해서 계속 파일을 받아오는 것 같음.연속된 네트워크 스트림에서 특정 부분만 잘라내는건 어려워보이므로 yt-dlp로 원본을, ffmpeg로 잘라낸 부분을 파일로 저장 후 songbird::File을 이용해서 songbird::Input을 생성songbird::Call과 songbird::Songbird의 메소드 차이점songbird::Call는 한 서버 내의 음성 연결을 담당songbird::Songbird는 내부적으로 DashMap을 사용해 디스코드 서버마다 songbird::Call을 관리connection.rs의 다음 부분에서 1. | let manager = songbird::get(ctx).await.clone(); 2. | // ... 3. | if let Some(call) = manager.get(guild_id) { 4. |    let mut call = call.lock().await; 5. |    if let Some(bot_channel) = call.current_channel() { 6. |        // ...     7. |    } else { 8. |        match call.join(user_channel).await { 9. |            Ok(_) =&gt; Ok(ConnectionSuccessCode::NewConnection),10. |            Err(why) =&gt; Err(ConnectionErrorCode::JoinError(why))11. |        }12. |    }13. |    // ...14. | }기존에 8번 라인의 call.join(user_channel).await 대신 manager.join(guild_id, user_channel).await 사용했었는데 이 경우 DeadLock 발생함.이유는  4번 라인에서 call에 대한 Mutex 획득  8번 라인 실행 시 해당 흐름은 block 후 manager.join이 반환될 때 까지 block  manager.join에서 다시 call 에 대한 Mutex 획득 시도 후 잠겨 있으므로 block 됨  따라서 manager.join이 반환되지 못하고, 호출자도 block 되어 있게 됨일반 채팅으로 재생중인 곡을 스킵하려면  이벤트 핸들러에서 async fn message(&amp;self, ctx: Context, msg: Message)함수로 채팅 확인  채팅이 특정 채널에서 발생했는지 확인  채팅이 재생 중인 곡의 키워드랑 일치하는지 확인2번에서 특정 채널을 확인하기 위해 명령어로 확인할 채널을 등록하도록 함이는 CommandDataOptionValue에 Channel(ChannelId) 필드가 존재하므로 가능할 것으로 보임재생 중인 곡의 키워드와 채팅 채널을 확인하기 위해 TrackQueue를 수정하여 GuildQueue를 만듦🔗 원본 파일 보기"
  },
  
  {
    "title": "Rust 동시성 문제",
    "url": "/posts/Bot_note_1/",
    "categories": "Project, Discord_Bot",
    "tags": "Concurrency, Bot",
    "date": "2025-02-02 17:57:07 +0900",
    





    
    "snippet": "      std::process::Stdio::piped() 는 새로운 파이프를 생성한다. std::process::Command::stdin(Stdio::piped()) 같은 식으로 사용하면 stdin이 생성된 파이프로 대체 되는 식.CommandObject.stdin.take().unwrap()으로 해당 파이프 디스크립터를 가져올 수 있다.   ...",
    "content": "      std::process::Stdio::piped() 는 새로운 파이프를 생성한다. std::process::Command::stdin(Stdio::piped()) 같은 식으로 사용하면 stdin이 생성된 파이프로 대체 되는 식.CommandObject.stdin.take().unwrap()으로 해당 파이프 디스크립터를 가져올 수 있다.        Command::spawn()으로 생성된 Child 객체는 wait[_with_output]나 kill 호출 전까지 완료/종료되지 않는다.만약 파일을 저장하는 작업 이후 연속해서 다른 Command 가 그 파일을 읽으려 한다면 파일이 생성되지 않아 정상적으로 작동하지 않는다. 버퍼 관련 문제인듯따라서 wait 를 사용해 프로세스를 기다리면 파일이 저장되어 사용 가능하다.하지만 pipe로 출력과 입력을 연결하면 출력버퍼에서 직접 스트림을 읽을 수 있기 때문에 wait가 필요 없다.        파이프 관련하여  만약 Command::spawn()으로 프로세스를 하나 생성 할 때, 이 프로세스의 stdin과 stdout을 모두 파이프 처리했을 때 deadlock이 발생할 수 있다.예를 들어          use std::{          io::{Read, Write},          process::{Command, Stdio},      };      let mut ffmpeg = Command::new(\"ffmpeg\")          .args(&amp;[\"-i\", \"-\"])          .args(&amp;FFMPEG_ARGS)          .arg(\"-\")          .stdin(Stdio::piped())          .stdout(Stdio::piped())          .spawn()          .unwrap();      let mut stdin = ffmpeg.stdin.take().unwrap();      stdin.write_all(&amp;data).unwrap();              let mut output = vec![];      let mut stdout = ffmpeg.stdout.take().unwrap();      stdout.read_to_end(&amp;mut output).unwrap();              ffmpeg.wait().unwrap();        다음과 같은 코드가 있을 때, stdin.write_all(&amp;data).unwrap();부분에서 deadlock이 발생할 수 있다.가능한 시나리오는 다음과 같다.          Rust 프로세스가 stdin.write_all(&amp;data)을 실행함      std::io는 Blocking I/O이기 때문에 Rust 프로세스는 데이터를 전부 쓰기 전까지 write_all 에서 블록된다.      ffmpeg는 stdin에서 데이터를 소비하여 stdout에 데이터를 쓴다.      ffmpeg가 작업을 진행하여 stdout가 가득 차게 되면 ffmpeg도 block된다.      ffmpeg가 깨어나려면 stdout애서 데이터가 소비 되어야 한다.      그러나 ffmpeg가 Block 됐기 때문에 stdin에서 데이터를 소비할 수 없어 Rust 프로세스 또한 계속 write_all에서 Block 되어 있다.      따라서 실행 흐름이 stdout.read_to_end(&amp;mut output).unwrap();까지 도달하지 못해 ffmpeg의 stdout을 비워 줄 수 없으므로 두 프로세스 모두 Block 되는 deadlock에 빠지게 된다.        이를 해결하려면   stdin.write_all(&amp;data).unwrap();를 tokio::spawn으로 감싸 task를 분리해주면 된다.      tokio::spawn(async move {      stdin.write_all(&amp;data).await.unwrap();  });        이렇게 하면 write_all은 여전히 block되지만 다른 task에서 block되므로 기존의 task는 stdout.read_to_end(&amp;mut output).unwrap();까지 도달하여 stdout을 소비하여 spawn된 프로세스를 계속 실행시킬 수 있기 때문에 deadlock이 발생하지 않게 된다.    단, 이를 위해서 기존의 std::process::Command를 tokio::process::Command로 바꿔야한다.  tokio::spawn은 Future에 대해 동작하기 때문인데, std::io는 Future가 될 수 없기 때문이다.    다른 방법으로는 파이프를 사용하지 않고 파일로 저장한 후 스폰 할 프로세스에서 파일을 처리하도록 하는 것도 가능하다.  Arc 타입에 관해  원자적으로 동작하는 복수의 소유권을 가지는 스마트 포인터  Arc::clone 하면 값을 clone하는게 아니라 소유권을 가져오면서 참조 카운팅을 늘린다.  단 해당 참조는 immutable하므로 Mutex나 RwLock를 감싸서 Arc&lt;Mutex&lt;T&gt;&gt;로 가변성을 얻는 식으로 많이 사용한다.음성 채널 연결을 관리하는 부분을 connection handler로 분리했을 때let manager = songbird::get(ctx)    .await    .expect(\"Songbird Voice client placed in at initialisation.\");이부분에서 future cannot be sent between threads safely 에러가 발생했다.찾아보니let voice_states: &amp;HashMap&lt;UserId, VoiceState&gt; = &amp;guild_id    .to_guild_cached(ctx)    .unwrap()    .voice_states;let user_channel = voice_states    .get(&amp;command.user.id)    .and_then(|voice_state| voice_state.channel_id);to_guild_cached로 가져오는 CacheRef가 NotSend였기 때문에 songbird::get(ctx).await 호출 시점에도 voice_states가 살아있어서 발생한 문제였다.let user_channel = {    // CacheRef is not Send    let voice_states: &amp;HashMap&lt;UserId, VoiceState&gt; = &amp;guild_id        .to_guild_cached(ctx)        .unwrap()        .voice_states;    voice_states        .get(&amp;command.user.id)        .and_then(|voice_state| voice_state.channel_id)}; // So must drop here그래서 다음과 같이 블록을 만들어서 voice_states를 블록 내에서만 사용하도록 수정했다.🔗 원본 파일 보기"
  },
  
  {
    "title": "고정 크기 Heap 구현",
    "url": "/posts/Heap_with_Array/",
    "categories": "Study, Algorithm",
    "tags": "Heap",
    "date": "2025-01-31 07:49:01 +0900",
    





    
    "snippet": "힙(Heap)완전 이진 트리(Complete Binary Tree) 기반의 자료구조  최댓값 또는 최솟값을 빠르게 접근 및 관리하는 데 사용된다.1. 힙의 종류🔹 최대 힙 (Max Heap)  부모 노드는 항상 자식보다 크거나 같음  루트 노드에는 가장 큰 값이 위치함  삽입(push)과 삭제(pop) 후에도 이 속성이 유지됨✅ 예시 (최대 힙)   ...",
    "content": "힙(Heap)완전 이진 트리(Complete Binary Tree) 기반의 자료구조  최댓값 또는 최솟값을 빠르게 접근 및 관리하는 데 사용된다.1. 힙의 종류🔹 최대 힙 (Max Heap)  부모 노드는 항상 자식보다 크거나 같음  루트 노드에는 가장 큰 값이 위치함  삽입(push)과 삭제(pop) 후에도 이 속성이 유지됨✅ 예시 (최대 힙)        50       /  \\     30    40    /  \\   /   10  20 35  top()을 하면 50이 반환됨  pop()을 하면 50이 제거되고, 힙 속성이 유지됨🔹 최소 힙 (Min Heap)  부모 노드는 항상 자식보다 작거나 같음  루트 노드에는 가장 작은 값이 위치함✅ 예시 (최소 힙)        10       /  \\     20    30    /  \\   /   50  40 35  top()을 하면 10이 반환됨  pop()을 하면 10이 제거되고, 힙 속성이 유지됨2. 힙의 특징  완전 이진 트리(Complete Binary Tree)          트리의 모든 레벨이 완전히 채워져 있어야 함      마지막 레벨만 예외적으로 왼쪽부터 채워짐        힙 속성(Heap Property) 유지          최대 힙: 부모 노드 ≥ 자식 노드      최소 힙: 부모 노드 ≤ 자식 노드        빠른 삽입과 삭제          O(log N)의 시간 복잡도를 가짐      3. 힙의 연산🔹 삽입 (push, insert)      새로운 원소를 트리의 마지막 위치에 추가    부모 노드와 비교하여 힙 속성이 유지될 때까지 Swap (Heapify-up)  시간 복잡도: O(log N)✅ 예제 (최대 힙, push(45))초기 상태:        50       /  \\     30    40    /  \\   /   10  20 35(1) 45를 마지막에 추가:        50       /  \\     30    40    /  \\   / \\   10  20 35  45(2) 부모(40)와 비교 후 Swap:        50       /  \\     30    45    /  \\   / \\   10  20 35  40⏳ 시간 복잡도: O(log N)🔹 삭제 (pop, remove)  루트 노드를 제거  마지막 원소를 루트로 이동  자식 노드 중 더 큰 값과 Swap하여 힙 속성을 유지 (Heapify-down)  시간 복잡도: O(log N)✅ 예제 (최대 힙, pop())초기 상태:        50       /  \\     30    40    /  \\   / \\   10  20 35  45(1) 루트(50) 제거 후, 마지막 노드(45) 이동:        45       /  \\     30    40    /  \\   /   10  20 35(2) 자식 중 더 큰 값(40)과 Swap:        45       /  \\     30    40    /  \\   /   10  20 35⏳ 시간 복잡도: O(log N)4. 힙의 구현 방법🔹 배열(Array) 기반 힙 구현힙은 배열을 사용하여 구현.노드의 인덱스를 활용하여 부모/자식 노드를 계산할 수 있다다.            노드      인덱스      부모 노드      왼쪽 자식      오른쪽 자식                  Root      1      -      2      3              A      2      1      4      5              B      3      1      6      7      수식  부모 노드: parent(i) = i / 2  왼쪽 자식: left(i) = 2 * i  오른쪽 자식: right(i) = 2 * i + 15. 힙의 활용✅ 우선순위 큐 (Priority Queue)  std::priority_queue&lt;T&gt; (C++ STL) 내부적으로 힙으로 구현  O(log N)에 삽입/삭제 가능✅ 힙 정렬 (Heap Sort)  O(N log N)의 시간 복잡도  std::make_heap(), std::sort_heap() 함수 활용 가능✅ 다익스트라 알고리즘 (Dijkstra’s Algorithm)  그래프 최단 경로를 찾을 때 우선순위 큐를 사용하여 O(E log V)에 최적화 가능6. C++ 구현#include &lt;cstdlib&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define MAX_LEN 1001template&lt;typename T&gt;struct heap {    T *v;    int cnt;    int max_size;    const bool is_max;    heap(bool is_max, int size) : is_max(is_max), max_size(size) {        v = new T[size+1];        cnt = 0;    }    ~heap() {        delete[] v;    }    void clear() {         cnt = 0;     }    T&amp; operator[] (int index) {        if (index &lt; 1 || index &gt; cnt) throw out_of_range(\"Index out of range\");        return v[index];    }    int size() {        return cnt;    }    T top() {        if (cnt &lt; 1) throw out_of_range(\"heap is empty\");         return v[1];    }    bool empty() {        return cnt == 0;    }    void push(const T&amp; x) {        if (cnt &gt;= max_size) throw out_of_range(\"heap is full\");        v[++cnt] = x;        int cur = cnt;        int parent = cnt / 2;        while (cur &gt; 1 &amp;&amp; cmp(v[cur], v[parent])) {            swap(v[cur], v[parent]);            cur = parent;            parent /= 2;        }    }    void push(T&amp;&amp; x) {        if (cnt &gt;= max_size) throw out_of_range(\"heap is full\");        v[++cnt] = move(x);        int cur = cnt;        int parent = cnt / 2;        while (cur &gt; 1 &amp;&amp; cmp(v[cur], v[parent])) {            swap(v[cur], v[parent]);            cur = parent;            parent /= 2;        }    }    void pop() {        if (cnt &lt; 1) throw out_of_range(\"heap is empty\");         swap(v[cnt--], v[1]);        int cur = 1, child;        while (true) {            child = cur * 2;            if (child &gt; cnt) break;            if (child+1 &lt;= cnt &amp;&amp; cmp(v[child+1], v[child])) child += 1;            if (!cmp(v[child], v[cur])) break;            swap(v[cur], v[child]);            cur = child;        }    }    bool cmp(T&amp; a, T&amp; b) {        return is_max ? a &gt; b : a &lt; b;    }};🔗 원본 파일 보기"
  },
  
  {
    "title": "Jekyll 시행 착오들 정리",
    "url": "/posts/Trial_Error/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2025-01-30 14:57:40 +0900",
    





    
    "snippet": "Github Pages 시행착오들  링크는 https:// 로 시작해야 htmlproofer 검사에서 오류가 나지 않음      markdown 문서에서 상대경로로 포함된 리소스는 절대 경로로 변환해줘야 함.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/ma...",
    "content": "Github Pages 시행착오들  링크는 https:// 로 시작해야 htmlproofer 검사에서 오류가 나지 않음      markdown 문서에서 상대경로로 포함된 리소스는 절대 경로로 변환해줘야 함.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md\" %} {% assign img_url = remote_url | remove: \"lecture.md\" | append: \"capture/\" %} {% capture remote_content %} &lt;!--remote_content 변수에 remote resource 저장 --&gt;     {% remote_include https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md %} {% endcapture %} {{ remote_content  &lt;!--remote_content에서 상대경로로 포함된 리소스를 절대 경로로 변환 --&gt; | replace: './capture/', img_url  }}      🔗 원본 파일 보기"
  },
  
  {
    "title": "Multi-level Feedack Queue 구현하기",
    "url": "/posts/MFQ/",
    "categories": "Project, OS",
    "tags": "OS, MFQ",
    "date": "2025-01-22 17:30:53 +0900",
    





    
    "snippet": "멀티 레벨 피드백 큐(MFQ) 스케줄링코드 구조  데이터 구조          Process 구조체: 각 프로세스를 표현하는 구조체.      waitq, finishedq, global_io_q: 대기 큐, 완료 큐, 글로벌 I/O 큐.        스케줄러 클래스          SchedulerBase (추상 클래스): 스케줄러의 기본 인터페이스...",
    "content": "멀티 레벨 피드백 큐(MFQ) 스케줄링코드 구조  데이터 구조          Process 구조체: 각 프로세스를 표현하는 구조체.      waitq, finishedq, global_io_q: 대기 큐, 완료 큐, 글로벌 I/O 큐.        스케줄러 클래스          SchedulerBase (추상 클래스): 스케줄러의 기본 인터페이스 정의.      Scheduler&lt;Container&gt; (템플릿 클래스): 특정 컨테이너(RR, SRTN, FCFS)를 기반으로 스케줄링을 수행.        함수          parse_process: 입력 파일을 파싱하여 프로세스를 생성하고 대기 큐에 삽입.      add_process: 프로세스를 적절한 큐로 삽입.      process_io_queue: I/O 큐에서 작업을 수행하고 완료된 프로세스를 다시 실행 큐에 추가.      run: 전체 스케줄링 시뮬레이션 실행.      print_results: 최종 결과 출력.      print_queue_status: 현재 큐 상태 출력.      코드 동작 방식1. 초기화 단계  parse_process 함수를 통해 입력 파일에서 프로세스를 읽어 waitq에 저장.  프로세스는 도착 시간(arrival_time)을 기준으로 정렬됨.2. 실행 단계run 함수의 반복 루프에서 다음 단계가 수행된다:  새로운 프로세스 추가          waitq에서 현재 cpu_clock과 일치하는 도착 시간이 있는 프로세스를 적절한 우선순위 큐(Q0~Q3)에 추가.        CPU 스케줄링          우선순위가 높은 큐부터 실행(Q0 → Q1 → Q2 → Q3).      스케줄러의 run 함수 호출.        스케줄링 알고리즘 적용          Q0 (RR, TQ=2):                  프로세스가 최대 2개의 타임 퀀텀 동안 실행.          타임 퀀텀 초과 시 Q1로 이동.          CPU burst가 완료되면 I/O 수행.                    Q1 (RR, TQ=6):                  최대 6개의 타임 퀀텀 적용, 초과 시 Q2로 이동.                    Q2 (SRTN):                  남은 CPU burst 시간이 가장 짧은 프로세스를 우선 실행.          선점될 경우 Q3로 이동.                    Q3 (FCFS):                  선입선출(FIFO) 방식으로 처리.                      I/O 처리          global_io_q에서 프로세스를 처리하며, 해당 프로세스의 I/O 시간이 감소.      I/O가 완료되면 원래 큐보다 높은 우선순위 큐로 복귀.        프로세스 종료 확인          모든 CPU burst와 I/O가 완료되면 finishedq로 이동.      3. 최종 결과 출력print_results 함수를 통해 다음 항목을 출력한다:  프로세스의 도착 시간, 종료 시간, 반환 시간(Turnaround Time), 대기 시간(Waiting Time).  평균 반환 시간 및 대기 시간.실행 과정 예시입력 예시31 0 0 2 6 3 72 1 1 1 83 2 2 3 4 3 5 1 4출력 예시[Scheduling Results]---------------------------------------------------  PID |    Arrival |     Finish | Turnaround |   Waiting---------------------------------------------------    2 |          1 |         14 |         13 |          5    1 |          0 |         21 |         21 |          8    3 |          2 |         34 |         32 |         19---------------------------------------------------Average Turnaround Time: 22Average Waiting Time: 10.6667주요 설계 고려사항  큐 간 이동 규칙:          CPU burst가 끝나면 I/O 작업을 수행한 후 적절한 큐로 이동.      타임 퀀텀이 만료되면 하위 큐로 이동.      SRTN 큐에서는 새로운 프로세스가 들어올 때 선점 발생.        클럭 증가 규칙:          프로세스가 실행될 때만 cpu_clock이 증가하도록 구현.        I/O 처리:          I/O 큐는 별도의 글로벌 큐로 유지되며 프로세스는 일정 시간 후 실행 큐로 돌아옴.        프로세스 완료 처리:          모든 작업이 완료되면 finishedq로 이동하고 완료 시간을 기록.      🔗 원본 파일 보기"
  },
  
  {
    "title": "태양계 시뮬레이션",
    "url": "/posts/Solar_System/",
    "categories": "Project, Graphics",
    "tags": "OpenGL, Solar-System",
    "date": "2025-01-19 20:12:54 +0900",
    





    
    "snippet": "구현데이터 초기화행성과 링의 데이터를 초기화하는 작업은 user_init() 함수에서 이루어집니다. 이 함수는 프로그램이 시작될 때 호출되어 필요한 데이터와 그래픽 리소스를 준비합니다.1. 초기 위치 설정      init_pos 초기화:    for (int i = 0; i &lt; NUM_SPHERE; i++) {    init_pos[i] = (...",
    "content": "구현데이터 초기화행성과 링의 데이터를 초기화하는 작업은 user_init() 함수에서 이루어집니다. 이 함수는 프로그램이 시작될 때 호출되어 필요한 데이터와 그래픽 리소스를 준비합니다.1. 초기 위치 설정      init_pos 초기화:    for (int i = 0; i &lt; NUM_SPHERE; i++) {    init_pos[i] = (float)rand() / (float)RAND_MAX * 2 * PI;}              각 행성의 초기 공전 위치를 랜덤 값으로 설정.      초기 위치는 [0, 2π] 사이의 값으로, 행성이 시뮬레이션 시작 시 서로 다른 위치에 배치되도록 보장.      2. OpenGL 초기화      텍스처 로드:    glGenTextures(19, textures);for (uint i = 0; i &lt; 19; i++) {    glBindTexture(GL_TEXTURE_2D, textures[i]);    int width, height, comp = 3;    unsigned char* pimage0 = stbi_load(meshes[i], &amp;width, &amp;height, &amp;comp, 3);    // 텍스처 데이터를 GPU에 업로드    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pimage);    glGenerateMipmap(GL_TEXTURE_2D);    // 텍스처 파라미터 설정    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);}              각 행성에 대한 텍스처 이미지(meshes 배열)를 읽어들여 OpenGL 텍스처로 설정.            정점 데이터 초기화:    update_circle_vertices(NUM_TESS);update_vertex_buffer(NUM_TESS);update_ring_vertices(NUM_TESS);update_ring_vertex_buffer(NUM_TESS);              행성과 링을 구성하는 정점 데이터를 생성하고, 이를 GPU 버퍼에 업로드.              행성은 구체로, 링은 원형의 평면으로 정의.            update_circle_vertices(NUM_TESS)                  구체의 정점 데이터 생성                    for (int i = 0; i &lt;= NUM_TESS; i++) {        float theta = PI * i / NUM_TESS; // 위도        for (int j = 0; j &lt;= NUM_TESS; j++) {            float p = PI * 2.0f / float(NUM_TESS) * float(j); // 경도            float x = sin(theta) * cos(p); float y = sin(theta) * sin(p); float z = cos(theta);            vertex_list.push_back({ vec3(x, y, z), vec3(x, y, z), vec2((p / (2 * PI)), (1.0f - (theta / PI))) });            if (i == 0 || i == NUM_TESS) break;        }    }                          구면좌표계 설명          위도(theta)와 경도(p)를 이용하여 구체 표면의 정점 좌표 (x, y, z)를 계산.          정점의 위치와 법선 벡터(normal)는 동일하게 (x, y, z)로 설정 (구의 중심으로부터의 방향).          텍스처 좌표(texcoord):          u = p / (2π): 경도에 따른 수평 텍스처 좌표.          v = 1 - theta / π: 위도에 따른 수직 텍스처 좌표.          극지방(위도 theta = 0 또는 theta = π)의 정점은 반복되지 않도록 처리.                if (i == 0 || i == NUM_TESS) break;                    2. update_vertex_buffer(NUM_TESS)                  구체의 정점 데이터를 GPU로 전송                      update_circle_vertices()에서 생성된 정점 데이터를 GPU에 업로드하여 렌더링에 사용.                                이전 버퍼 삭제:              if (vertex_buffer) glDeleteBuffers(1, &amp;vertex_buffer); vertex_buffer = 0;  if (index_buffer) glDeleteBuffers(1, &amp;index_buffer); index_buffer = 0;                                      이전에 사용했던 정점 및 인덱스 버퍼를 삭제하여 메모리 낭비를 방지.                                인덱스 배열 생성:                          삼각형으로 구를 렌더링하기 위해 인덱스 리스트를 생성.                          index_list.clear();  for (uint i = 0; i &lt; N; i++) {      index_list.push_back(0);      index_list.push_back(i + 1);      index_list.push_back(i + 2);  }  uint k;  for (k = 1; k &lt; (N + 1) * (N - 2); k += (N + 1)) {      for (uint j = k; j &lt; k + N; j++) {          index_list.push_back(j);          index_list.push_back(j + N + 1);          index_list.push_back(j + N + 2);          index_list.push_back(j);          index_list.push_back(j + N + 2);          index_list.push_back(j + 1);      }  }  for (uint i = k; i &lt; k + N; i++) {      index_list.push_back(i);      index_list.push_back(k + 1 + N);      index_list.push_back(i + 1);  }                                삼각형을 구성하는 정점의 인덱스를 정의:                          구의 각 위도와 경도 사이의 사각형을 두 개의 삼각형으로 분할.              각 삼각형은 세 개의 정점 인덱스로 정의.                                            GPU에 버퍼 업로드:            glGenBuffers(1, &amp;vertex_buffer);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);glBufferData(GL_ARRAY_BUFFER, sizeof(vertex)*vertex_list.size(), &amp;vertex_list[0], GL_STATIC_DRAW);glGenBuffers(1, &amp;index_buffer);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(uint)*index_list.size(), &amp;index_list[0], GL_STATIC_DRAW);                                      생성된 정점(vertex_list)과 인덱스(index_list) 데이터를 GPU로 전송.                                          3. update_ring_vertices(NUM_TESS)                  링(고리)의 정점 데이터 생성                          링은 평면에 그려짐.                                링의 정점 계산:                ring_vertex_list.clear();for (uint i = 0; i &lt;= N; i++) {    float theta = 2.0f * PI * i / float(N); // 원형 각도    float x = cos(theta); float y = sin(theta);    ring_vertex_list.push_back({ vec3(0, 0, 0), vec3(x, y, 0), vec2(0, 0) });   // 내부 원    ring_vertex_list.push_back({ vec3(x, y, 0), vec3(x, y, 0), vec2(1, 0) });   // 외부 원}                          링의 정점은 내부 원과 외부 원의 좌표로 구성.          vec3(x, y, 0)은 각도를 기준으로 계산된 정점의 위치.                    4. update_ring_vertex_buffer(NUM_TESS)                              링 정점 데이터를 GPU로 전송                                앞면(정면) 정의:                          ring_index_list.push_back(2 * i);ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1) + 1);                                      여기서 정의된 삼각형은 링의 앞면(시계 방향)을 그림.                                뒷면 정의:                          ring_index_list.push_back(2 * i);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * i + 1);ring_index_list.push_back(2 * (i + 1));ring_index_list.push_back(2 * (i + 1) + 1);ring_index_list.push_back(2 * i + 1);                                      여기서는 앞면 삼각형과 동일한 영역을 반대 방향(반시계 방향)으로 정의하여 뒷면을 그림.                                OpenGL 기본 설정에서는 삼각형의 정점 연결 순서(시계 방향 또는 반시계 방향)에 따라앞면과 뒷면을 구분하기 때문에 양면 모두 렌더링하려면 두 방향의 삼각형을 각각 정의해야 한다.                              3. 카메라와 조명 설정      카메라 초기화:      cam.eye = vec3(2000, 0, 0); // 초기 카메라 위치  cam.at = vec3(0, 0, 0);     // 카메라가 바라보는 지점  cam.up = vec3(0, 0, 1);     // 위쪽 방향              카메라는 태양계 전체를 관찰할 수 있도록 배치.            조명 설정:      light.position = vec4(0.0f, 0.0f, 0.0f, 1.0f); // 태양을 조명 위치로 설정  light.ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f);  light.diffuse = vec4(0.8f, 0.8f, 0.8f, 1.0f);  light.specular = vec4(1.0f, 1.0f, 1.0f, 1.0f);              태양을 광원의 위치로 설정하며, 환경광, 난반사, 정반사를 구성.      데이터 업데이트업데이트 작업은 매 프레임마다 호출되는 update() 함수에서 수행됨.이 함수는 시간(t)에 따라 행성의 위치와 회전 상태를 동적으로 계산한다.1. 시간 계산      시간 관리:      if (!isPause) t = float(glfwGetTime()) - bt;  else bt = float(glfwGetTime()) - t;              glfwGetTime()을 사용하여 시뮬레이션이 시작된 이후의 경과 시간을 얻음.      isPause 변수로 애니메이션을 일시 정지하거나 재개 가능.      2. 공전 위치 계산      공전 속도:    speed = t * 100 / radius[i];              공전 속도는 행성의 크기(radius[i])에 반비례하여 계산.      이는 행성의 반지름이 클수록 공전 속도가 느려짐을 의미.            위치 변환:    mat4 trans_mat = {    cosf(speed), -sinf(speed), 0, 0,    sinf(speed),  cosf(speed), 0, 0,    0,            0,           1, 0,    0,            0,           0, 1};vec3 temp_pos = vec3(0, 1, 0); temp_pos = mat3(trans_mat) * temp_pos;temp_pos *= rot_rad[i];              행성의 공전 운동은 원형 회전 행렬(trans_mat) 을 사용해 계산.      공전 반지름(rot_rad[i])을 곱하여 행성이 중심체로부터의 위치를 결정.      3. 자전 운동 계산      회전 행렬:    mat4 rot_mat = {    cosf(speed), -sinf(speed), 0, 0,    sinf(speed),  cosf(speed), 0, 0,    0,            0,           1, 0,    0,            0,           0, 1};rot_mat = mat4::rotate(vec3(1, 0, 0), axis[i]) * rot_mat;              자전 운동은 행성의 자전축(axis[i])을 기준으로 한 회전으로 계산.      행성의 회전 상태는 행성 표면에 텍스처를 적용할 때 사용.      4. 링 데이터 업데이트      링 위치 계산:    float speed = t * 10 / radius[i + 6];vec3 temp_pos = vec3(offset[(i + 6) * 3 + 0], offset[(i + 6) * 3 + 1], offset[(i + 6) * 3 + 2]);memcpy(ring_offset + i * 3, (float*)temp_pos, 3 * sizeof(float));              링의 위치는 해당 행성의 공전 위치와 동기화.      링의 회전 상태는 별도로 계산하여 회전 효과를 부여.      5. 셰이더에 데이터 전달      행성 데이터 업데이트:    glUniform1fv(glGetUniformLocation(program, \"radius\"), NUM_SPHERE, radius);glUniformMatrix4fv(glGetUniformLocation(program, \"rotate_mat\"), NUM_SPHERE, GL_TRUE, rotate_mat);glUniform3fv(glGetUniformLocation(program, \"location\"), NUM_SPHERE, offset);              각 행성의 크기(radius), 위치(offset), 회전 상태(rotate_mat)를 GLSL 셰이더로 전달.            링 데이터 업데이트:    glUniform1fv(glGetUniformLocation(program, \"radius\"), 4, ring_radius);glUniformMatrix4fv(glGetUniformLocation(program, \"rotate_mat\"), 2, GL_TRUE, rotate_mat);glUniform3fv(glGetUniformLocation(program, \"location\"), 2, ring_offset);      카메라 조작  카메라 회전: 카메라가 특정 축을 중심으로 회전.  줌(확대/축소): 카메라와 대상 간의 거리를 조절.  패닝(panning): 카메라의 위치를 평행 이동.1. mouse 함수: 마우스 입력 처리사용자가 버튼을 클릭하거나 놓을 때 호출.if (button == GLFW_MOUSE_BUTTON_LEFT || button == GLFW_MOUSE_BUTTON_MIDDLE || button == GLFW_MOUSE_BUTTON_RIGHT) {    dvec2 pos; glfwGetCursorPos(window, &amp;pos.x, &amp;pos.y);    vec2 npos = vec2(float(pos.x) / float(window_size.x - 1), float(pos.y) / float(window_size.y - 1));    prev = npos;                 // 마우스 이전 위치 저장    prev_at = cam.at;            // 카메라가 바라보는 대상 저장    prev_eye = cam.eye;          // 카메라 위치 저장    prev_pan = panning;          // 이전 패닝 변환 저장    prev_view = cam.view_matrix; // 이전 뷰 행렬 저장    if (action == GLFW_PRESS) {        if (button == GLFW_MOUSE_BUTTON_MIDDLE) key_ctrl = true;        if (button == GLFW_MOUSE_BUTTON_RIGHT) key_shift = true;        tb.begin(cam.view_matrix, npos.x, npos.y); // 트랙볼 초기화        prev_mouse = npos;    } else if (action == GLFW_RELEASE) {        if (button == GLFW_MOUSE_BUTTON_MIDDLE) key_ctrl = false;        if (button == GLFW_MOUSE_BUTTON_RIGHT) key_shift = false;        tb.end(); // 트랙볼 추적 종료    }}2. motion 함수: 마우스 이동 처리if(!tb.is_tracking()) return;vec2 npos = vec2( float(x)/float(window_size.x-1), float(y)/float(window_size.y-1) );if (key_shift) { // 줌    float rate = (npos.y - prev_mouse.y);    if (rate &gt;= 0.99f) rate = 0.99f;    cam.eye = (1 - rate) * prev_eye + rate * cam.at; // 카메라와 대상 간 거리 조정    cam.view_matrix = mat4::look_at(cam.eye, cam.at, cam.up);}else if (key_ctrl) {    // 평행 이동 변환    panning = mat4::translate((npos.x - prev.x) * 300, (prev.y - npos.y) * 300, 0);    cam.view_matrix = panning * prev_view;    cam.eye = ((mat3)cam.view_matrix).inverse() * -vec3(cam.view_matrix.at(3), cam.view_matrix.at(7), cam.view_matrix.at(11));    cam.at = (cam.eye - prev_eye) + prev_at; // 대상 위치 갱신}else {    // 트랙볼 업데이트    cam.view_matrix = tb.update(npos.x, npos.y, cam.at);    cam.eye = ((mat3)cam.view_matrix).inverse() * -vec3(cam.view_matrix.at(3), cam.view_matrix.at(7), cam.view_matrix.at(11));    vec3 u = vec3(cam.view_matrix._11, cam.view_matrix._12, cam.view_matrix._13);    vec3 n = vec3(cam.view_matrix._31, cam.view_matrix._32, cam.view_matrix._33);    cam.up = n.cross(u); // 새로운 상단 벡터 계산}기능  줌:          마우스 이동의 Y축 변화량으로 줌 비율(rate)을 계산.      카메라의 위치 cam.eye를 조정하여 대상 cam.at과의 거리를 변경.        패닝 모드:          마우스 이동의 X, Y 변화량으로 카메라를 평행 이동.      이동 행렬 panning을 생성하여 카메라의 뷰 행렬에 적용.      카메라 위치(cam.eye)와 대상(cam.at)을 갱신.        회전 모드:          트랙볼(trackball)을 사용해 카메라 회전 구현.      트랙볼은 마우스 이동에 따라 카메라의 뷰 행렬을 회전 변환.      새로운 뷰 행렬(cam.view_matrix)과 카메라 위치(cam.eye), 상단 벡터(cam.up)를 계산.      🔗 원본 파일 보기"
  },
  
  {
    "title": "미니 쉘 만들기",
    "url": "/posts/Swsh/",
    "categories": "Project, C_CPP",
    "tags": "mini_shell",
    "date": "2025-01-10 17:01:45 +0900",
    





    
    "snippet": "미니쉘 (swsh) 동작 과정1. 초기 설정1.1 환경 변수 설정  custom_binary = \"./commands/bin:\"을 기존 PATH 환경 변수와 합쳐서 새로운 PATH를 설정한다.  이를 통해 사용자가 실행 파일을 ./commands/bin/ 디렉토리에서 실행할 수 있도록 함.1.2 시그널 핸들링  SIGINT (Ctrl+C)와 SIGTS...",
    "content": "미니쉘 (swsh) 동작 과정1. 초기 설정1.1 환경 변수 설정  custom_binary = \"./commands/bin:\"을 기존 PATH 환경 변수와 합쳐서 새로운 PATH를 설정한다.  이를 통해 사용자가 실행 파일을 ./commands/bin/ 디렉토리에서 실행할 수 있도록 함.1.2 시그널 핸들링  SIGINT (Ctrl+C)와 SIGTSTP (Ctrl+Z)를 무시하도록 설정.  SIGCHLD 시그널을 처리하여 종료된 자식 프로세스를 정리하는 핸들러 chld_handler 등록.2. 입력 및 파싱2.1 사용자 입력 처리  read(0, input, 256)을 이용해 최대 256바이트까지 입력을 읽음.  입력을 split_commands(input, &amp;cmd_cnt)로 분리하여 명령어 목록을 생성.2.2 명령어 파싱 (argparse.c)  split_commands 함수:          | 기호를 기준으로 명령어를 여러 개로 분리함.      parse_redirection을 사용해 &gt;, &lt;, &gt;&gt; 등 입출력 리다이렉션을 처리.      parse_command를 통해 명령어와 인자를 파싱하여 COMMAND 구조체에 저장.      3. 명령 실행3.1 파이프 설정  명령어 개수(cmd_cnt)를 확인하고 필요하면 pipe(pipe_fds)를 생성.  prev_pipe_fd를 이용하여 이전 명령의 출력을 현재 명령의 입력으로 연결.3.2 명령 실행 과정  각 명령을 fork()하여 자식 프로세스를 생성한 후 실행.  setup_redirection을 이용해 입력/출력 리다이렉션을 처리.  execvp(cmd-&gt;cmd, cmd-&gt;argv)를 호출하여 실행 파일을 실행.  파이프의 읽기/쓰기 파일 디스크립터를 적절히 닫음.  waitpid(-1, &amp;status, 0)를 이용해 자식 프로세스가 종료될 때까지 대기.3.3 내부 명령 실행 (inline.c)  cd, pwd, exit는 별도로 fork() 없이 실행.          cd: chdir(path)를 호출하여 현재 디렉토리를 변경.      pwd: getcwd()를 호출하여 현재 디렉토리를 출력.      exit: exit(status)를 호출하여 쉘 종료.      4. 정리 및 종료  실행이 끝난 후 restore_redirection을 호출하여 원래의 표준 입력/출력 상태 복구.  COMMAND_free를 이용해 동적 할당된 메모리를 해제.  free(cmds)를 호출하여 COMMAND 목록을 해제.  다음 입력을 기다리며 루프를 반복.🔗 원본 파일 보기"
  },
  
  {
    "title": "웹페이지 제목 수집기",
    "url": "/posts/Title_Collector/",
    "categories": "Project, C_CPP",
    "tags": "Title_Collector",
    "date": "2025-01-04 16:59:17 +0900",
    





    
    "snippet": "구현 정리1. 구성 요소1.1 TaskQueuewget 작업을 다루는 Task Queue  헤더: task_queue.h  구현: task_queue.c함수:  TaskQueue_init: TaskQueue 초기화.  TaskQueue_push: Task 추가.  TaskQueue_pop: Task를 Queue에서 하나 꺼냄.  TaskQueue_de...",
    "content": "구현 정리1. 구성 요소1.1 TaskQueuewget 작업을 다루는 Task Queue  헤더: task_queue.h  구현: task_queue.c함수:  TaskQueue_init: TaskQueue 초기화.  TaskQueue_push: Task 추가.  TaskQueue_pop: Task를 Queue에서 하나 꺼냄.  TaskQueue_destroy: Queue에서 사용한 자원을 정리.Task Structure:typedef struct Task {    char url[MAX_DOMAIN_SIZE];    char filename[16];    bool final; // 스레드 종료를 위한 작업 종료 지시자    struct Task *next;} Task;1.2 스레드 풀wget 작업을 병렬로 처리하기 위한 스레드 풀  헤더: task_queue.h  구현: task_queue.c함수:  thread_pool_init: 스레드 풀 초기화.  thread_pool_add_task: Task Queue에 Task 추가.  thread_pool_wait: 모든 Task 끝날 때까지 대기.  thread_pool_destroy: 큐에 종료 Task를 추가해 모든 스레드 종료 후 자원 정리.1.3 메모리 풀수집한 Domain, Title 쌍을 저장하기 위한 BST 전용 메모리 풀  헤더: memory_pool.h  구현: memory_pool.c함수:  MemoryPool_init: 메모리 풀 초기화.  MemoryPool_alloc: 메모리 풀에서 자원 할당.  MemoryPool_free: 메모리 풀로 자원 반환.  MemoryPool_destroy: 메모리 풀 정리.1.4 Binary Search Tree (BST)수집한 Domain, Title 쌍을 이진 탐색 트리 형태로 저장  헤더: bst.h  구현: bst.c함수:  BST_new: BST 노드 생성.  BST_insert: Domain, Title 쌍 추가.  BST_search: Domain 검색.  BST_print_inorder: 디버깅 용 BST Inorder 출력 함수.1.5 Collect과제에서 요구하는 기능들 집합  헤더: collect.h  구현: collect.c함수:  wget: 페이지를 다운로드하고 title을 추출해서 BST에 저장.  find_title: HTML file에서 title 태그 추출.  get_domain_name: URL에서 Domain Name을 추출.  concat_string: 여러 개의 문자열을 연걸.1.6 BackupStackload 명령 실행 시 남아있던 기존 명령을 스택에 백업함  구현: main.c함수:  backup: 남은 명령을 입력으로부터 저장.  restore: 저장된 명령을 입력으로 복원.2. 작업 흐름  명령어를 읽어들임.          읽지 못했을 경우                  현재 입력이 표준 입력이고 남은 명령어가 없을 경우 자원을 정리하고 종료          리다이렉트 됐을 경우                          남은 명령어가 없으면 표준 입력으로 복구              남았을 경우 명령어 백업으로부터 복구                                          읽었을 경우 개행문자 기준으로 토큰화        작업 수행          URL의 경우, thread_pool에 작업 추가      print, stat의 경우 모든 thread 작업 완료 대기 후 명령 수행      load의 경우 load 이후에 남아있는 명령 백업 후 입력 리다이렉션 및 1번으로 이동      quit의 경우 자원 정리 후 종료      🔗 원본 파일 보기"
  },
  
  {
    "title": "string.h 직접 구현하기",
    "url": "/posts/Stringh/",
    "categories": "Project, C_CPP",
    "tags": "string.h",
    "date": "2025-01-03 16:40:20 +0900",
    





    
    "snippet": "문자열 라이브러리 구현1. 개요  C 표준 라이브러리의 &lt;string.h&gt; 및 기타 문자열 관련 함수들을 직접 구현.  앞으로의 과제를 위해 문자열 처리와 변환 함수들을 준비.2. 구현 함수2.1 숫자 변환 (Conversions)문자열 → 숫자  int atoi2(const char *str):          문자열 str을 int로 변...",
    "content": "문자열 라이브러리 구현1. 개요  C 표준 라이브러리의 &lt;string.h&gt; 및 기타 문자열 관련 함수들을 직접 구현.  앞으로의 과제를 위해 문자열 처리와 변환 함수들을 준비.2. 구현 함수2.1 숫자 변환 (Conversions)문자열 → 숫자  int atoi2(const char *str):          문자열 str을 int로 변환.      int는 32비트 정수로 간주.        long atol2(const char *str):          문자열 str을 long으로 변환.      long은 64비트 정수로 간주.      숫자 → 문자열  char *int2str(char *dest, int num):          정수 num을 문자열로 변환 후 dest에 저장.      dest가 NULL일 경우, 동적으로 메모리를 할당하여 반환.      메모리 할당 실패 시 NULL 반환.      2.2 문자열 조작 (String Manipulation)  char *strcpy(char *dst, const char *src):          문자열 src를 dst로 복사.        char *strncpy(char *dst, const char *src, size_t count):          src에서 최대 count 바이트를 dst로 복사.        char *strcat(char *dst, const char *src):          dst 문자열의 끝에 src를 붙임.        char *strncat(char *dst, const char *src, size_t count):          dst 문자열의 끝에 최대 count 바이트만큼 src를 붙임.        char *strdup(const char *str):          문자열 str을 복사하여 동적 메모리에 저장하고 해당 포인터 반환.      2.3 문자열 검사 (String Examination)  size_t strlen(const char *str):          문자열 str의 길이를 반환.        int strcmp(const char *lhs, const char *rhs):          두 문자열 lhs와 rhs를 비교.        int strncmp(const char *lhs, const char *rhs, size_t count):          lhs와 rhs를 최대 count 바이트만큼 비교.        char *strchr(const char *str, int ch):          str에서 문자 ch가 처음 나타나는 위치를 반환.        char *strrchr(const char *str, int ch):          str에서 문자 ch가 마지막으로 나타나는 위치를 반환.        char *strpbrk(const char *str, const char *accept):          str에서 accept 문자열 중 하나라도 처음 등장하는 위치를 반환.        char *strstr(const char *str, const char *substr):          str에서 부분 문자열 substr이 처음 나타나는 위치를 반환.        char *strtok(char *str, const char *delim):          str을 delim으로 토큰화.        char *strtok_r(char *str, const char *delim, char **saveptr):          strtok와 동일하지만, 내부 상태 대신 saveptr에 저장.      2.4 메모리 조작 (Memory Manipulation)  void *memcpy(void *dest, const void *src, size_t n):          src에서 dest로 n 바이트 복사.        void *memset(void *dest, int ch, size_t count):          dest에서 count 바이트를 ch로 설정.      4. 구현 제한 사항  C 표준 라이브러리 및 기타 외부 라이브러리 함수 사용 금지.  허용된 함수:          malloc, calloc, free를 포함한 일부 메모리 관리 함수.        필요한 경우 라이브러리 함수를 직접 구현 가능.  동적으로 할당된 모든 자원은 프로그램 종료 전에 반드시 해제.🔗 원본 파일 보기"
  },
  
  {
    "title": "Udemy Unreal 메모",
    "url": "/posts/Unreal/",
    "categories": "Study, Unreal",
    "tags": "Unreal",
    "date": "2025-01-01 13:50:56 +0900",
    





    
    "snippet": "# Lecture NoteUdemy 강의 (https://www.udemy.com/course/unrealcourse-korean/)Object  데이터와 기능의 집합  액터: 레벨에 들어가는 오브젝트  컴포넌트: 액터에 들어가는 오브젝트  블루프린트에서 참조 방법          화면 안의 액터 선택 후 BP의 이벤트 그래프에서 우클릭 후 Creat...",
    "content": "# Lecture NoteUdemy 강의 (https://www.udemy.com/course/unrealcourse-korean/)Object  데이터와 기능의 집합  액터: 레벨에 들어가는 오브젝트  컴포넌트: 액터에 들어가는 오브젝트  블루프린트에서 참조 방법          화면 안의 액터 선택 후 BP의 이벤트 그래프에서 우클릭 후 Create a Reference 선택        Data Pin: BP 노드의 In/Out  Execution Pin: 노드의 실행 흐름BP &amp; Instance액터 선택 후 오른쪽의 디테일 혹은 툴바에서 BP 클래스로 변환 가능하다.BP 편집 화면에서 해당 클래스의 여러 속성들을 편집할 수 있으며컨텐츠 드로어에서 씬에 드래그하는 식으로 해당 BP클래스의 인스턴스를 생성할 수 있다.Spawn BPclass : 스폰할 액터의 클래스transform : location, rotation, scalecollision : 스폰 지점 충돌 처리instigator : 이벤트 리스너여러 데이터 타입이 결합된 핀의 경우, 우클릭해서 핀 분할을 통해 세부 타입으로 분리할 수 있다.SpawnActor는 스폰한 인스턴스의 참조를 반환한다. 해당 참조를 이용해 추가적인 작업이 가능하다.Control Rotation  Get Control Rotation : 컨트롤러의 회전 벡터를 반환한다.  Get Forward Vector : 회전 벡터를 정면 벡터로 변환환다.          Forward Vector: 객체의 정면 방향을 월드 좌표계에서 나타낸 단위 벡터      Rotator : 객체의 회전을 표한하는 벡터        물체를 기준으로 바라봤을 때 좌우 회전(Z축 중심)을 Yaw, 상하 회전(Y축 중심)을 Pitch, 물체의 수평 기울기(X축 중심)을 Roll이라고 한다.      Pure Function  side effect가 없는 함수  BP 상에서 실행 핀이 없는 함수🔗 원본 파일 보기"
  },
  
  {
    "title": "SQL 메모",
    "url": "/posts/SQL/",
    "categories": "Study, Database",
    "tags": "SQL",
    "date": "2024-12-30 01:59:01 +0900",
    





    
    "snippet": "Database MEMOSQL 구문 해석 순서  FROM: 데이터 소스를 지정  ON: 조인 조건을 설정  JOIN: 필요한 테이블 결합  WHERE: 행을 필터링  GROUP BY: 데이터를 그룹화  HAVING: 그룹화된 데이터에 추가 조건 적용  SELECT: 선택한 컬럼을 가져옴  DISTINCT: 중복된 행 제거  ORDER BY: 결과를 정...",
    "content": "Database MEMOSQL 구문 해석 순서  FROM: 데이터 소스를 지정  ON: 조인 조건을 설정  JOIN: 필요한 테이블 결합  WHERE: 행을 필터링  GROUP BY: 데이터를 그룹화  HAVING: 그룹화된 데이터에 추가 조건 적용  SELECT: 선택한 컬럼을 가져옴  DISTINCT: 중복된 행 제거  ORDER BY: 결과를 정렬  LIMIT: 결과의 개수를 제한구문 별 문법                              LIMIT B, A          LIMIT A OFFSET B: B번째 행부터 A개의 행 선택 (0-index)                    ACID🔗 원본 파일 보기"
  },
  
  {
    "title": "C++ 정리",
    "url": "/posts/CPP/",
    "categories": "Study, Programming Language",
    "tags": "C++",
    "date": "2024-12-30 01:55:08 +0900",
    





    
    "snippet": "C++ 정리Const  상수에 관한 키워드일반 변수에서의 const  변수 선언시 이후 해당 변수에 대한 변경을 막는다.      const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.    // 기본 자료형(int, float 등)은 무시하고 생각const int val = 10;int const val = 10;// -&gt; va...",
    "content": "C++ 정리Const  상수에 관한 키워드일반 변수에서의 const  변수 선언시 이후 해당 변수에 대한 변경을 막는다.      const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.    // 기본 자료형(int, float 등)은 무시하고 생각const int val = 10;int const val = 10;// -&gt; val에 대한 변경 금지const int *val = ...;// 이후 *val = ...; 금지// val = ...; 가능const int **val = ...;// **val = ...; 금지// *val = ...; val = ...; 가능const int * const *val = ...;// **val = ...; *val = ...; 금지// val = ...; 가능      함수에서의 const  반환형, 매개변수의 const는 일반 변수와 동일  멤버 함수의 경우 함수 시그니쳐 이후에 const를 사용할 수 있다.      const 멤버 함수의 제약조건은 다음과 같다.      class MyClass {  private:      int value = 10;      mutable int mutableValue = 0;      static int staticValue;  public:      int getValue() { // non-const 멤버 함수          return value;      }      void SetValue(int val) const { // const 멤버 함수          value = val; // 일반 멤버 변수 수정 불가          staticValue = mutableValue = 1; // static, mutable 멤버 변수 수정 가능      }      bool IsPositive() const { // const 멤버 함수          int val = GetValue();  // 일반 멤버 함수 호출 불가          SetValue(0); // const 멤버 함수 호출 가능          GetStaticValue(); // static 멤버 함수 호출 가능          externalFunction(value); // 외부 함수 호출 가능          return value &gt; 0;         }      static int GetStaticValue() {          staticValue = 10; // static 멤버 함수는 static 멤버 함수/변수만 접근 가능          return staticValue;      }  };  // 외부 함수  void externalFunction(int&amp; val) {      val = 50;  }  int MyClass::staticValue = 0;       상속, 다형성, Virtual  상속: 부모 클래스의 속성이나 메소드를 자식 클래스가 물려 받는 것.코드 재사용성 증가, 객체 모델링 유연성 증가      다형성: 같은 이름의 메소드나 연산자가 다른 클래스에 대해 다른 동작을 하는 것    타입 캐스팅                  업 캐스팅과 Virtual 키워드다형성을 위해 자식 클래스를 부모 클래스로 변환하는 경우                    다운 캐스팅과 RTTI부모 클래스의 객체를 자식 클래스로 변환하는 경우dynamic_cast를 이용해 수행되며 런타임에 객체의 타입을 확인 후, 불가능한 경우 포인터는 nullptr 반환, 참조자는 std::bad_cast 예외를 던진다.              class Animal {  public:      virtual void says() { cout &lt;&lt; \"Animal says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Animal\" &lt;&lt; endl; }};  class Dog : public Animal {  public:      void says() override { cout &lt;&lt; \"Dog says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Dog\" &lt;&lt; endl; }  };  Animal* a = new Animal();  Animal* b = new Dog();  a-&gt;says(); // Animal says  a-&gt;what(); // Animal  b-&gt;says(); // Dog says  b-&gt;what(); // Animal              Dog 클래스의 인스턴스를 부모인 Animal로 업캐스팅했다.함수 호출 결과를 보면 virtual 함수인 says는 원본 클래스의 함수를 잘 호출하지만 what은 부모 클래스의 함수만 호출된다.      virtual 함수가 있는 클래스는 컴파일 과정에서 VTable을 생성해 함수 호출을 관리한다.      VTable은 클래스마다 생성되며 객체는 VTable 포인터를 통해 자신의 클래스의 함수를 호출하게 된다.      non virtual 함수는 컴파일 타임에 정적으로 바인딩된다.              가상 함수가 포함된 클래스의 메모리 레이아웃은 다음과 같다.        Animal 객체 메모리 레이아웃:+----------------------------+| Animal 클래스 RTTI 포인터   |+----------------------------+| Animal 클래스 VTable 포인터 | &lt;-- a가 여길 가리키고 있음+----------------------------+| (Animal 클래스 멤버 변수)   |+----------------------------+      Dog 객체 메모리 레이아웃:+----------------------------+| Dog 클래스 RTTI 포인터      |+----------------------------+| Dog 클래스 VTable 포인터    |  &lt;-- b가 여길 가리키고 있음+----------------------------+| (Animal 클래스 멤버 변수)   |  +----------------------------+| (Dog 클래스 멤버 변수)      |+----------------------------+Animal VTable:+-----------------+| &amp;Animal::speak  |  // Animal의 says() 함수 주소+-----------------+      Dog VTable:+-----------------+| &amp;Dog::speak     |  // Dog의 says() 함수 주소+-----------------+                          해당 메모리 레이아웃은 다음과 같은 방법으로도 확인 할 수 있다.                class A {    private:        int A_num;        int A_sum;    public:        A() {             A_num = 0x12121212;            A_sum = 0x34343434;            printf(\"A 생성자\\n\");         }        virtual void says() { printf(\"A의 func\\n\"); }        virtual ~A() { printf(\"A 소멸자\\n\"); }            };class B : public A {    private:        int B_num;        int B_sum;    public:        B() {             B_num = 0x56565656;            B_sum = 0x78787878;            printf(\"B 생성자\\n\");         }        void says() override { printf(\"B의 func\\n\"); }        ~B() { printf(\"B 소멸자\\n\"); }};A* c = new B();uintptr_t* vtablePtr = *reinterpret_cast&lt;uintptr_t**&gt;(c); // vtable 포인터printf(\"vtablePtr: %p\\n\", vtablePtr);int* dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t));printf(\"A_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int)); printf(\"A_sum: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 2);printf(\"B_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 3);printf(\"B_sum: %x\\n\", *dataPtr);auto funcPtr = reinterpret_cast&lt;void(*)(A*)&gt;(vtablePtr[0]);funcPtr(c);cout &lt;&lt; typeid(*c).name() &lt;&lt; endl;const std::type_info* rttiInfo = reinterpret_cast&lt;const std::type_info*&gt;(vtablePtr[-1]);std::cout &lt;&lt; \"RTTI type name: \" &lt;&lt; rttiInfo-&gt;name() &lt;&lt; std::endl;// 출력 결과// A 생성자// B 생성자// vtablePtr: 0x5631eb7cbcc0// A_num: 12121212// A_sum: 34343434// B_num: 56565656// B_sum: 78787878// B의 func// RTTI type name: 1B                            소멸자도 함수이기 때문에 소멸자를 가상 함수로 선언하지 않으면 부모 클래스의 소멸자만 호출되어 메모리 누수가 발생할 수 있다.            순수 가상 함수                  가상 함수를 선언만 한 형태                virtual void func() = 0;                          순수 가상 함수가 하나라도 있는 클래스는 추상 클래스라 하며 해당 클래스는 객체 생성이 불가능하다.          순수 가상 함수는 상속된 클래스에서 반드시 구현해줘야 함          순수 가상 함수로만 이루어진 클래스는 인터페이스라고 함                    포인터와 참조자            특징      포인터      참조자                  NULL 지원      지원 (nullptr)      지원하지 않음              초기화      나중에 초기화 가능      선언과 동시에 초기화 필수              대상 변경      가능      불가능              사용법      *, &amp; 필요      간단 (변수처럼 사용 가능)              크기      메모리 주소 크기      크기 없음              산술 연산      가능 (ptr++)      불가능      선택 기준  포인터를 사용할 때:          동적 메모리 할당 및 관리가 필요할 때      NULL 값을 가리키거나 가리키는 대상을 변경해야 할 때      배열, 문자열, 하드웨어 주소를 다룰 때        참조자를 사용할 때:          매개변수로 데이터를 전달하여 복사를 피하고 싶을 때      반환값으로 객체를 참조해야 할 때      간단하고 직관적인 코드를 작성하고 싶을 때      객체의 초기화C++에서 클래스 생성자는 객체가 생성될 때 호출되어 멤버 변수나 기타 자원을 초기화하는 특별한 함수다.1. 멤버 초기화 리스트(Member Initialization List)  생성자 정의에서 콜론(:) 뒤에 멤버 초기화 리스트를 사용하여 객체를 초기화  멤버 변수의 초기화가 생성자의 본체가 실행되기 전에 수행되므로 효율적  const 멤버, 참조자 멤버는 생성 시 초기화 되어야 하므로 초기화 리스트가 필수class MyClass {private:    int value;    const int constValue;    int&amp; refValue;public:    MyClass(int val, int constVal, int&amp; ref)         : value(val), constValue(constVal), refValue(ref) {}};2. 생성자 본문에서 초기화  생성자 본문에서 직접 멤버 변수에 값을 할당하여 초기화.  임시 객체 생성 가능성이 있class MyClass {private:    int value;public:    MyClass(int val) {        value = val;    }};3. 디폴트 멤버 초기화(Default Member Initializer)  C++11부터 클래스 정의에서 멤버 변수를 초기화할 수 있는 디폴트 초기화 구문이 도입  멤버 변수 선언 시 초기값을 지정하며, 모든 생성자에서 동일한 초기값을 사용하려는 경우 유용함  초기화 리스트보다 우선 적용되지만, 명시적 초기화가 있으면 덮어쓴다.class MyClass {private:    int value = 0;    double rate = 1.5;public:    MyClass() {} // 별도 초기화 없이 기본값 사용};4. 위임 생성자(Delegating Constructor)  C++11에서 추가된 기능으로, 생성자에서 다른 생성자를 호출하여 멤버를 초기화  비슷한 초기화 로직을 여러 생성자에서 반복하지 않고 공유할 수 있다.  코드 중복을 줄이고, 유지보수성을 높임class MyClass {private:    int value;public:    // 기본 생성자    MyClass() : MyClass(0) {} // 위임 생성자 사용    // 파라미터를 받는 생성자    MyClass(int val) : value(val) {}};L-Value, R-Value, Move Semantics  L-Value: 메모리에 존재하며 참조할 수 있는 값  R-Value: 임시적인 값으로 참조할 수 없는 값  Move semantics: 복사 대신 리소스의 소유권을 이동하는 개념          R-Value 참조(&amp;&amp;): R-Value를 참조할 수 있는 참조자      std::move: L-Value를 R-Value 캐스팅해주는 함수        이동 생성자와 이동 대입 연산자를 구현하여 사용    복사 대신 소유권을 이전하여 기존 객체의 리소스를 재활용원본 객체는 비어있는 상태가 됨    불필요한 메모리 할당과 해제를 줄여 복사 오버헤드를 줄이고 효율적인 메모리 사용을 가능하게 한다.    class MyClass {private:    int* data;    int size;public:    MyClass(int s) : size(s), data(new int[s]) { }    // 이동 생성자    MyClass(MyClass&amp;&amp; other) noexcept : size(other.size), data(other.data) {        other.size = 0;        other.data = nullptr;  // 소유권 이전    }    // 이동 대입 연산자    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept {        if (this != &amp;other) {            delete[] data;  // 기존 리소스 해제            data = other.data;            size = other.size;            other.data = nullptr;            other.size = 0;        }        return *this;    }    ~MyClass() { delete[] data; }  };int main() {    MyClass obj1(10);    MyClass obj2 = std::move(obj1);  // 이동 생성자 호출    MyClass obj3(5);    obj3 = std::move(obj2);  // 이동 대입 연산자 호출    return 0;}      🔗 원본 파일 보기"
  },
  
  {
    "title": "OpenGL 파이프라인 정리",
    "url": "/posts/OpenGL_Pipeline/",
    "categories": "Project, Graphics",
    "tags": "OpenGL",
    "date": "2024-12-28 17:49:24 +0900",
    





    
    "snippet": "# OpenGL Pipeline 정리Pipeline 과정1. Application (CPU) - Vertex Specification어플리케이션이 실행되며 API 호출을 통해 Vertex, Color, Texture 좌표 등의 데이터를 준비한다.이후 glDrawArrays, glDrawElements등의 API 호출을 통해 렌더링 시작2. Vertex...",
    "content": "# OpenGL Pipeline 정리Pipeline 과정1. Application (CPU) - Vertex Specification어플리케이션이 실행되며 API 호출을 통해 Vertex, Color, Texture 좌표 등의 데이터를 준비한다.이후 glDrawArrays, glDrawElements등의 API 호출을 통해 렌더링 시작2. Vertex Shatder (GPU)정점 데이터를 처리하여 화면 좌표로 변환한다.모델, 뷰, 투영에 행렬을 사용한 변환 수행1. 변환 종류(1) 모델 좌표 → 월드 좌표 (모델 변환)  객체의 로컬 좌표(모델 좌표)를 월드 좌표계로 변환.  모델 변환 행렬 $M$ 사용.(2) 월드 좌표 → 뷰 좌표 (뷰 변환)  카메라(또는 관찰자)의 위치와 방향을 기준으로 월드 좌표를 변환.  뷰 변환 행렬 $V$ 사용.(3) 뷰 좌표 → 클립 좌표 (투영 변환)  3D 공간을 2D 화면에 투영.  원근법(Perspective) 또는 직교(Orthographic) 투영 방식 사용.  투영 변환 행렬 $P$ 사용.2. 행렬 변환(1) 모델-뷰-투영 행렬 (MVP)      각 단계에서 적용되는 행렬을 결합하여 전체 변환을 하나의 행렬로 표현 가능:\\[\\text{MVP} = P \\cdot V \\cdot M\\]          $M$: 모델 변환 행렬.      $V$: 뷰 변환 행렬.      $P$: 투영 변환 행렬.            버텍스 쉐이더는 주로 아래와 같이 변환을 수행:    gl_Position = projection * view * model * vec4(position, 1.0);      (2) 모델 변환 행렬객체의 각 정점에 행렬을 곱해 객체의 로컬 좌표를 월드 좌표로 변환할 수 있다.$T(Translation), R(Rotation), S (Scale)$(3) 뷰 변환 행렬  카메라의 위치와 방향을 기준으로 월드 좌표계를 카메라 좌표계(View Space)로 변환.      OpenGL에서는 일반적으로 카메라가 원점(0,0,0)에 위치하고, $-Z$ 방향을 바라보는 것으로 가정.        구성 요소          카메라 위치 $\\mathbf{C}$ (Eye Position).      카메라 방향:                  $\\mathbf{F}$: 전방 벡터(Forward).          $\\mathbf{R}$: 오른쪽 벡터(Right).          $\\mathbf{U}$: 위쪽 벡터(Up).                          뷰 행렬 계산          전방 벡터:    \\[\\mathbf{F} = \\frac{\\mathbf{Target} - \\mathbf{C}}{||\\mathbf{Target} - \\mathbf{C}||}\\]          오른쪽 벡터:    \\[\\mathbf{R} = \\frac{\\mathbf{F} \\times \\mathbf{Up}}{||\\mathbf{F} \\times \\mathbf{Up}||}\\]          새로운 위쪽 벡터:    \\[\\mathbf{U} = \\mathbf{R} \\times \\mathbf{F}\\]          뷰 변환 행렬 $V$:      \\[\\mathbf{V} = \\begin{bmatrix}R_x &amp; R_y &amp; R_z &amp; -\\mathbf{R} \\cdot \\mathbf{C} \\\\U_x &amp; U_y &amp; U_z &amp; -\\mathbf{U} \\cdot \\mathbf{C} \\\\-F_x &amp; -F_y &amp; -F_z &amp; \\mathbf{F} \\cdot \\mathbf{C} \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\]  행렬의 구성:          상단 $3 \\times 3$: 카메라 방향 변환.      $-\\mathbf{R} \\cdot \\mathbf{C}, -\\mathbf{U} \\cdot \\mathbf{C}, \\mathbf{F} \\cdot \\mathbf{C}$: 카메라 위치 변환.            GLM의 glm::lookAt 함수          함수 프로토타입        glm::mat4 glm::lookAt(    glm::vec3 eye,        // 카메라의 위치    glm::vec3 center,     // 카메라가 바라보는 대상 위치    glm::vec3 up          // 카메라의 업 벡터);      (4) 투영 변환 행렬  3D 공간을 2D 화면으로 투영.      투영은 원근 투영(Perspective Projection) 또는 직교 투영(Orthographic Projection) 방식으로 이루어짐.        1. 원근 투영 (Perspective Projection)          특징: 멀리 있는 객체는 작게, 가까운 객체는 크게 보이도록.      구성 요소:                  fov: 시야각(Field of View).          aspect: 화면 비율 (너비/높이).          near, far: 가까운 평면과 먼 평면의 거리.                    행렬 형태:      \\[\\mathbf{P} = \\begin{bmatrix}\\frac{1}{\\tan(\\frac{fov}{2}) \\cdot aspect} &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; \\frac{1}{\\tan(\\frac{fov}{2})} &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; \\frac{-(far + near)}{far - near} &amp; \\frac{-2 \\cdot far \\cdot near}{far - near} \\\\0 &amp; 0 &amp; -1 &amp; 0\\end{bmatrix}\\]      2. 직교 투영 (Orthographic Projection)          특징: 멀리 있는 객체도 동일한 크기로 보임.      구성 요소:                  l, r: 왼쪽, 오른쪽 평면.          t, b: 위쪽, 아래쪽 평면.          near, far: 가까운 평면과 먼 평면의 거리.                    행렬 형태:      \\[\\mathbf{P}=\\begin{bmatrix}\\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{r+l}{r-l} \\\\0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t-b} \\\\0 &amp; 0 &amp; \\frac{-2}{far-near} &amp; -\\frac{far+near}{far-near} \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\]3. Primitive Assembly정점들을 가지고 점, 선, 삼각형(Primitive)를 만드는 단계4. RasterisationPrimitive(기본 도형: 점, 선, 삼각형 등)를 픽셀(fragment)로 변환하는 과정.클리핑, 컬링, 뷰포트 변환, 래스터라이즈등을 수행함.클리핑 (Clipping)Primitive(점, 선, 삼각형 등)가 화면에 표시될 수 있는 범위 안에 존재하는지 확인하고, 화면 밖의 부분을 제거.  목표:          클립 공간(Clip Space)에서 화면에 표시될 영역만 남기고, 표시되지 않을 부분을 제거.      클립 공간은 정규화된 좌표 영역(Normalized Device Coordinates, NDC)에서 $[-1, 1]$ 범위로 제한.        과정:          클립 공간에서 벗어난 점은 잘려나거나 새로운 정점으로 분할.                  예: 삼각형이 클립 경계에 걸쳐 있을 경우, 클립 경계에 따라 새로운 삼각형으로 분리.                    클리핑 이후, 남아 있는 부분은 화면에 그려질 준비를 함.        유형:          View Frustum Clipping: 시야 절두체(View Frustum) 영역 안에 있는 것만 렌더링.      Near/Far Plane Clipping: 카메라의 근평면(near plane)과 원평면(far plane)에서 잘라냄.      컬링 (Culling)카메라에서 보이지 않는 면(프리미티브)을 제거하여 렌더링 효율을 높이는 작업.  목표:          삼각형(또는 기타 프리미티브)의 뒷면(back face) 을 제거하여 처리량을 줄임.      주로 폐쇄형 오브젝트에서 내부 면을 제거.        방식:          컬링은 삼각형의 법선 방향(normal vector) 과 카메라 방향을 비교하여 수행.      시계 방향(CW, Clockwise) 또는 반시계 방향(CCW, Counter-clockwise) 으로 정의된 삼각형의 정점 순서를 기반으로 면이 앞면인지 뒷면인지 판단.        유형:          Back-face Culling: 카메라에서 보이지 않는 면(뒷면)을 제거.      Front-face Culling: 필요 시 앞면을 제거.      Frustum Culling: 시야 절두체(Frustum) 밖의 객체를 제거.        장점:          불필요한 면 제거로 GPU 연산량 감소.      렌더링 최적화.      뷰포트 변환 (Viewport Transformation)정규화된 장치 좌표(NDC, Normalized Device Coordinates)를 스크린 좌표(Screen Coordinates)로 변환하는 작업입니다.  목표:          클립 공간에서 정규화된 좌표($[-1, 1]$)를 실제 화면에서 픽셀 위치로 변환.      렌더링할 뷰포트 영역에 맞게 조정.            과정:\\[x_{\\text{screen}} = \\frac{x_{\\text{ndc} } + 1}{2} \\cdot w_{\\text{viewport}} + x_{\\text{origin}}\\]\\[y_{\\text{screen}} = \\frac{y_{\\text{ndc} } + 1}{2} \\cdot h_{\\text{viewport}} + y_{\\text{origin}}\\]          $x_{\\text{ndc} }, y_{\\text{ndc} }$: NDC 좌표.      $w_{\\text{viewport}}, h_{\\text{viewport}}$: 뷰포트의 너비와 높이.      $x_{\\text{origin}}, y_{\\text{origin}}$: 뷰포트의 시작 좌표.        특징:          화면에서 특정 영역만 렌더링할 수도 있음 (예: Split Screen, Render Target).      OpenGL:                  glViewport(x, y, width, height)를 통해 뷰포트 설정.                    5. Fragment Shader각 픽셀(Fragment)에 대해 색상을 계산한다.조명 계산, 택스쳐 매핑등을 수행한다.6. Frame BufferFragment Shader 출력이 화면의 픽셀에 표시된다.깊이 테스트, 스텐실 테스트등을 통해 사용할 Fragment를 정하고,블렌딩, 디더링, 샘플링을 통해 색상을 자연스럽게 렌더링한다.CPU 코드와 쉐이더 코드의 관계1. CPU 코드의 역할CPU 코드(애플리케이션) OpenGL 파이프라인을 제어하고 데이터를 준비한다.  쉐이더 프로그램 관리:          쉐이더 소스 코드 읽기(보통 .vert와 .frag 파일).      쉐이더 컴파일 및 링크.      쉐이더 변수에 데이터 전달(유니폼, 속성 등).        버퍼와 VAO/VBO 설정:          정점 데이터를 GPU 메모리에 업로드.      렌더링 대상 정의.        렌더링 명령 전달:          드로우 호출로 GPU에 렌더링 명령 실행.      2. 쉐이더 코드 (Vertex &amp; Fragment)  Vertex Shader (.vert 파일):          각 정점에 대해 처리 작업을 수행.      모델 변환, 뷰 변환, 투영 변환.        Fragment Shader (.frag 파일):          각 프래그먼트에 대해 처리 작업을 수행.      색상, 조명, 텍스처 매핑을 계산.      3. 데이터 전달CPU와 쉐이더 코드 간 데이터 전달은 다음 방식으로 이루어진다:  유니폼(Uniform): 애플리케이션에서 쉐이더로 글로벌 데이터 전달 (예: 변환 행렬, 조명 데이터).  속성(Attribute): 각 정점에 대해 별도의 데이터 전달 (예: 위치, 텍스처 좌표).  VBO(Vertex Buffer Object): 정점 데이터를 GPU 메모리에 저장.  텍스처: 이미지 데이터를 GPU에 업로드하고 프래그먼트 쉐이더에서 접근.참고자료opengl-graphics-pipeline[OpenGL ES를 이용한 3차원 컴퓨터 그래픽스 입문] 챕터 7 - 래스터라이저[OpenGL로 배우는 컴퓨터 그래픽스] Chapter 07. 투상변환과 뷰포트변환🔗 원본 파일 보기"
  },
  
  {
    "title": "OpenGL API 정리",
    "url": "/posts/OpenGL_API/",
    "categories": "Project, Graphics",
    "tags": "OpenGL",
    "date": "2024-12-28 17:49:24 +0900",
    





    
    "snippet": "OpenGL APIOpenGL 파이프라인의 각 단계에서 데이터를 설정하거나 렌더링을 제어하는 역할을 하는 API 정리1. 데이터 관리 및 설정 관련 APIglGenBuffers  역할: 하나 이상의 버퍼 객체를 생성하고 고유한 ID를 할당.      사용 예:    glGenBuffers(1, &amp;vertex_buffer);            ...",
    "content": "OpenGL APIOpenGL 파이프라인의 각 단계에서 데이터를 설정하거나 렌더링을 제어하는 역할을 하는 API 정리1. 데이터 관리 및 설정 관련 APIglGenBuffers  역할: 하나 이상의 버퍼 객체를 생성하고 고유한 ID를 할당.      사용 예:    glGenBuffers(1, &amp;vertex_buffer);              새로운 버퍼 객체를 생성하고 vertex_buffer에 ID를 저장.      glBindBuffer      함수 정의      void glBindBuffer(GLenum target, GLuint buffer);              target: 버퍼 객체가 어떤 용도로 사용될지 지정하는 버퍼 타입.      buffer: 바인딩할 버퍼 객체의 ID. (glGenBuffers로 생성된 ID).        역할: 생성된 버퍼 객체를 특정 버퍼 타입(GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER 등)과 바인딩.      사용 예:    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);              vertex_buffer를 현재 활성화된 GL_ARRAY_BUFFER로 설정.        주요 버퍼 타입 (target)          GL_ARRAY_BUFFER                  역할: 정점 데이터(Vertex Data)를 저장.          사용 데이터:                          정점 위치(Position), 색상(Color), 텍스처 좌표(Texture Coordinates), 법선 벡터(Normal) 등.                                적용 대상:                          버텍스 셰이더에서 입력으로 사용되는 데이터.                                          GL_ELEMENT_ARRAY_BUFFER                  역할: 인덱스 데이터(Index Data)를 저장.          사용 데이터:                          삼각형의 정점 인덱스 배열.              정점 데이터를 재사용하여 메모리 절약 및 렌더링 효율성 향상.                                적용 대상:                          glDrawElements 및 glDrawElementsInstanced 호출에서 사용.                                          GL_UNIFORM_BUFFER                  역할: 유니폼 데이터(Uniform Data)를 저장.          사용 데이터:                          여러 셰이더에서 공유하는 전역 데이터(예: 변환 행렬, 조명 데이터 등).                                적용 대상:                          유니폼 블록(Uniform Block) 으로 선언된 데이터를 전달.                                          (4) GL_TEXTURE_BUFFER                  역할: 텍스처 데이터(Texture Data)를 저장.          사용 데이터:                          텍스처로 사용될 1D 배열 데이터를 저장.                                적용 대상:                          텍스처 버퍼를 사용할 때.                                          glBufferData  역할: 바인딩된 버퍼 객체에 데이터를 업로드.      사용 예:    glBufferData(GL_ARRAY_BUFFER, sizeof(vertex) * vertex_list.size(), &amp;vertex_list[0], GL_STATIC_DRAW);              vertex_list의 데이터를 GPU로 복사.      GL_STATIC_DRAW: 데이터가 자주 변경되지 않음을 명시.      glGetAttribLocation  역할: 셰이더 프로그램에서 특정 속성(attribute)의 위치를 가져옴.      사용 예:    GLuint loc = glGetAttribLocation(program, \"position\");              셰이더 프로그램(program)에서 \"position\" 속성의 위치를 반환.      glEnableVertexAttribArray  역할: 특정 속성을 활성화하여 GPU가 데이터를 사용할 수 있도록 설정.      사용 예:    glEnableVertexAttribArray(loc);              속성(loc)을 활성화.      glVertexAttribPointer  역할: 셰이더 속성에 데이터의 레이아웃(구조)을 정의.      사용 예:    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, sizeof(vertex), (GLvoid*)0);              셰이더 속성 loc에 대해:                  3: 데이터 개수(예: vec3).          GL_FLOAT: 데이터 타입.          GL_FALSE: 정규화 여부.          sizeof(vertex): 정점 데이터의 크기(Stride).          (GLvoid*)0: 데이터의 시작 위치(Offset).                    glGetUniformLocation  역할: 셰이더 프로그램에서 특정 유니폼 변수의 위치를 가져옴.      사용 예:    GLint uloc = glGetUniformLocation(program, \"radius\");              \"radius\" 유니폼 변수의 위치를 반환.      glUniform*  역할: 특정 유니폼 변수에 값을 설정.      사용 예:    glUniform1fv(uloc, NUM_CIRCLES, radius);              uloc 위치에 radius 데이터를 전달.      2. 셰이더 관련 APIglCreateProgram  역할: 새로운 셰이더 프로그램 객체를 생성.      사용 예:    GLuint program = glCreateProgram();              셰이더 프로그램 ID를 생성.      glUseProgram  역할: 특정 셰이더 프로그램을 활성화.      사용 예:    glUseProgram(program);              현재 렌더링에 사용할 셰이더 프로그램을 설정.      3. 렌더링 관련 APIglClear  역할: 컬러 버퍼, 깊이 버퍼 등을 초기화.      사용 예:    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);              컬러 버퍼와 깊이 버퍼를 초기화.      glDrawElementsInstanced  역할: 인덱스 버퍼를 기반으로 다수의 인스턴스를 렌더링.      사용 예:    glDrawElementsInstanced(GL_TRIANGLES, index_list.size(), GL_UNSIGNED_INT, nullptr, 21);              GL_TRIANGLES: 삼각형 렌더링.      index_list.size(): 인덱스 데이터 개수.      GL_UNSIGNED_INT: 인덱스 데이터 타입.      21: 인스턴스의 개수.      glDrawArrays  역할: 정점 데이터를 순서대로 읽어와 렌더링.      사용 예:    glDrawArrays(GL_TRIANGLES, 0, NUM_TESS * 3);              GL_TRIANGLES: 삼각형 렌더링.      0: 첫 번째 정점부터 시작.      NUM_TESS * 3: 정점 개수.      glfwSwapBuffers  역할: 더블 버퍼링 방식에서 현재 렌더링된 버퍼를 화면에 출력.      사용 예:    glfwSwapBuffers(window);      4. 윈도우 및 이벤트 관련 APIglfwSetWindowSizeCallback  역할: 윈도우 크기 변경 시 호출되는 콜백 함수를 설정.      사용 예:    glfwSetWindowSizeCallback(window, reshape);      glfwPollEvents  역할: 이벤트 큐에서 대기 중인 이벤트를 처리.      사용 예:    glfwPollEvents();      요약            API      역할      관련 작업                  glGenBuffers / glBindBuffer      버퍼 생성 및 바인딩      GPU 메모리 관리              glBufferData      버퍼에 데이터 업로드      정점, 인덱스 데이터 전송              glGetAttribLocation      셰이더 속성 위치 가져오기      속성 바인딩              glEnableVertexAttribArray      속성 활성화      속성 사용 설정              glVertexAttribPointer      속성과 데이터 연결      셰이더 데이터 매핑              glGetUniformLocation      유니폼 변수 위치 가져오기      셰이더 변수 설정              glUniform*      유니폼 값 전달      값 설정              glDrawElementsInstanced      인스턴스 렌더링      다중 객체 렌더링              glDrawArrays      정점 순차 렌더링      단일 객체 렌더링              glClear      화면 초기화      화면 준비              glfwSwapBuffers      렌더링된 화면 출력      더블 버퍼링      🔗 원본 파일 보기"
  },
  
  {
    "title": "OpenGL 데이터 처리 과정",
    "url": "/posts/OpenGL_Flow/",
    "categories": "Project, Graphics",
    "tags": "Math, Elastic_Collision",
    "date": "2024-12-25 20:06:20 +0900",
    





    
    "snippet": "# OpenGL 파이프라인을 기반으로 한 데이터 이동과 처리 흐름 정리1. CPU 데이터 준비(1) 정점 및 인스턴스 데이터 초기화  CPU 코드에서 정점(Vertex) 데이터와 원의 인스턴스 데이터(위치, 반지름, 색상 등)를 준비.          update_circle_vertices(NUM_TESS):                  원의 꼭짓...",
    "content": "# OpenGL 파이프라인을 기반으로 한 데이터 이동과 처리 흐름 정리1. CPU 데이터 준비(1) 정점 및 인스턴스 데이터 초기화  CPU 코드에서 정점(Vertex) 데이터와 원의 인스턴스 데이터(위치, 반지름, 색상 등)를 준비.          update_circle_vertices(NUM_TESS):                  원의 꼭짓점 데이터를 계산하여 vertex_list에 저장          정점 데이터는 원점 (0, 0)에서 시작하여 NUM_TESS개의 삼각형으로 원을 정의한다.                    update_vertex_buffer(NUM_TESS):                  GPU 메모리에 정점 버퍼와 인덱스 버퍼를 생성 및 업로드.                    void update_circle_vertices(uint N) {        vertex_list.clear();        vertex_list.push_back({ vec3(0,0,0), vec3(0.0f,0.0f,-1.0f), vec2(0.5f) });        for (uint k = 0; k &lt;= N; k++) {            float t = PI * 2.0f / float(N) * float(k);            float c = cos(t), s = sin(t);            vertex_list.push_back({ vec3(c,s,0.0f) , vec3(0.0f,0.0f,-1.0f), vec2(c * 0.5f + 0.5f,s * 0.5f + 0.5f) });        }    }    void update_vertex_buffer(uint N) {        // ... buffer clear        for (uint k = 0; k &lt; N; k++) {            index_list.push_back(0);            index_list.push_back(k + 1);            index_list.push_back(k + 2);        }        // ... buffer upload    }                update_circle_vertices에서 한 점을 원점을 기준으로 반시계 방향으로 회전시켜 vertex를 만들고update_vertex_buffer에서 반시계 방향으로 변 하나씩을 공유하는 삼각형을 만들도록 index를 구성한다.            (2) 버퍼 데이터 업로드  정점 데이터 (vertex_list)는 glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);를 통해 GPU에 업로드.  인덱스 데이터 (index_list)는 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);를 통해 GPU에 업로드.(3) 유니폼 데이터 설정  CPU에서 원의 속성 데이터를 쉐이더에 전달.          glUniform* 함수로 radius, offset, solid_color 등 데이터를 쉐이더의 유니폼 변수에 설정한다.      2. 버텍스 쉐이더 단계 (circ.vert)버텍스 쉐이더는 정점 데이터를 처리하며, 여기서는 인스턴스화를 통해 각 원을 개별적으로 설정한다.(1) 입력 데이터  정점 속성: position, normal, texcoord (정점의 위치, 법선 벡터, 텍스처 좌표).  유니폼:          radius[21]: 각 원의 반지름.      offset[21]: 각 원의 중심 위치.      aspect_ratio: 화면의 종횡비.        내장 변수: gl_InstanceID (현재 처리 중인 인스턴스 ID).(2) 처리 내용  각 정점을 해당 원의 반지름(radius[gl_InstanceID])으로 스케일링 (Scale).  회전(Rotate)은 필요 없으므로 생략  각 정점의 위치를 해당 원의 중심 위치(offset[gl_InstanceID])로 이동 (Translate).  화면의 종횡비(aspect_ratio)를 고려하여 위치 조정.(3) 출력 데이터  gl_Position: 최종 변환된 정점의 클립 공간 좌표.  norm, tc: 법선 벡터와 텍스처 좌표를 프래그먼트 쉐이더로 전달.3. 래스터화 및 프래그먼트 쉐이더 단계 (circ.frag)래스터화 단계에서 삼각형 프리미티브가 픽셀(fragment)로 변환되며, 각 픽셀은 프래그먼트 쉐이더에서 처리된다.(1) 입력 데이터  인터폴레이션된 데이터:          tc: 텍스처 좌표 (각 픽셀의 상대 위치).      instanceID: 처리 중인 인스턴스 ID (flat, 변하지 않음).        유니폼 데이터:          bUseSolidColor: 단색 여부를 결정하는 플래그.      solid_color[21]: 각 원의 색상.      (2) 처리 내용  bUseSolidColor가 true일 경우:          픽셀 색상을 solid_color[instanceID]에서 가져옴.        bUseSolidColor가 false일 경우:          픽셀 색상을 텍스처 좌표 tc를 기반으로 설정.      (3) 출력 데이터  fragColor: 최종 픽셀 색상. 화면에 표시될 결과값.4. 프레임 버퍼 및 렌더링  glfwSwapBuffers를 통해 현재 프레임을 화면에 출력함.🔗 원본 파일 보기"
  },
  
  {
    "title": "완전 탄성 충돌 수식",
    "url": "/posts/Elastic_Collision/",
    "categories": "Project, Graphics",
    "tags": "Math, Elastic_Collision",
    "date": "2024-12-25 19:59:52 +0900",
    





    
    "snippet": "# 완전 탄성 충돌 구현완전 탄성 충돌에서 두 물체의 속도 변화 유도완전 탄성 충돌(elastic collision)은 운동량과 운동에너지가 모두 보존된다.다음은 두 물체의 충돌 전후 속도를 유도하는 과정이다.1. 운동량 보존법칙두 물체의 질량을 각각 $m_1$, $m_2$라고 하고, 충돌 전 속도를 $v_1$, $v_2$, 충돌 후 속도를 $V_1$...",
    "content": "# 완전 탄성 충돌 구현완전 탄성 충돌에서 두 물체의 속도 변화 유도완전 탄성 충돌(elastic collision)은 운동량과 운동에너지가 모두 보존된다.다음은 두 물체의 충돌 전후 속도를 유도하는 과정이다.1. 운동량 보존법칙두 물체의 질량을 각각 $m_1$, $m_2$라고 하고, 충돌 전 속도를 $v_1$, $v_2$, 충돌 후 속도를 $V_1$, $V_2$라고 할 때, 운동량 보존법칙은 다음과 같이 표현된다:\\[(1) \\quad m_1 v_1 + m_2 v_2 = m_1 V_1 + m_2 V_2\\]2. 운동에너지 보존법칙\\[\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 V_1^2 + \\frac{1}{2} m_2 V_2^2\\]정리하면:\\[(2) \\quad m_1 v_1^2 + m_2 v_2^2 = m_1 V_1^2 + m_2 V_2^2\\]3. 상대속도 관계완전 탄성 충돌에서 두 물체의 상대속도는 충돌 전 후에 반대 방향으로 동일하다:\\[(3) \\quad v_1 - v_2 = -(V_1 - V_2)\\]이는 (1)과 (2)로부터 유도 가능하다.4. 속도 계산 유도식 (3)을 정리하면:\\[V_1 = V_2 + v_2 - v_1\\]이를 식 (1)에 대입하면:\\[m_1 v_1 + m_2 v_2 = m_1 (V_2 + v_2 - v_1) + m_2 V_2\\]정리하면:\\[m_1 v_1 + m_2 v_2 = m_1 V_2 + m_1 v_2 - m_1 v_1 + m_2 V_2\\]\\[m_1 v_1 + m_2 v_2 + m_1 v_1 - m_1 v_2 = (m_1 + m_2) V_2\\]\\[V_1 = \\frac{(m_1 - m_2) v_1 + 2 m_2 v_2}{m_1 + m_2}\\]마찬가지로, $V_2$는 다음과 같다:\\[V_2 = \\frac{(m_2 - m_1) v_2 + 2 m_1 v_1}{m_1 + m_2}\\]물체의 크기를 포함한 속도 계산물체의 크기가 존재하면 위에서 구한 값에 추가적인 계산이 필요하다.위의 식은 두 물체의 충돌 방향이 두 물체의 중심을 이은 직선과 같을 때 성립한다.따라서 그림에서와 같이 두 물체가 $u_1$, $u_2$로 충돌할 때, 속도 벡터를 분해하여공의 중심을 잇는 방향의 속도끼리 계산한 후, 나머지 성분의 속도를 합해줘야 한다.벡터를 특정 방향으로 분해하는 방법은 벡터의 내적을 이용하면 된다.속도 벡터가 $\\vec{A}$, 충돌 방향 벡터가 $\\vec{B}$일 때, $\\vec{A}$와 $\\vec{B}$를 내적하면 $\\vec{B}$방향에 대한 $\\vec{A}$의 크기를 구할 수 있다.다른 방향의 크기는 $\\vec{B}$를 90도 회전시킨 벡터에 대해 계산하면 된다.회전각 $\\theta$에 따른 회전 공식은 다음과 같다.\\[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = \\begin{bmatrix}\\cos \\theta &amp; -\\sin \\theta \\\\\\sin \\theta &amp; \\cos \\theta\\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\\]상세 구현은 elastic 함수에 작성되어 있다.🔗 원본 파일 보기"
  },
  
  {
    "title": "OOP 정리",
    "url": "/posts/OOP/",
    "categories": "Study, OOP",
    "tags": "OOP",
    "date": "2024-12-19 23:56:56 +0900",
    





    
    "snippet": "OOP특징      추상화    대상의 공통적인 특성들을 묶어 표현하는 것 (abstract, interface class)        상속          기존 클래스의 속성과 메서드를 물려받는 것      코드 재사용성과 확장성을 높임      부모 클래스의 public, protected 멤버를 상속받는다.            캡슐화      ...",
    "content": "OOP특징      추상화    대상의 공통적인 특성들을 묶어 표현하는 것 (abstract, interface class)        상속          기존 클래스의 속성과 메서드를 물려받는 것      코드 재사용성과 확장성을 높임      부모 클래스의 public, protected 멤버를 상속받는다.            캡슐화          데이터와 메서드를 묶고, 데이터에 대한 직접 접근을 막는 것            다형성          같은 이름의 메서드나 연산자가 다른 동작을 하는 것      오버로딩과 오버라이딩을 통해 구현                  오버로딩: 이름은 같지만 시그니쳐가 다른 것          오버라이딩: 상위 클래스의 메소드를 재정의 하는 것                    SOLID 원칙      단일 책임 원칙 (SRP)    클래스는 단 하나의 책임을 가지고 하나의 이유로만 변경되어야 한다.        개방 폐쇄 원칙 (OCP)    확장에는 열려 있고 수정에는 닫혀 있어야 한다. 기존 코드를 수정하지 않고 기능을 추가할 수 있어야 한다.        리스코프 치환 원칙 (LSP)    상위 타입의 객체를 하위 타입으로 대체해도 정상적으로 동작해야 한다.        인터페이스 분리 원칙 (ISP)    클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다. 인터페이스를 세분화하여 클라이언트가 필요한 기능만 사용할 수 있도록 제한한다.        의존성 역전 원칙 (DIP)    고수준 모듈(비즈니스 로직 등)은 저수준 모듈(구현 세부 사항)에 의존해서는 안 된다. 고수준, 저수준 모두 둘 다 추상화(인터페이스나 추상 클래스)에 의존해야 한다.    DIP 위반     class EmailService {     public:         void SendEmail(const string&amp; message) {             cout &lt;&lt; \"Sending Email: \" &lt;&lt; message &lt;&lt; endl;         } }; // 고수준 모듈: Notification은 EmailService에 직접 의존 class Notification {     private:         EmailService emailService; // 저수준 모듈에 직접 의존     public:         void Notify(const string&amp; message) {             emailService.SendEmail(message); // EmailService에 직접 접근         } };        DIP 적용     class IMessageService {     public:         virtual void SendMessage(const std::string&amp; message) = 0; }; // 고수준 모듈 class Notification {     private:         IMessageService* messageService;     public:         Notification(IMessageService* service) : messageService(service) {}         void Notify(const std::string&amp; message) {             messageService-&gt;SendMessage(message);         } }; // 저수준 모듈 class EmailService : public IMessageService {     public:         void SendMessage(const std::string&amp; message) override {             // 이메일 전송 로직         } };      🔗 원본 파일 보기"
  },
  
  {
    "title": "OS Scheduling",
    "url": "/posts/OS_Scheduling/",
    "categories": "Study, OS",
    "tags": "Scheduling",
    "date": "2024-12-19 13:50:56 +0900",
    





    
    "snippet": "# OSScheduling  자원을 할당받을 프로세스를 결정하는 과정  Process 5-state model  다음 경우에 발생          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)  ...",
    "content": "# OSScheduling  자원을 할당받을 프로세스를 결정하는 과정  Process 5-state model  다음 경우에 발생          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)        이 중 1, 4번에서만 발생할 경우 비선점 (non-preemptive), 네 가지 전부에서 발생할 경우 선점 (preemptive) 스케줄링이라 한다.  알고리즘First Come First Served (FCFS, FIFO)  가장 간단한 비선점 스케줄링 방법  작업 큐에 도착한 순서대로 실행한다.  작업 순서에 따라 콘보이 효과가 발생 할 수 있다.          콘보이 효과: 하나의 긴 작업이 CPU를 오래 점유하여 뒤에 대기하는 짧은 작업들이 오래 기다리게 되는 현상      Shortest Job First (SJB)  비선점  실행 시간(burst time)이 짧은 프로세스부터 실행  어떤 프로세스가 계속 자원 할당을 받지 못하는 Starvation 발생 가능Shortest Remaining Time First (SRTF)  선점형  남은 시간이 가장 짧은 프로세스부터 실행  Starvation 발생 가능Priority Scheduling  선점형, 비선점형  선점형의 경우 Starvation 발생 가능          오래 대기한 프로세스의 우선순위를 높여서 해결 가능 (aging)      Round Robin (RR)  선점형  일정한 시간 간격동안만 프로세스를 처리하고 남은 작업은 큐의 맨 뒤로 보냄Multilevel Feedback Queue  선점형  우선순위가 다른 여러개의 큐를 사용  프로세스는 다른 큐로 이동 가능🔗 원본 파일 보기"
  },
  
  {
    "title": "최장 공통 부분 수열",
    "url": "/posts/LCS/",
    "categories": "Study, Algorithm",
    "tags": "DP, LCS",
    "date": "2024-11-30 01:19:44 +0900",
    





    
    "snippet": "최장 공통 부분 수열(LCS: Longest Common Subsequence)LCS 길이 구하기DP[i][j]: A[..i], B[..j]까지의 LCS길이      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j ...",
    "content": "최장 공통 부분 수열(LCS: Longest Common Subsequence)LCS 길이 구하기DP[i][j]: A[..i], B[..j]까지의 LCS길이      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])  LCS 문자열 구하기  역추적 (Backtracking) 방식DP 테이블을 이용해 (N, M)에서 (0, 0)까지 역추적하여 LCS를 복원.          A[i] == B[j]이면 LCS에 포함됨 → i-1, j-1로 이동      DP[i-1][j], DP[i][j-1]를 비교해 큰 쪽으로 이동      def LCS(A: str, B: str) -&gt; str:    N, M = len(A), len(B)    DP = [[0] * (M + 1) for _ in range(N + 1)]    # DP 테이블 채우기    for i in range(1, N + 1):        for j in range(1, M + 1):            if A[i - 1] == B[j - 1]:  # 문자가 같으면                DP[i][j] = DP[i - 1][j - 1] + 1            else:                DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])    # LCS 역추적 (Backtracking)    i, j = N, M    lcs = []    while i &gt; 0 and j &gt; 0:        if A[i - 1] == B[j - 1]:  # 같은 문자는 LCS에 포함            lcs.append(A[i - 1])            i -= 1            j -= 1        elif DP[i - 1][j] &gt; DP[i][j - 1]:  # 위쪽이 크다면 위로 이동            i -= 1        else:  # 왼쪽이 크다면 왼쪽으로 이동            j -= 1    return ''.join(reversed(lcs))  # 역순으로 정렬하여 반환시간 복잡도  DP 테이블을 채우는 과정: O(N × M)  LCS 역추적 과정: O(N + M)  전체 시간 복잡도: O(N × M)🔗 원본 파일 보기"
  },
  
  {
    "title": "정렬 알고리즘",
    "url": "/posts/Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 01:15:21 +0900",
    





    
    "snippet": "정렬Bubble Sort인접한 두 원소를 비교하여 역순이면 교환한다.# seq = []# 총 n번 반복for i in range(n - 1, -1, -1):    is_swapped = False    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로     # seq[:i] 까지만 확인    for j in range(i):        i...",
    "content": "정렬Bubble Sort인접한 두 원소를 비교하여 역순이면 교환한다.# seq = []# 총 n번 반복for i in range(n - 1, -1, -1):    is_swapped = False    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로     # seq[:i] 까지만 확인    for j in range(i):        if seq[j] &gt; seq[j + 1]:            seq[j], seq[j + 1] = seq[j + 1] &gt; seq[j]            is_swapped = True    if not is_swapped:        breakSelection Sort현재 i = [0, n)일 때 seq[i:]에서 가장 작은 원소와 seq[i]를 교환한다.# seq = []for cur in range(n):    min_index = cur    for i in range(cur, n):        if seq[min_index] &gt; seq[i]:            min_index = i    seq[min_index], seq[cur] = seq[cur], seq[min_index]Insertion Sort현재 i = [1, n)일 때 seq[:i]에서 seq[i]를 삽입할 위치를 찾아 삽입한다.# seq = []for cur in range(1, n):    while cur &gt; 0 and seq[cur] &lt; seq[cur - 1]:        seq[cur], seq[cur - 1] = seq[cur - 1], seq[cur]        cur -= 1Quick Sortpivot을 기준으로 배열을 양쪽으로 나누어 정렬한다.# seq = []def partition(left, right):    # [left, right] 범위를 재배치    pivot = seq[(left + right) // 2]    while left &lt;= right:        # left를 pivot보다 큰 원소가 나타나는 지점까지 이동        while seq[left] &lt; pivot:            left += 1        # right를 pivot보다 작은 원소가 나타나느 지점까지 이동        while seq[right] &gt; pivot:            right -= 1                # 재배치가 안끝났으면        if left &lt;= right:            # seq[left]는 pivot보다 크고             # seq[right]는 pivot보다 작으므로             # 서로 교환            seq[left], seq[right] = seq[right], seq[left]            # 한 칸씩 이동            left, right = left + 1, right - 1    return leftdef quick_sort(left, right):    print(seq, left, right)    if left &gt;= right:        return        mid = partition(left, right)    quick_sort(left, mid - 1)    quick_sort(mid, right)Merge Sort배열을 두 부분으로 나누고 각 배열을 정렬한 뒤 하나로 합친다.# seq = []def merge(left, mid, right):    # seq[left:mid + 1]과 seq[mid + 1:right]를 합침    tmp = []    i, j = left, mid + 1    # 두 부분 배열에서 작은 값을 채워 넣음    while i &lt;= mid and j &lt;= right:        if seq[i] &lt; seq[j]:            tmp.append(seq[i])            i += 1        else:            tmp.append(seq[j])            j += 1    # 부분 배열에서 남은 것을 뒤에 추가함    while i &lt;= mid:         tmp.append(seq[i])        i += 1    while j &lt;= right:        tmp.append(seq[j])        j += 1    # 정렬된 배열을 원본 배열에 옮김    seq[left:left+len(tmp)] = tmp[:]def merge_sort(left, right):    # 길이 2 이상의 배열에 대해 분할    if left &gt;= right:        return    mid = (left + right) // 2    # 두 부분으로 나눔    merge_sort(left, mid)    merge_sort(mid + 1, right)    # 나눈 배열을 합침    merge(left, mid, right)🔗 원본 파일 보기"
  },
  
  {
    "title": "편집 거리",
    "url": "/posts/Edit_distance/",
    "categories": "Study, Algorithm",
    "tags": "DP",
    "date": "2024-11-30 01:02:24 +0900",
    





    
    "snippet": "편집 거리문자열 A를 문자열 B로 바꾸는데 필요한 연산(문자 추가, 삭제, 교체)의 최소 횟수DP[i][j]: A[..i]를 B[..j]로 편집하는 연산의 최소 횟수A[i] == B[j]라면 해당 위치에 대해서는 편집할 필요가 없으므로 DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]라면 편집이 필요하다.추가하는 경우는 A[i]...",
    "content": "편집 거리문자열 A를 문자열 B로 바꾸는데 필요한 연산(문자 추가, 삭제, 교체)의 최소 횟수DP[i][j]: A[..i]를 B[..j]로 편집하는 연산의 최소 횟수A[i] == B[j]라면 해당 위치에 대해서는 편집할 필요가 없으므로 DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]라면 편집이 필요하다.추가하는 경우는 A[i]에 문자열을 하나 추가해서 B[j]가 되어야 하므로 DP[i][j - 1] + 1, 즉 A[..i]를 B[..j - 1]로 변경하는 최소 횟수에 1을 더해준다.변경은 A[i]를 B[j]로 바꾸는 것이므로 DP[i - 1][j - 1] + 1삭제는 DP[i - 1][j] + 1이 된다.(A[..i - 1]로 B[j]를 만들었으므로 A[i]를 삭제)🔗 원본 파일 보기"
  },
  
  {
    "title": "위상 정렬",
    "url": "/posts/Topology_Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 00:01:14 +0900",
    





    
    "snippet": "위상정렬비순환 유향 그래프(DAG)에 대해서 정점을 선형으로 정렬하는 것각 노드에 선행 조건이 존재할 때 사용 가능정렬 방법  각 노드의 진입 차수 기록  진입 차수가 0인 정점을 큐에 삽입  큐에 담긴 정점에서 나가는 간선을 제거하고 해당 간선에 연결된 정점의 진입 차수를 감소  2-3과정을 큐가 비거나 모든 정점을 탐색할 때까지 반복구현graph ...",
    "content": "위상정렬비순환 유향 그래프(DAG)에 대해서 정점을 선형으로 정렬하는 것각 노드에 선행 조건이 존재할 때 사용 가능정렬 방법  각 노드의 진입 차수 기록  진입 차수가 0인 정점을 큐에 삽입  큐에 담긴 정점에서 나가는 간선을 제거하고 해당 간선에 연결된 정점의 진입 차수를 감소  2-3과정을 큐가 비거나 모든 정점을 탐색할 때까지 반복구현graph = defaultdict(list)indegree = [0] * (n + 1)# 인접 리스트 및 진입 차수 초기화# for _ in range(k):#     a, b = map(int, input().split())#     graph[a].append(b)#     indegree[b] += 1# 진입 차수 0인 정점 큐에 추가q = deque(filter(lambda x: indegree[x] == 0, range(1, n + 1)))while q:    cur = st.popleft()    print(q)    if cur in graph:        for nxt in graph[cur]:            indegree[nxt] -= 1            if indegree[nxt] == 0:                st.append(nxt)🔗 원본 파일 보기"
  },
  
  {
    "title": "블로그 소개",
    "url": "/posts/Introduce/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2024-11-15 10:28:00 +0900",
    





    
    "snippet": "알고리즘, 자료구조 및 다양한 프로그래밍 관련 내용을 정리한 개인 학습 저장소입니다.",
    "content": "알고리즘, 자료구조 및 다양한 프로그래밍 관련 내용을 정리한 개인 학습 저장소입니다."
  }
  
]

